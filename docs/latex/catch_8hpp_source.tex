\hypertarget{catch_8hpp_source}{}\section{catch.\+hpp}
\label{catch_8hpp_source}\index{lib/catch.hpp@{lib/catch.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{/*}}
\DoxyCodeLine{00002 \textcolor{comment}{ *  Catch v2.5.0}}
\DoxyCodeLine{00003 \textcolor{comment}{ *  Generated: 2018-11-26 20:46:12.165372}}
\DoxyCodeLine{00004 \textcolor{comment}{ *  ----------------------------------------------------------}}
\DoxyCodeLine{00005 \textcolor{comment}{ *  This file has been merged from multiple headers. Please don't edit it directly}}
\DoxyCodeLine{00006 \textcolor{comment}{ *  Copyright (c) 2018 Two Blue Cubes Ltd. All rights reserved.}}
\DoxyCodeLine{00007 \textcolor{comment}{ *}}
\DoxyCodeLine{00008 \textcolor{comment}{ *  Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{00009 \textcolor{comment}{ *  file LICENSE\_1\_0.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{00010 \textcolor{comment}{ */}}
\DoxyCodeLine{00011 \textcolor{preprocessor}{\#ifndef TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{00012 \textcolor{preprocessor}{\#define TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{00013 \textcolor{comment}{// start catch.hpp}}
\DoxyCodeLine{00014 }
\DoxyCodeLine{00015 }
\DoxyCodeLine{00016 \textcolor{preprocessor}{\#define CATCH\_VERSION\_MAJOR 2}}
\DoxyCodeLine{00017 \textcolor{preprocessor}{\#define CATCH\_VERSION\_MINOR 5}}
\DoxyCodeLine{00018 \textcolor{preprocessor}{\#define CATCH\_VERSION\_PATCH 0}}
\DoxyCodeLine{00019 }
\DoxyCodeLine{00020 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{00021 \textcolor{preprocessor}{\#    pragma clang system\_header}}
\DoxyCodeLine{00022 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{00023 \textcolor{preprocessor}{\#    pragma GCC system\_header}}
\DoxyCodeLine{00024 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00025 }
\DoxyCodeLine{00026 \textcolor{comment}{// start catch\_suppress\_warnings.h}}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{00029 \textcolor{preprocessor}{\#   ifdef \_\_ICC // icpc defines the \_\_clang\_\_ macro}}
\DoxyCodeLine{00030 \textcolor{preprocessor}{\#       pragma warning(push)}}
\DoxyCodeLine{00031 \textcolor{preprocessor}{\#       pragma warning(disable: 161 1682)}}
\DoxyCodeLine{00032 \textcolor{preprocessor}{\#   else // \_\_ICC}}
\DoxyCodeLine{00033 \textcolor{preprocessor}{\#       pragma clang diagnostic push}}
\DoxyCodeLine{00034 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "-Wpadded"}}
\DoxyCodeLine{00035 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "-Wswitch-enum"}}
\DoxyCodeLine{00036 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "-Wcovered-switch-default"}}
\DoxyCodeLine{00037 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{00038 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{00039      \textcolor{comment}{// GCC likes to warn on REQUIREs, and we cannot suppress them}}
\DoxyCodeLine{00040      \textcolor{comment}{// locally because g++'s support for \_Pragma is lacking in older,}}
\DoxyCodeLine{00041      \textcolor{comment}{// still supported, versions}}
\DoxyCodeLine{00042 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "-Wparentheses"}}
\DoxyCodeLine{00043 \textcolor{preprocessor}{\#    pragma GCC diagnostic push}}
\DoxyCodeLine{00044 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "-Wunused-variable"}}
\DoxyCodeLine{00045 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "-Wpadded"}}
\DoxyCodeLine{00046 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00047 \textcolor{comment}{// end catch\_suppress\_warnings.h}}
\DoxyCodeLine{00048 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_MAIN) || defined(CATCH\_CONFIG\_RUNNER)}}
\DoxyCodeLine{00049 \textcolor{preprocessor}{\#  define CATCH\_IMPL}}
\DoxyCodeLine{00050 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ALL\_PARTS}}
\DoxyCodeLine{00051 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00052 }
\DoxyCodeLine{00053 \textcolor{comment}{// In the impl file, we want to have access to all parts of the headers}}
\DoxyCodeLine{00054 \textcolor{comment}{// Can also be used to sanely support PCHs}}
\DoxyCodeLine{00055 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ALL\_PARTS)}}
\DoxyCodeLine{00056 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_EXTERNAL\_INTERFACES}}
\DoxyCodeLine{00057 \textcolor{preprocessor}{\#  if defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{00058 \textcolor{preprocessor}{\#    undef CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{00059 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{00060 \textcolor{preprocessor}{\#  if !defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{00061 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{00062 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{00063 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00064 }
\DoxyCodeLine{00065 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_IMPL\_ONLY)}}
\DoxyCodeLine{00066 \textcolor{comment}{// start catch\_platform.h}}
\DoxyCodeLine{00067 }
\DoxyCodeLine{00068 \textcolor{preprocessor}{\#ifdef \_\_APPLE\_\_}}
\DoxyCodeLine{00069 \textcolor{preprocessor}{\# include <TargetConditionals.h>}}
\DoxyCodeLine{00070 \textcolor{preprocessor}{\# if TARGET\_OS\_OSX == 1}}
\DoxyCodeLine{00071 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{00072 \textcolor{preprocessor}{\# elif TARGET\_OS\_IPHONE == 1}}
\DoxyCodeLine{00073 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_IPHONE}}
\DoxyCodeLine{00074 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{00075 }
\DoxyCodeLine{00076 \textcolor{preprocessor}{\#elif defined(linux) || defined(\_\_linux) || defined(\_\_linux\_\_)}}
\DoxyCodeLine{00077 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_LINUX}}
\DoxyCodeLine{00078 }
\DoxyCodeLine{00079 \textcolor{preprocessor}{\#elif defined(WIN32) || defined(\_\_WIN32\_\_) || defined(\_WIN32) || defined(\_MSC\_VER) || defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{00080 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{00081 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00082 }
\DoxyCodeLine{00083 \textcolor{comment}{// end catch\_platform.h}}
\DoxyCodeLine{00084 }
\DoxyCodeLine{00085 \textcolor{preprocessor}{\#ifdef CATCH\_IMPL}}
\DoxyCodeLine{00086 \textcolor{preprocessor}{\#  ifndef CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{00087 \textcolor{preprocessor}{\#    define CLARA\_CONFIG\_MAIN\_NOT\_DEFINED}}
\DoxyCodeLine{00088 \textcolor{preprocessor}{\#    define CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{00089 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{00090 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00091 }
\DoxyCodeLine{00092 \textcolor{comment}{// start catch\_user\_interfaces.h}}
\DoxyCodeLine{00093 }
\DoxyCodeLine{00094 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{00095     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed();}
\DoxyCodeLine{00096 \}}
\DoxyCodeLine{00097 }
\DoxyCodeLine{00098 \textcolor{comment}{// end catch\_user\_interfaces.h}}
\DoxyCodeLine{00099 \textcolor{comment}{// start catch\_tag\_alias\_autoregistrar.h}}
\DoxyCodeLine{00100 }
\DoxyCodeLine{00101 \textcolor{comment}{// start catch\_common.h}}
\DoxyCodeLine{00102 }
\DoxyCodeLine{00103 \textcolor{comment}{// start catch\_compiler\_capabilities.h}}
\DoxyCodeLine{00104 }
\DoxyCodeLine{00105 \textcolor{comment}{// Detect a number of compiler features - by compiler}}
\DoxyCodeLine{00106 \textcolor{comment}{// The following features are defined:}}
\DoxyCodeLine{00107 \textcolor{comment}{//}}
\DoxyCodeLine{00108 \textcolor{comment}{// CATCH\_CONFIG\_COUNTER : is the \_\_COUNTER\_\_ macro supported?}}
\DoxyCodeLine{00109 \textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH : is Windows SEH supported?}}
\DoxyCodeLine{00110 \textcolor{comment}{// CATCH\_CONFIG\_POSIX\_SIGNALS : are POSIX signals supported?}}
\DoxyCodeLine{00111 \textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_EXCEPTIONS : Are exceptions enabled?}}
\DoxyCodeLine{00112 \textcolor{comment}{// ****************}}
\DoxyCodeLine{00113 \textcolor{comment}{// Note to maintainers: if new toggles are added please document them}}
\DoxyCodeLine{00114 \textcolor{comment}{// in configuration.md, too}}
\DoxyCodeLine{00115 \textcolor{comment}{// ****************}}
\DoxyCodeLine{00116 }
\DoxyCodeLine{00117 \textcolor{comment}{// In general each macro has a \_NO\_<feature name> form}}
\DoxyCodeLine{00118 \textcolor{comment}{// (e.g. CATCH\_CONFIG\_NO\_POSIX\_SIGNALS) which disables the feature.}}
\DoxyCodeLine{00119 \textcolor{comment}{// Many features, at point of detection, define an \_INTERNAL\_ macro, so they}}
\DoxyCodeLine{00120 \textcolor{comment}{// can be combined, en-mass, with the \_NO\_ forms later.}}
\DoxyCodeLine{00121 }
\DoxyCodeLine{00122 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{00123 }
\DoxyCodeLine{00124 \textcolor{preprocessor}{\#  if (\_\_cplusplus >= 201402L) || (defined(\_MSVC\_LANG) \&\& \_MSVC\_LANG >= 201402L)}}
\DoxyCodeLine{00125 \textcolor{preprocessor}{\#    define CATCH\_CPP14\_OR\_GREATER}}
\DoxyCodeLine{00126 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{00127 }
\DoxyCodeLine{00128 \textcolor{preprocessor}{\#  if (\_\_cplusplus >= 201703L) || (defined(\_MSVC\_LANG) \&\& \_MSVC\_LANG >= 201703L)}}
\DoxyCodeLine{00129 \textcolor{preprocessor}{\#    define CATCH\_CPP17\_OR\_GREATER}}
\DoxyCodeLine{00130 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{00131 }
\DoxyCodeLine{00132 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00133 }
\DoxyCodeLine{00134 \textcolor{preprocessor}{\#if defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{00135 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{00136 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00137 }
\DoxyCodeLine{00138 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{00139 }
\DoxyCodeLine{00140 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00141 \textcolor{preprocessor}{            \_Pragma( "clang diagnostic push" ) \(\backslash\)}}
\DoxyCodeLine{00142 \textcolor{preprocessor}{            \_Pragma( "clang diagnostic ignored \(\backslash\)"-Wexit-time-destructors\(\backslash\)"" ) \(\backslash\)}}
\DoxyCodeLine{00143 \textcolor{preprocessor}{            \_Pragma( "clang diagnostic ignored \(\backslash\)"-Wglobal-constructors\(\backslash\)"")}}
\DoxyCodeLine{00144 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_UNSUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00145 \textcolor{preprocessor}{            \_Pragma( "clang diagnostic pop" )}}
\DoxyCodeLine{00146 }
\DoxyCodeLine{00147 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00148 \textcolor{preprocessor}{            \_Pragma( "clang diagnostic push" ) \(\backslash\)}}
\DoxyCodeLine{00149 \textcolor{preprocessor}{            \_Pragma( "clang diagnostic ignored \(\backslash\)"-Wparentheses\(\backslash\)"" )}}
\DoxyCodeLine{00150 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_UNSUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00151 \textcolor{preprocessor}{            \_Pragma( "clang diagnostic pop" )}}
\DoxyCodeLine{00152 }
\DoxyCodeLine{00153 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00154 \textcolor{preprocessor}{            \_Pragma( "clang diagnostic push" ) \(\backslash\)}}
\DoxyCodeLine{00155 \textcolor{preprocessor}{            \_Pragma( "clang diagnostic ignored \(\backslash\)"-Wunused-variable\(\backslash\)"" )}}
\DoxyCodeLine{00156 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_UNSUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00157 \textcolor{preprocessor}{            \_Pragma( "clang diagnostic pop" )}}
\DoxyCodeLine{00158 }
\DoxyCodeLine{00159 \textcolor{preprocessor}{\#endif // \_\_clang\_\_}}
\DoxyCodeLine{00160 }
\DoxyCodeLine{00162 \textcolor{comment}{// Assume that non-Windows platforms support posix signals by default}}
\DoxyCodeLine{00163 \textcolor{preprocessor}{\#if !defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{00164 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{00165 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00166 }
\DoxyCodeLine{00168 \textcolor{comment}{// We know some environments not to support full POSIX signals}}
\DoxyCodeLine{00169 \textcolor{preprocessor}{\#if defined(\_\_CYGWIN\_\_) || defined(\_\_QNX\_\_) || defined(\_\_EMSCRIPTEN\_\_) || defined(\_\_DJGPP\_\_)}}
\DoxyCodeLine{00170 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS}}
\DoxyCodeLine{00171 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00172 }
\DoxyCodeLine{00173 \textcolor{preprocessor}{\#ifdef \_\_OS400\_\_}}
\DoxyCodeLine{00174 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS}}
\DoxyCodeLine{00175 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{00176 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00177 }
\DoxyCodeLine{00179 \textcolor{comment}{// Android somehow still does not support std::to\_string}}
\DoxyCodeLine{00180 \textcolor{preprocessor}{\#if defined(\_\_ANDROID\_\_)}}
\DoxyCodeLine{00181 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING}}
\DoxyCodeLine{00182 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00183 }
\DoxyCodeLine{00185 \textcolor{comment}{// Not all Windows environments support SEH properly}}
\DoxyCodeLine{00186 \textcolor{preprocessor}{\#if defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{00187 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_WINDOWS\_SEH}}
\DoxyCodeLine{00188 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00189 }
\DoxyCodeLine{00191 \textcolor{comment}{// PS4}}
\DoxyCodeLine{00192 \textcolor{preprocessor}{\#if defined(\_\_ORBIS\_\_)}}
\DoxyCodeLine{00193 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_NEW\_CAPTURE}}
\DoxyCodeLine{00194 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00195 }
\DoxyCodeLine{00197 \textcolor{comment}{// Cygwin}}
\DoxyCodeLine{00198 \textcolor{preprocessor}{\#ifdef \_\_CYGWIN\_\_}}
\DoxyCodeLine{00199 }
\DoxyCodeLine{00200 \textcolor{comment}{// Required for some versions of Cygwin to declare gettimeofday}}
\DoxyCodeLine{00201 \textcolor{comment}{// see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin}}
\DoxyCodeLine{00202 \textcolor{preprocessor}{\#   define \_BSD\_SOURCE}}
\DoxyCodeLine{00203 \textcolor{comment}{// some versions of cygwin (most) do not support std::to\_string. Use the libstd check.}}
\DoxyCodeLine{00204 \textcolor{comment}{// https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053\_source.html line 2812-2813}}
\DoxyCodeLine{00205 \textcolor{preprocessor}{\# if !((\_\_cplusplus >= 201103L) \&\& defined(\_GLIBCXX\_USE\_C99) \(\backslash\)}}
\DoxyCodeLine{00206 \textcolor{preprocessor}{           \&\& !defined(\_GLIBCXX\_HAVE\_BROKEN\_VSWPRINTF))}}
\DoxyCodeLine{00207 }
\DoxyCodeLine{00208 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING}}
\DoxyCodeLine{00209 }
\DoxyCodeLine{00210 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{00211 \textcolor{preprocessor}{\#endif // \_\_CYGWIN\_\_}}
\DoxyCodeLine{00212 }
\DoxyCodeLine{00214 \textcolor{comment}{// Visual C++}}
\DoxyCodeLine{00215 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{00216 }
\DoxyCodeLine{00217 \textcolor{preprocessor}{\#  if \_MSC\_VER >= 1900 // Visual Studio 2015 or newer}}
\DoxyCodeLine{00218 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{00219 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{00220 }
\DoxyCodeLine{00221 \textcolor{comment}{// Universal Windows platform does not support SEH}}
\DoxyCodeLine{00222 \textcolor{comment}{// Or console colours (or console at all...)}}
\DoxyCodeLine{00223 \textcolor{preprocessor}{\#  if defined(WINAPI\_FAMILY) \&\& (WINAPI\_FAMILY == WINAPI\_FAMILY\_APP)}}
\DoxyCodeLine{00224 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{00225 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{00226 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{00227 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{00228 }
\DoxyCodeLine{00229 \textcolor{comment}{// MSVC traditional preprocessor needs some workaround for \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{00230 \textcolor{comment}{// \_MSVC\_TRADITIONAL == 0 means new conformant preprocessor}}
\DoxyCodeLine{00231 \textcolor{comment}{// \_MSVC\_TRADITIONAL == 1 means old traditional non-conformant preprocessor}}
\DoxyCodeLine{00232 \textcolor{preprocessor}{\#  if !defined(\_MSVC\_TRADITIONAL) || (defined(\_MSVC\_TRADITIONAL) \&\& \_MSVC\_TRADITIONAL)}}
\DoxyCodeLine{00233 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{00234 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{00235 }
\DoxyCodeLine{00236 \textcolor{preprocessor}{\#endif // \_MSC\_VER}}
\DoxyCodeLine{00237 }
\DoxyCodeLine{00239 \textcolor{comment}{// Check if we are compiled with -fno-exceptions or equivalent}}
\DoxyCodeLine{00240 \textcolor{preprocessor}{\#if defined(\_\_EXCEPTIONS) || defined(\_\_cpp\_exceptions) || defined(\_CPPUNWIND)}}
\DoxyCodeLine{00241 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_EXCEPTIONS\_ENABLED}}
\DoxyCodeLine{00242 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00243 }
\DoxyCodeLine{00245 \textcolor{comment}{// DJGPP}}
\DoxyCodeLine{00246 \textcolor{preprocessor}{\#ifdef \_\_DJGPP\_\_}}
\DoxyCodeLine{00247 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_NO\_WCHAR}}
\DoxyCodeLine{00248 \textcolor{preprocessor}{\#endif // \_\_DJGPP\_\_}}
\DoxyCodeLine{00249 }
\DoxyCodeLine{00251 \textcolor{comment}{// Embarcadero C++Build}}
\DoxyCodeLine{00252 \textcolor{preprocessor}{\#if defined(\_\_BORLANDC\_\_)}}
\DoxyCodeLine{00253 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_POLYFILL\_ISNAN}}
\DoxyCodeLine{00254 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00255 }
\DoxyCodeLine{00257 }
\DoxyCodeLine{00258 \textcolor{comment}{// Use of \_\_COUNTER\_\_ is suppressed during code analysis in}}
\DoxyCodeLine{00259 \textcolor{comment}{// CLion/AppCode 2017.2.x and former, because \_\_COUNTER\_\_ is not properly}}
\DoxyCodeLine{00260 \textcolor{comment}{// handled by it.}}
\DoxyCodeLine{00261 \textcolor{comment}{// Otherwise all supported compilers support COUNTER macro,}}
\DoxyCodeLine{00262 \textcolor{comment}{// but user still might want to turn it off}}
\DoxyCodeLine{00263 \textcolor{preprocessor}{\#if ( !defined(\_\_JETBRAINS\_IDE\_\_) || \_\_JETBRAINS\_IDE\_\_ >= 20170300L )}}
\DoxyCodeLine{00264 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_COUNTER}}
\DoxyCodeLine{00265 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00266 }
\DoxyCodeLine{00268 \textcolor{comment}{// Check if string\_view is available and usable}}
\DoxyCodeLine{00269 \textcolor{comment}{// The check is split apart to work around v140 (VS2015) preprocessor issue...}}
\DoxyCodeLine{00270 \textcolor{preprocessor}{\#if defined(\_\_has\_include)}}
\DoxyCodeLine{00271 \textcolor{preprocessor}{\#if \_\_has\_include(<string\_view>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{00272 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{00273 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00274 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00275 }
\DoxyCodeLine{00277 \textcolor{comment}{// Check if variant is available and usable}}
\DoxyCodeLine{00278 \textcolor{preprocessor}{\#if defined(\_\_has\_include)}}
\DoxyCodeLine{00279 \textcolor{preprocessor}{\#  if \_\_has\_include(<variant>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{00280 \textcolor{preprocessor}{\#    if defined(\_\_clang\_\_) \&\& (\_\_clang\_major\_\_ < 8)}}
\DoxyCodeLine{00281        \textcolor{comment}{// work around clang bug with libstdc++ https://bugs.llvm.org/show\_bug.cgi?id=31852}}
\DoxyCodeLine{00282        \textcolor{comment}{// fix should be in clang 8, workaround in libstdc++ 8.2}}
\DoxyCodeLine{00283 \textcolor{preprocessor}{\#      include <ciso646>}}
\DoxyCodeLine{00284 \textcolor{preprocessor}{\#      if defined(\_\_GLIBCXX\_\_) \&\& defined(\_GLIBCXX\_RELEASE) \&\& (\_GLIBCXX\_RELEASE < 9)}}
\DoxyCodeLine{00285 \textcolor{preprocessor}{\#        define CATCH\_CONFIG\_NO\_CPP17\_VARIANT}}
\DoxyCodeLine{00286 \textcolor{preprocessor}{\#     else}}
\DoxyCodeLine{00287 \textcolor{preprocessor}{\#        define CATCH\_INTERNAL\_CONFIG\_CPP17\_VARIANT}}
\DoxyCodeLine{00288 \textcolor{preprocessor}{\#      endif // defined(\_\_GLIBCXX\_\_) \&\& defined(\_GLIBCXX\_RELEASE) \&\& (\_GLIBCXX\_RELEASE < 9)}}
\DoxyCodeLine{00289 \textcolor{preprocessor}{\#    endif // defined(\_\_clang\_\_) \&\& (\_\_clang\_major\_\_ < 8)}}
\DoxyCodeLine{00290 \textcolor{preprocessor}{\#  endif // \_\_has\_include(<variant>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{00291 \textcolor{preprocessor}{\#endif // \_\_has\_include}}
\DoxyCodeLine{00292 }
\DoxyCodeLine{00293 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_COUNTER) \&\& !defined(CATCH\_CONFIG\_NO\_COUNTER) \&\& !defined(CATCH\_CONFIG\_COUNTER)}}
\DoxyCodeLine{00294 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_COUNTER}}
\DoxyCodeLine{00295 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00296 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_WINDOWS\_SEH) \&\& !defined(CATCH\_CONFIG\_NO\_WINDOWS\_SEH) \&\& !defined(CATCH\_CONFIG\_WINDOWS\_SEH) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_WINDOWS\_SEH)}}
\DoxyCodeLine{00297 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{00298 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00299 \textcolor{comment}{// This is set by default, because we assume that unix compilers are posix-signal-compatible by default.}}
\DoxyCodeLine{00300 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_POSIX\_SIGNALS) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS) \&\& !defined(CATCH\_CONFIG\_NO\_POSIX\_SIGNALS) \&\& !defined(CATCH\_CONFIG\_POSIX\_SIGNALS)}}
\DoxyCodeLine{00301 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{00302 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00303 \textcolor{comment}{// This is set by default, because we assume that compilers with no wchar\_t support are just rare exceptions.}}
\DoxyCodeLine{00304 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_NO\_WCHAR) \&\& !defined(CATCH\_CONFIG\_NO\_WCHAR) \&\& !defined(CATCH\_CONFIG\_WCHAR)}}
\DoxyCodeLine{00305 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{00306 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00307 }
\DoxyCodeLine{00308 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11\_TO\_STRING) \&\& !defined(CATCH\_CONFIG\_CPP11\_TO\_STRING)}}
\DoxyCodeLine{00309 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_CPP11\_TO\_STRING}}
\DoxyCodeLine{00310 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00311 }
\DoxyCodeLine{00312 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_UNCAUGHT\_EXCEPTIONS) \&\& !defined(CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)}}
\DoxyCodeLine{00313 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{00314 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00315 }
\DoxyCodeLine{00316 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_STRING\_VIEW) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_STRING\_VIEW) \&\& !defined(CATCH\_CONFIG\_CPP17\_STRING\_VIEW)}}
\DoxyCodeLine{00317 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{00318 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00319 }
\DoxyCodeLine{00320 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_VARIANT) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_VARIANT) \&\& !defined(CATCH\_CONFIG\_CPP17\_VARIANT)}}
\DoxyCodeLine{00321 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_VARIANT}}
\DoxyCodeLine{00322 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00323 }
\DoxyCodeLine{00324 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_EXPERIMENTAL\_REDIRECT)}}
\DoxyCodeLine{00325 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{00326 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00327 }
\DoxyCodeLine{00328 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_NEW\_CAPTURE) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_NEW\_CAPTURE) \&\& !defined(CATCH\_CONFIG\_NO\_NEW\_CAPTURE) \&\& !defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{00329 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{00330 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00331 }
\DoxyCodeLine{00332 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_EXCEPTIONS\_ENABLED) \&\& !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{00333 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_DISABLE\_EXCEPTIONS}}
\DoxyCodeLine{00334 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00335 }
\DoxyCodeLine{00336 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_POLYFILL\_ISNAN) \&\& !defined(CATCH\_CONFIG\_NO\_POLYFILL\_ISNAN) \&\& !defined(CATCH\_CONFIG\_POLYFILL\_ISNAN)}}
\DoxyCodeLine{00337 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_POLYFILL\_ISNAN}}
\DoxyCodeLine{00338 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00339 }
\DoxyCodeLine{00340 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS)}}
\DoxyCodeLine{00341 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS}}
\DoxyCodeLine{00342 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_UNSUPPRESS\_PARENTHESES\_WARNINGS}}
\DoxyCodeLine{00343 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00344 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS)}}
\DoxyCodeLine{00345 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS}}
\DoxyCodeLine{00346 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_UNSUPPRESS\_GLOBALS\_WARNINGS}}
\DoxyCodeLine{00347 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00348 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS)}}
\DoxyCodeLine{00349 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS}}
\DoxyCodeLine{00350 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_UNSUPPRESS\_UNUSED\_WARNINGS}}
\DoxyCodeLine{00351 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00352 }
\DoxyCodeLine{00353 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{00354 \textcolor{preprocessor}{\#define CATCH\_TRY if ((true))}}
\DoxyCodeLine{00355 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ALL if ((false))}}
\DoxyCodeLine{00356 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ANON(type) if ((false))}}
\DoxyCodeLine{00357 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00358 \textcolor{preprocessor}{\#define CATCH\_TRY try}}
\DoxyCodeLine{00359 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ALL catch (...)}}
\DoxyCodeLine{00360 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ANON(type) catch (type)}}
\DoxyCodeLine{00361 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00362 }
\DoxyCodeLine{00363 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR) \&\& !defined(CATCH\_CONFIG\_NO\_TRADITIONAL\_MSVC\_PREPROCESSOR) \&\& !defined(CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR)}}
\DoxyCodeLine{00364 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{00365 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00366 }
\DoxyCodeLine{00367 \textcolor{comment}{// end catch\_compiler\_capabilities.h}}
\DoxyCodeLine{00368 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE2( name, line ) name\#\#line}}
\DoxyCodeLine{00369 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, line ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE2( name, line )}}
\DoxyCodeLine{00370 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_COUNTER}}
\DoxyCodeLine{00371 \textcolor{preprocessor}{\#  define INTERNAL\_CATCH\_UNIQUE\_NAME( name ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, \_\_COUNTER\_\_ )}}
\DoxyCodeLine{00372 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00373 \textcolor{preprocessor}{\#  define INTERNAL\_CATCH\_UNIQUE\_NAME( name ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, \_\_LINE\_\_ )}}
\DoxyCodeLine{00374 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00375 }
\DoxyCodeLine{00376 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{00377 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{00378 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{00379 }
\DoxyCodeLine{00380 \textcolor{comment}{// We need a dummy global operator<< so we can bring it into Catch namespace later}}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00381}\mbox{\hyperlink{structCatch__global__namespace__dummy}{00381}} \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch__global__namespace__dummy}{Catch\_global\_namespace\_dummy}} \{\};}
\DoxyCodeLine{00382 std::ostream\& operator<<(std::ostream\&, \mbox{\hyperlink{structCatch__global__namespace__dummy}{Catch\_global\_namespace\_dummy}});}
\DoxyCodeLine{00383 }
\DoxyCodeLine{00384 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{00385 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00386}\mbox{\hyperlink{structCatch_1_1CaseSensitive}{00386}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1CaseSensitive}{CaseSensitive}} \{ \textcolor{keyword}{enum} Choice \{}
\DoxyCodeLine{00387         Yes,}
\DoxyCodeLine{00388         No}
\DoxyCodeLine{00389     \}; \};}
\DoxyCodeLine{00390 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00391}\mbox{\hyperlink{classCatch_1_1NonCopyable}{00391}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \{}
\DoxyCodeLine{00392         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \textcolor{keyword}{const}\& )              = \textcolor{keyword}{delete};}
\DoxyCodeLine{00393         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \&\& )                  = \textcolor{keyword}{delete};}
\DoxyCodeLine{00394         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}\& operator = ( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00395         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}\& operator = ( \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \&\& )     = \textcolor{keyword}{delete};}
\DoxyCodeLine{00396 }
\DoxyCodeLine{00397     \textcolor{keyword}{protected}:}
\DoxyCodeLine{00398         \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}();}
\DoxyCodeLine{00399         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}}();}
\DoxyCodeLine{00400     \};}
\DoxyCodeLine{00401 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00402}\mbox{\hyperlink{structCatch_1_1SourceLineInfo}{00402}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \{}
\DoxyCodeLine{00403 }
\DoxyCodeLine{00404         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}() = \textcolor{keyword}{delete};}
\DoxyCodeLine{00405         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \_file, std::size\_t \_line ) noexcept}
\DoxyCodeLine{00406         :   file( \_file ),}
\DoxyCodeLine{00407             line( \_line )}
\DoxyCodeLine{00408         \{\}}
\DoxyCodeLine{00409 }
\DoxyCodeLine{00410         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& other )        = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00411         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00412         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}\& operator = ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00413         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}}\& operator = ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00414 }
\DoxyCodeLine{00415         \textcolor{keywordtype}{bool} empty() \textcolor{keyword}{const} noexcept;}
\DoxyCodeLine{00416         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} noexcept;}
\DoxyCodeLine{00417         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} noexcept;}
\DoxyCodeLine{00418 }
\DoxyCodeLine{00419         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* file;}
\DoxyCodeLine{00420         std::size\_t line;}
\DoxyCodeLine{00421     \};}
\DoxyCodeLine{00422 }
\DoxyCodeLine{00423     std::ostream\& operator << ( std::ostream\& os, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{00424 }
\DoxyCodeLine{00425     \textcolor{comment}{// Bring in operator<< from global namespace into Catch namespace}}
\DoxyCodeLine{00426     \textcolor{comment}{// This is necessary because the overload of operator<< above makes}}
\DoxyCodeLine{00427     \textcolor{comment}{// lookup stop at namespace Catch}}
\DoxyCodeLine{00428     using ::operator<<;}
\DoxyCodeLine{00429 }
\DoxyCodeLine{00430     \textcolor{comment}{// Use this in variadic streaming macros to allow}}
\DoxyCodeLine{00431     \textcolor{comment}{//    >> +StreamEndStop}}
\DoxyCodeLine{00432     \textcolor{comment}{// as well as}}
\DoxyCodeLine{00433     \textcolor{comment}{//    >> stuff +StreamEndStop}}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00434}\mbox{\hyperlink{structCatch_1_1StreamEndStop}{00434}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StreamEndStop}{StreamEndStop}} \{}
\DoxyCodeLine{00435         std::string operator+() \textcolor{keyword}{const};}
\DoxyCodeLine{00436     \};}
\DoxyCodeLine{00437     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00438     T \textcolor{keyword}{const}\& operator + ( T \textcolor{keyword}{const}\& value, \mbox{\hyperlink{structCatch_1_1StreamEndStop}{StreamEndStop}} ) \{}
\DoxyCodeLine{00439         \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{00440     \}}
\DoxyCodeLine{00441 \}}
\DoxyCodeLine{00442 }
\DoxyCodeLine{00443 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_LINEINFO \(\backslash\)}}
\DoxyCodeLine{00444 \textcolor{preprocessor}{    ::Catch::SourceLineInfo( \_\_FILE\_\_, static\_cast<std::size\_t>( \_\_LINE\_\_ ) )}}
\DoxyCodeLine{00445 }
\DoxyCodeLine{00446 \textcolor{comment}{// end catch\_common.h}}
\DoxyCodeLine{00447 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{00448 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00449}\mbox{\hyperlink{structCatch_1_1RegistrarForTagAliases}{00449}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1RegistrarForTagAliases}{RegistrarForTagAliases}} \{}
\DoxyCodeLine{00450         \mbox{\hyperlink{structCatch_1_1RegistrarForTagAliases}{RegistrarForTagAliases}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* alias, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* tag, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{00451     \};}
\DoxyCodeLine{00452 }
\DoxyCodeLine{00453 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{00454 }
\DoxyCodeLine{00455 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TAG\_ALIAS( alias, spec ) \(\backslash\)}}
\DoxyCodeLine{00456 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00457 \textcolor{preprocessor}{    namespace\{ Catch::RegistrarForTagAliases INTERNAL\_CATCH\_UNIQUE\_NAME( AutoRegisterTagAlias )( alias, spec, CATCH\_INTERNAL\_LINEINFO ); \} \(\backslash\)}}
\DoxyCodeLine{00458 \textcolor{preprocessor}{    CATCH\_INTERNAL\_UNSUPPRESS\_GLOBALS\_WARNINGS}}
\DoxyCodeLine{00459 }
\DoxyCodeLine{00460 \textcolor{comment}{// end catch\_tag\_alias\_autoregistrar.h}}
\DoxyCodeLine{00461 \textcolor{comment}{// start catch\_test\_registry.h}}
\DoxyCodeLine{00462 }
\DoxyCodeLine{00463 \textcolor{comment}{// start catch\_interfaces\_testcase.h}}
\DoxyCodeLine{00464 }
\DoxyCodeLine{00465 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{00466 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{00467 }
\DoxyCodeLine{00468 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{00469 }
\DoxyCodeLine{00470     \textcolor{keyword}{class }TestSpec;}
\DoxyCodeLine{00471 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00472}\mbox{\hyperlink{structCatch_1_1ITestInvoker}{00472}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}} \{}
\DoxyCodeLine{00473         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke () \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{00474         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}}();}
\DoxyCodeLine{00475     \};}
\DoxyCodeLine{00476 }
\DoxyCodeLine{00477     \textcolor{keyword}{using} ITestCasePtr = std::shared\_ptr<ITestInvoker>;}
\DoxyCodeLine{00478 }
\DoxyCodeLine{00479     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}};}
\DoxyCodeLine{00480     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{00481 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00482}\mbox{\hyperlink{structCatch_1_1ITestCaseRegistry}{00482}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ITestCaseRegistry}{ITestCaseRegistry}} \{}
\DoxyCodeLine{00483         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1ITestCaseRegistry}{ITestCaseRegistry}}();}
\DoxyCodeLine{00484         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTests() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{00485         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestsSorted( IConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{00486     \};}
\DoxyCodeLine{00487 }
\DoxyCodeLine{00488     \textcolor{keywordtype}{bool} matchTest( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{00489     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{00490     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{00491 }
\DoxyCodeLine{00492 \}}
\DoxyCodeLine{00493 }
\DoxyCodeLine{00494 \textcolor{comment}{// end catch\_interfaces\_testcase.h}}
\DoxyCodeLine{00495 \textcolor{comment}{// start catch\_stringref.h}}
\DoxyCodeLine{00496 }
\DoxyCodeLine{00497 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{00498 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{00499 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{00500 }
\DoxyCodeLine{00501 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{00502 }
\DoxyCodeLine{00503     \textcolor{keyword}{class }StringData;}
\DoxyCodeLine{00504 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00512}\mbox{\hyperlink{classCatch_1_1StringRef}{00512}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \{}
\DoxyCodeLine{00513     \textcolor{keyword}{public}:}
\DoxyCodeLine{00514         \textcolor{keyword}{using} size\_type = std::size\_t;}
\DoxyCodeLine{00515 }
\DoxyCodeLine{00516     \textcolor{keyword}{private}:}
\DoxyCodeLine{00517         \textcolor{keyword}{friend} \textcolor{keyword}{struct }StringRefTestAccess;}
\DoxyCodeLine{00518 }
\DoxyCodeLine{00519         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* m\_start;}
\DoxyCodeLine{00520         size\_type m\_size;}
\DoxyCodeLine{00521 }
\DoxyCodeLine{00522         \textcolor{keywordtype}{char}* m\_data = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00523 }
\DoxyCodeLine{00524         \textcolor{keywordtype}{void} takeOwnership();}
\DoxyCodeLine{00525 }
\DoxyCodeLine{00526         \textcolor{keyword}{static} constexpr \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \textcolor{keyword}{const} s\_empty = \textcolor{stringliteral}{""};}
\DoxyCodeLine{00527 }
\DoxyCodeLine{00528     \textcolor{keyword}{public}: \textcolor{comment}{// construction/ assignment}}
\DoxyCodeLine{00529         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}() noexcept}
\DoxyCodeLine{00530         :   \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}( s\_empty, 0 )}
\DoxyCodeLine{00531         \{\}}
\DoxyCodeLine{00532 }
\DoxyCodeLine{00533         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& other ) noexcept}
\DoxyCodeLine{00534         :   m\_start( other.m\_start ),}
\DoxyCodeLine{00535             m\_size( other.m\_size )}
\DoxyCodeLine{00536         \{\}}
\DoxyCodeLine{00537 }
\DoxyCodeLine{00538         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}\&\& other ) noexcept}
\DoxyCodeLine{00539         :   m\_start( other.m\_start ),}
\DoxyCodeLine{00540             m\_size( other.m\_size ),}
\DoxyCodeLine{00541             m\_data( other.m\_data )}
\DoxyCodeLine{00542         \{}
\DoxyCodeLine{00543             other.m\_data = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00544         \}}
\DoxyCodeLine{00545 }
\DoxyCodeLine{00546         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars ) noexcept;}
\DoxyCodeLine{00547 }
\DoxyCodeLine{00548         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, size\_type size ) noexcept}
\DoxyCodeLine{00549         :   m\_start( rawChars ),}
\DoxyCodeLine{00550             m\_size( size )}
\DoxyCodeLine{00551         \{\}}
\DoxyCodeLine{00552 }
\DoxyCodeLine{00553         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}( std::string \textcolor{keyword}{const}\& stdString ) noexcept}
\DoxyCodeLine{00554         :   m\_start( stdString.c\_str() ),}
\DoxyCodeLine{00555             m\_size( stdString.size() )}
\DoxyCodeLine{00556         \{\}}
\DoxyCodeLine{00557 }
\DoxyCodeLine{00558         ~\mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}() noexcept \{}
\DoxyCodeLine{00559             \textcolor{keyword}{delete}[] m\_data;}
\DoxyCodeLine{00560         \}}
\DoxyCodeLine{00561 }
\DoxyCodeLine{00562         \textcolor{keyword}{auto} operator = ( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const} \&other ) noexcept -> \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}\& \{}
\DoxyCodeLine{00563             \textcolor{keyword}{delete}[] m\_data;}
\DoxyCodeLine{00564             m\_data = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00565             m\_start = other.m\_start;}
\DoxyCodeLine{00566             m\_size = other.m\_size;}
\DoxyCodeLine{00567             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{00568         \}}
\DoxyCodeLine{00569 }
\DoxyCodeLine{00570         \textcolor{keyword}{operator} std::string() \textcolor{keyword}{const};}
\DoxyCodeLine{00571 }
\DoxyCodeLine{00572         \textcolor{keywordtype}{void} swap( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}\& other ) noexcept;}
\DoxyCodeLine{00573 }
\DoxyCodeLine{00574     \textcolor{keyword}{public}: \textcolor{comment}{// operators}}
\DoxyCodeLine{00575         \textcolor{keyword}{auto} operator == ( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} noexcept -> bool;}
\DoxyCodeLine{00576         \textcolor{keyword}{auto} operator != ( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} noexcept -> bool;}
\DoxyCodeLine{00577 }
\DoxyCodeLine{00578         \textcolor{keyword}{auto} operator[] ( size\_type index ) \textcolor{keyword}{const} noexcept -> char;}
\DoxyCodeLine{00579 }
\DoxyCodeLine{00580     \textcolor{keyword}{public}: \textcolor{comment}{// named queries}}
\DoxyCodeLine{00581         \textcolor{keyword}{auto} empty() \textcolor{keyword}{const} noexcept -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{00582             \textcolor{keywordflow}{return} m\_size == 0;}
\DoxyCodeLine{00583         \}}
\DoxyCodeLine{00584         \textcolor{keyword}{auto} size() \textcolor{keyword}{const} noexcept -> size\_type \{}
\DoxyCodeLine{00585             \textcolor{keywordflow}{return} m\_size;}
\DoxyCodeLine{00586         \}}
\DoxyCodeLine{00587 }
\DoxyCodeLine{00588         \textcolor{keyword}{auto} numberOfCharacters() \textcolor{keyword}{const} noexcept -> size\_type;}
\DoxyCodeLine{00589         \textcolor{keyword}{auto} c\_str() \textcolor{keyword}{const} -> \textcolor{keywordtype}{char} \textcolor{keyword}{const}*;}
\DoxyCodeLine{00590 }
\DoxyCodeLine{00591     \textcolor{keyword}{public}: \textcolor{comment}{// substrings and searches}}
\DoxyCodeLine{00592         \textcolor{keyword}{auto} substr( size\_type start, size\_type size ) \textcolor{keyword}{const} noexcept -> \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}};}
\DoxyCodeLine{00593 }
\DoxyCodeLine{00594         \textcolor{comment}{// Returns the current start pointer.}}
\DoxyCodeLine{00595         \textcolor{comment}{// Note that the pointer can change when if the StringRef is a substring}}
\DoxyCodeLine{00596         \textcolor{keyword}{auto} currentData() \textcolor{keyword}{const} noexcept -> \textcolor{keywordtype}{char} \textcolor{keyword}{const}*;}
\DoxyCodeLine{00597 }
\DoxyCodeLine{00598     \textcolor{keyword}{private}: \textcolor{comment}{// ownership queries - may not be consistent between calls}}
\DoxyCodeLine{00599         \textcolor{keyword}{auto} isOwned() \textcolor{keyword}{const} noexcept -> bool;}
\DoxyCodeLine{00600         \textcolor{keyword}{auto} isSubstring() \textcolor{keyword}{const} noexcept -> bool;}
\DoxyCodeLine{00601     \};}
\DoxyCodeLine{00602 }
\DoxyCodeLine{00603     \textcolor{keyword}{auto} operator + ( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& rhs ) -> std::string;}
\DoxyCodeLine{00604     \textcolor{keyword}{auto} operator + ( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rhs ) -> std::string;}
\DoxyCodeLine{00605     \textcolor{keyword}{auto} operator + ( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* lhs, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& rhs ) -> std::string;}
\DoxyCodeLine{00606 }
\DoxyCodeLine{00607     \textcolor{keyword}{auto} operator += ( std::string\& lhs, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& sr ) -> std::string\&;}
\DoxyCodeLine{00608     \textcolor{keyword}{auto} operator << ( std::ostream\& os, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& sr ) -> std::ostream\&;}
\DoxyCodeLine{00609 }
\DoxyCodeLine{00610     \textcolor{keyword}{inline} \textcolor{keyword}{auto} \textcolor{keyword}{operator} \textcolor{stringliteral}{""} \_sr( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, std::size\_t size ) noexcept -> \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \{}
\DoxyCodeLine{00611         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}( rawChars, size );}
\DoxyCodeLine{00612     \}}
\DoxyCodeLine{00613 }
\DoxyCodeLine{00614 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{00615 }
\DoxyCodeLine{00616 \textcolor{keyword}{inline} \textcolor{keyword}{auto} \textcolor{keyword}{operator} \textcolor{stringliteral}{""} \_catch\_sr( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, std::size\_t size ) noexcept -> \mbox{\hyperlink{classCatch_1_1StringRef}{Catch::StringRef}} \{}
\DoxyCodeLine{00617     \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1StringRef}{Catch::StringRef}}( rawChars, size );}
\DoxyCodeLine{00618 \}}
\DoxyCodeLine{00619 }
\DoxyCodeLine{00620 \textcolor{comment}{// end catch\_stringref.h}}
\DoxyCodeLine{00621 \textcolor{comment}{// start catch\_type\_traits.hpp}}
\DoxyCodeLine{00622 }
\DoxyCodeLine{00623 }
\DoxyCodeLine{00624 \textcolor{keyword}{namespace }Catch\{}
\DoxyCodeLine{00625 }
\DoxyCodeLine{00626 \textcolor{preprocessor}{\#ifdef CATCH\_CPP17\_OR\_GREATER}}
\DoxyCodeLine{00627     \textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{00628     \textcolor{keyword}{inline} constexpr \textcolor{keyword}{auto} is\_unique = std::true\_type\{\};}
\DoxyCodeLine{00629 }
\DoxyCodeLine{00630     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Rest>}
\DoxyCodeLine{00631     \textcolor{keyword}{inline} constexpr \textcolor{keyword}{auto} is\_unique<T, Rest...> = std::bool\_constant<}
\DoxyCodeLine{00632         (!std::is\_same\_v<T, Rest> \&\& ...) \&\& is\_unique<Rest...>}
\DoxyCodeLine{00633     >\{\};}
\DoxyCodeLine{00634 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00635 }
\DoxyCodeLine{00636 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00637}\mbox{\hyperlink{structCatch_1_1is__unique}{00637}} \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1is__unique}{is\_unique}} : std::true\_type\{\};}
\DoxyCodeLine{00638 }
\DoxyCodeLine{00639 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T0, \textcolor{keyword}{typename} T1, \textcolor{keyword}{typename}... Rest>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00640}\mbox{\hyperlink{structCatch_1_1is__unique_3_01T0_00_01T1_00_01Rest_8_8_8_01_4}{00640}} \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1is__unique}{is\_unique}}<T0, T1, Rest...> : std::integral\_constant}
\DoxyCodeLine{00641 <bool,}
\DoxyCodeLine{00642      !std::is\_same<T0, T1>::value}
\DoxyCodeLine{00643      \&\& is\_unique<T0, Rest...>::value}
\DoxyCodeLine{00644      \&\& is\_unique<T1, Rest...>::value}
\DoxyCodeLine{00645 >\{\};}
\DoxyCodeLine{00646 }
\DoxyCodeLine{00647 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00648 \}}
\DoxyCodeLine{00649 }
\DoxyCodeLine{00650 \textcolor{comment}{// end catch\_type\_traits.hpp}}
\DoxyCodeLine{00651 \textcolor{comment}{// start catch\_preprocessor.hpp}}
\DoxyCodeLine{00652 }
\DoxyCodeLine{00653 }
\DoxyCodeLine{00654 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL0(...) \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{00655 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL1(...) CATCH\_RECURSION\_LEVEL0(CATCH\_RECURSION\_LEVEL0(CATCH\_RECURSION\_LEVEL0(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{00656 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL2(...) CATCH\_RECURSION\_LEVEL1(CATCH\_RECURSION\_LEVEL1(CATCH\_RECURSION\_LEVEL1(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{00657 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL3(...) CATCH\_RECURSION\_LEVEL2(CATCH\_RECURSION\_LEVEL2(CATCH\_RECURSION\_LEVEL2(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{00658 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL4(...) CATCH\_RECURSION\_LEVEL3(CATCH\_RECURSION\_LEVEL3(CATCH\_RECURSION\_LEVEL3(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{00659 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL5(...) CATCH\_RECURSION\_LEVEL4(CATCH\_RECURSION\_LEVEL4(CATCH\_RECURSION\_LEVEL4(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{00660 }
\DoxyCodeLine{00661 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{00662 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND\_VARGS(...) \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{00663 \textcolor{comment}{// MSVC needs more evaluations}}
\DoxyCodeLine{00664 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL6(...) CATCH\_RECURSION\_LEVEL5(CATCH\_RECURSION\_LEVEL5(CATCH\_RECURSION\_LEVEL5(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{00665 \textcolor{preprocessor}{\#define CATCH\_RECURSE(...)  CATCH\_RECURSION\_LEVEL6(CATCH\_RECURSION\_LEVEL6(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{00666 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00667 \textcolor{preprocessor}{\#define CATCH\_RECURSE(...)  CATCH\_RECURSION\_LEVEL5(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{00668 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00669 }
\DoxyCodeLine{00670 \textcolor{preprocessor}{\#define CATCH\_REC\_END(...)}}
\DoxyCodeLine{00671 \textcolor{preprocessor}{\#define CATCH\_REC\_OUT}}
\DoxyCodeLine{00672 }
\DoxyCodeLine{00673 \textcolor{preprocessor}{\#define CATCH\_EMPTY()}}
\DoxyCodeLine{00674 \textcolor{preprocessor}{\#define CATCH\_DEFER(id) id CATCH\_EMPTY()}}
\DoxyCodeLine{00675 }
\DoxyCodeLine{00676 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END2() 0, CATCH\_REC\_END}}
\DoxyCodeLine{00677 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END1(...) CATCH\_REC\_GET\_END2}}
\DoxyCodeLine{00678 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END(...) CATCH\_REC\_GET\_END1}}
\DoxyCodeLine{00679 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT0(test, next, ...) next CATCH\_REC\_OUT}}
\DoxyCodeLine{00680 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT1(test, next) CATCH\_DEFER ( CATCH\_REC\_NEXT0 ) ( test, next, 0)}}
\DoxyCodeLine{00681 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT(test, next)  CATCH\_REC\_NEXT1(CATCH\_REC\_GET\_END test, next)}}
\DoxyCodeLine{00682 }
\DoxyCodeLine{00683 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST0(f, x, peek, ...) , f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{00684 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST1(f, x, peek, ...) , f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST0) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{00685 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST2(f, x, peek, ...)   f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{00686 }
\DoxyCodeLine{00687 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST0\_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{00688 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST1\_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST0\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{00689 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST2\_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{00690 }
\DoxyCodeLine{00691 \textcolor{comment}{// Applies the function macro `f` to each of the remaining parameters, inserts commas between the results,}}
\DoxyCodeLine{00692 \textcolor{comment}{// and passes userdata as the first parameter to each invocation,}}
\DoxyCodeLine{00693 \textcolor{comment}{// e.g. CATCH\_REC\_LIST\_UD(f, x, a, b, c) evaluates to f(x, a), f(x, b), f(x, c)}}
\DoxyCodeLine{00694 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST\_UD(f, userdata, ...) CATCH\_RECURSE(CATCH\_REC\_LIST2\_UD(f, userdata, \_\_VA\_ARGS\_\_, ()()(), ()()(), ()()(), 0))}}
\DoxyCodeLine{00695 }
\DoxyCodeLine{00696 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST(f, ...) CATCH\_RECURSE(CATCH\_REC\_LIST2(f, \_\_VA\_ARGS\_\_, ()()(), ()()(), ()()(), 0))}}
\DoxyCodeLine{00697 }
\DoxyCodeLine{00698 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND1(param) INTERNAL\_CATCH\_EXPAND2(param)}}
\DoxyCodeLine{00699 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND2(...) INTERNAL\_CATCH\_NO\#\# \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{00700 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEF(...) INTERNAL\_CATCH\_DEF \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{00701 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NOINTERNAL\_CATCH\_DEF}}
\DoxyCodeLine{00702 }
\DoxyCodeLine{00703 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS(...) INTERNAL\_CATCH\_EXPAND1(INTERNAL\_CATCH\_DEF \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{00704 }
\DoxyCodeLine{00705 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEMPLATE\_UNIQUE\_NAME2(Name, ...) INTERNAL\_CATCH\_TEMPLATE\_UNIQUE\_NAME3(Name, \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{00706 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{00707 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEMPLATE\_UNIQUE\_NAME3(Name,...) Name " - " \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{00708 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEMPLATE\_UNIQUE\_NAME(Name,...) INTERNAL\_CATCH\_TEMPLATE\_UNIQUE\_NAME2(Name, INTERNAL\_CATCH\_REMOVE\_PARENS(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{00709 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00710 \textcolor{comment}{// MSVC is adding extra space and needs more calls to properly remove ()}}
\DoxyCodeLine{00711 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEMPLATE\_UNIQUE\_NAME3(Name,...) Name " -" \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{00712 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEMPLATE\_UNIQUE\_NAME1(Name, ...) INTERNAL\_CATCH\_TEMPLATE\_UNIQUE\_NAME2(Name, \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{00713 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEMPLATE\_UNIQUE\_NAME(Name, ...) INTERNAL\_CATCH\_TEMPLATE\_UNIQUE\_NAME1(Name, INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_REMOVE\_PARENS(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{00714 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00715 }
\DoxyCodeLine{00716 \textcolor{comment}{// end catch\_preprocessor.hpp}}
\DoxyCodeLine{00717 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{00718 }
\DoxyCodeLine{00719 \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00720}\mbox{\hyperlink{classCatch_1_1TestInvokerAsMethod}{00720}} \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1TestInvokerAsMethod}{TestInvokerAsMethod}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}} \{}
\DoxyCodeLine{00721     void (C::*m\_testAsMethod)();}
\DoxyCodeLine{00722 \textcolor{keyword}{public}:}
\DoxyCodeLine{00723     \mbox{\hyperlink{classCatch_1_1TestInvokerAsMethod}{TestInvokerAsMethod}}( \textcolor{keywordtype}{void} (C::*testAsMethod)() ) noexcept : m\_testAsMethod( testAsMethod ) \{\}}
\DoxyCodeLine{00724 }
\DoxyCodeLine{00725     \textcolor{keywordtype}{void} invoke()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{00726         C obj;}
\DoxyCodeLine{00727         (obj.*m\_testAsMethod)();}
\DoxyCodeLine{00728     \}}
\DoxyCodeLine{00729 \};}
\DoxyCodeLine{00730 }
\DoxyCodeLine{00731 \textcolor{keyword}{auto} makeTestInvoker( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept -> \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}}*;}
\DoxyCodeLine{00732 }
\DoxyCodeLine{00733 template<typename C>}
\DoxyCodeLine{00734 auto makeTestInvoker( \textcolor{keywordtype}{void} (C::*testAsMethod)() ) noexcept -> \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}}* \{}
\DoxyCodeLine{00735     \textcolor{keywordflow}{return} \textcolor{keyword}{new}(std::nothrow) \mbox{\hyperlink{classCatch_1_1TestInvokerAsMethod}{TestInvokerAsMethod<C>}}( testAsMethod );}
\DoxyCodeLine{00736 \}}
\DoxyCodeLine{00737 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00738}\mbox{\hyperlink{structCatch_1_1NameAndTags}{00738}} \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1NameAndTags}{NameAndTags}} \{}
\DoxyCodeLine{00739     \mbox{\hyperlink{structCatch_1_1NameAndTags}{NameAndTags}}( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& name\_ = \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}(), \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& tags\_ = \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}}() ) noexcept;}
\DoxyCodeLine{00740     \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} name;}
\DoxyCodeLine{00741     \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} tags;}
\DoxyCodeLine{00742 \};}
\DoxyCodeLine{00743 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00744}\mbox{\hyperlink{structCatch_1_1AutoReg}{00744}} \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1AutoReg}{AutoReg}} : \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \{}
\DoxyCodeLine{00745     \mbox{\hyperlink{structCatch_1_1AutoReg}{AutoReg}}( \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}}* invoker, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& classOrMethod, \mbox{\hyperlink{structCatch_1_1NameAndTags}{NameAndTags}} \textcolor{keyword}{const}\& nameAndTags ) noexcept;}
\DoxyCodeLine{00746     ~\mbox{\hyperlink{structCatch_1_1AutoReg}{AutoReg}}();}
\DoxyCodeLine{00747 \};}
\DoxyCodeLine{00748 }
\DoxyCodeLine{00749 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{00750 }
\DoxyCodeLine{00751 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{00752 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION( TestName, ... ) \(\backslash\)}}
\DoxyCodeLine{00753 \textcolor{preprocessor}{        static void TestName()}}
\DoxyCodeLine{00754 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION( TestName, ClassName, ... ) \(\backslash\)}}
\DoxyCodeLine{00755 \textcolor{preprocessor}{        namespace\{                        \(\backslash\)}}
\DoxyCodeLine{00756 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName) \{ \(\backslash\)}}
\DoxyCodeLine{00757 \textcolor{preprocessor}{                void test();              \(\backslash\)}}
\DoxyCodeLine{00758 \textcolor{preprocessor}{            \};                            \(\backslash\)}}
\DoxyCodeLine{00759 \textcolor{preprocessor}{        \}                                 \(\backslash\)}}
\DoxyCodeLine{00760 \textcolor{preprocessor}{        void TestName::test()}}
\DoxyCodeLine{00761 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION( TestName, ... )  \(\backslash\)}}
\DoxyCodeLine{00762 \textcolor{preprocessor}{        template<typename TestType>                                             \(\backslash\)}}
\DoxyCodeLine{00763 \textcolor{preprocessor}{        static void TestName()}}
\DoxyCodeLine{00764 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION( TestName, ClassName, ... )    \(\backslash\)}}
\DoxyCodeLine{00765 \textcolor{preprocessor}{        namespace\{                                                                                  \(\backslash\)}}
\DoxyCodeLine{00766 \textcolor{preprocessor}{            template<typename TestType>                                                             \(\backslash\)}}
\DoxyCodeLine{00767 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName <TestType>) \{     \(\backslash\)}}
\DoxyCodeLine{00768 \textcolor{preprocessor}{                void test();                                                                        \(\backslash\)}}
\DoxyCodeLine{00769 \textcolor{preprocessor}{            \};                                                                                      \(\backslash\)}}
\DoxyCodeLine{00770 \textcolor{preprocessor}{        \}                                                                                           \(\backslash\)}}
\DoxyCodeLine{00771 \textcolor{preprocessor}{        template<typename TestType>                                                                 \(\backslash\)}}
\DoxyCodeLine{00772 \textcolor{preprocessor}{        void TestName::test()}}
\DoxyCodeLine{00773 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00774 }
\DoxyCodeLine{00776 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE2( TestName, ... ) \(\backslash\)}}
\DoxyCodeLine{00777 \textcolor{preprocessor}{        static void TestName(); \(\backslash\)}}
\DoxyCodeLine{00778 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00779 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( \&TestName ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); \} }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{00780 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00781 \textcolor{preprocessor}{        static void TestName()}}
\DoxyCodeLine{00782 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE( ... ) \(\backslash\)}}
\DoxyCodeLine{00783 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TESTCASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{00784 }
\DoxyCodeLine{00786 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( QualifiedMethod, ... ) \(\backslash\)}}
\DoxyCodeLine{00787 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00788 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( \&QualifiedMethod ), CATCH\_INTERNAL\_LINEINFO, "\&" \#QualifiedMethod, Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); \} }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{00789 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_GLOBALS\_WARNINGS}}
\DoxyCodeLine{00790 }
\DoxyCodeLine{00792 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( TestName, ClassName, ... )\(\backslash\)}}
\DoxyCodeLine{00793 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00794 \textcolor{preprocessor}{        namespace\{ \(\backslash\)}}
\DoxyCodeLine{00795 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName) \{ \(\backslash\)}}
\DoxyCodeLine{00796 \textcolor{preprocessor}{                void test(); \(\backslash\)}}
\DoxyCodeLine{00797 \textcolor{preprocessor}{            \}; \(\backslash\)}}
\DoxyCodeLine{00798 \textcolor{preprocessor}{            Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar ) ( Catch::makeTestInvoker( \&TestName::test ), CATCH\_INTERNAL\_LINEINFO, \#ClassName, Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{00799 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{00800 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00801 \textcolor{preprocessor}{        void TestName::test()}}
\DoxyCodeLine{00802 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD( ClassName, ... ) \(\backslash\)}}
\DoxyCodeLine{00803 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), ClassName, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{00804 }
\DoxyCodeLine{00806 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, ... ) \(\backslash\)}}
\DoxyCodeLine{00807 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00808 \textcolor{preprocessor}{        Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{00809 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_GLOBALS\_WARNINGS}}
\DoxyCodeLine{00810 }
\DoxyCodeLine{00812 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2(TestName, TestFunc, Name, Tags, ... )\(\backslash\)}}
\DoxyCodeLine{00813 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00814 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{00815 \textcolor{preprocessor}{        static void TestFunc();\(\backslash\)}}
\DoxyCodeLine{00816 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{00817 \textcolor{preprocessor}{            template<typename...Types> \(\backslash\)}}
\DoxyCodeLine{00818 \textcolor{preprocessor}{            struct TestName\{\(\backslash\)}}
\DoxyCodeLine{00819 \textcolor{preprocessor}{                template<typename...Ts> \(\backslash\)}}
\DoxyCodeLine{00820 \textcolor{preprocessor}{                TestName(Ts...names)\{\(\backslash\)}}
\DoxyCodeLine{00821 \textcolor{preprocessor}{                    CATCH\_INTERNAL\_CHECK\_UNIQUE\_TYPES(CATCH\_REC\_LIST(INTERNAL\_CATCH\_REMOVE\_PARENS, \_\_VA\_ARGS\_\_)) \(\backslash\)}}
\DoxyCodeLine{00822 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{00823 \textcolor{preprocessor}{                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestFunc<Types> ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ names, Tags \} ), 0)... \};}\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{00824 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{00825 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{00826 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_REGISTRY\_INITIATE(TestName, Name, \_\_VA\_ARGS\_\_) \(\backslash\)}}
\DoxyCodeLine{00827 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{00828 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00829 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{00830 \textcolor{preprocessor}{        static void TestFunc()}}
\DoxyCodeLine{00831 }
\DoxyCodeLine{00832 \textcolor{preprocessor}{\#if defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{00833 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CHECK\_UNIQUE\_TYPES(...) static\_assert(Catch::is\_unique<\_\_VA\_ARGS\_\_>,"Duplicate type detected in declaration of template test case");}}
\DoxyCodeLine{00834 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00835 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CHECK\_UNIQUE\_TYPES(...) static\_assert(Catch::is\_unique<\_\_VA\_ARGS\_\_>::value,"Duplicate type detected in declaration of template test case");}}
\DoxyCodeLine{00836 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00837 }
\DoxyCodeLine{00838 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{00839 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{00840 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{00841 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00842 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{00843 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{00844 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00845 }
\DoxyCodeLine{00846 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_REGISTRY\_INITIATE(TestName, Name, ...)\(\backslash\)}}
\DoxyCodeLine{00847 \textcolor{preprocessor}{        static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{00848 \textcolor{preprocessor}{            TestName<CATCH\_REC\_LIST(INTERNAL\_CATCH\_REMOVE\_PARENS, \_\_VA\_ARGS\_\_)>(CATCH\_REC\_LIST\_UD(INTERNAL\_CATCH\_TEMPLATE\_UNIQUE\_NAME,Name, \_\_VA\_ARGS\_\_));\(\backslash\)}}
\DoxyCodeLine{00849 \textcolor{preprocessor}{            return 0;\(\backslash\)}}
\DoxyCodeLine{00850 \textcolor{preprocessor}{        \}();}}
\DoxyCodeLine{00851 }
\DoxyCodeLine{00852 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( TestNameClass, TestName, ClassName, Name, Tags, ... ) \(\backslash\)}}
\DoxyCodeLine{00853 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{00854 \textcolor{preprocessor}{        namespace\{ \(\backslash\)}}
\DoxyCodeLine{00855 \textcolor{preprocessor}{            template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{00856 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName <TestType>) \{ \(\backslash\)}}
\DoxyCodeLine{00857 \textcolor{preprocessor}{                void test();\(\backslash\)}}
\DoxyCodeLine{00858 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{00859 \textcolor{preprocessor}{            template<typename...Types> \(\backslash\)}}
\DoxyCodeLine{00860 \textcolor{preprocessor}{            struct TestNameClass\{\(\backslash\)}}
\DoxyCodeLine{00861 \textcolor{preprocessor}{                template<typename...Ts> \(\backslash\)}}
\DoxyCodeLine{00862 \textcolor{preprocessor}{                TestNameClass(Ts...names)\{\(\backslash\)}}
\DoxyCodeLine{00863 \textcolor{preprocessor}{                    CATCH\_INTERNAL\_CHECK\_UNIQUE\_TYPES(CATCH\_REC\_LIST(INTERNAL\_CATCH\_REMOVE\_PARENS, \_\_VA\_ARGS\_\_)) \(\backslash\)}}
\DoxyCodeLine{00864 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{00865 \textcolor{preprocessor}{                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestName<Types>::test ), CATCH\_INTERNAL\_LINEINFO, \#ClassName, Catch::NameAndTags\{ names, Tags \} ), 0)... \};}\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{00866 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{00867 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{00868 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_REGISTRY\_INITIATE(TestNameClass, Name, \_\_VA\_ARGS\_\_)\(\backslash\)}}
\DoxyCodeLine{00869 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{00870 \textcolor{preprocessor}{        CATCH\_INTERNAL\_UNSUPPRESS\_GLOBALS\_WARNINGS\(\backslash\)}}
\DoxyCodeLine{00871 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{00872 \textcolor{preprocessor}{        void TestName<TestType>::test()}}
\DoxyCodeLine{00873 }
\DoxyCodeLine{00874 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{00875 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{00876 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{00877 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00878 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{00879 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{00880 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00881 }
\DoxyCodeLine{00882 \textcolor{comment}{// end catch\_test\_registry.h}}
\DoxyCodeLine{00883 \textcolor{comment}{// start catch\_capture.hpp}}
\DoxyCodeLine{00884 }
\DoxyCodeLine{00885 \textcolor{comment}{// start catch\_assertionhandler.h}}
\DoxyCodeLine{00886 }
\DoxyCodeLine{00887 \textcolor{comment}{// start catch\_assertioninfo.h}}
\DoxyCodeLine{00888 }
\DoxyCodeLine{00889 \textcolor{comment}{// start catch\_result\_type.h}}
\DoxyCodeLine{00890 }
\DoxyCodeLine{00891 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{00892 }
\DoxyCodeLine{00893     \textcolor{comment}{// ResultWas::OfType enum}}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00894}\mbox{\hyperlink{structCatch_1_1ResultWas}{00894}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ResultWas}{ResultWas}} \{ \textcolor{keyword}{enum} OfType \{}
\DoxyCodeLine{00895         Unknown = -1,}
\DoxyCodeLine{00896         Ok = 0,}
\DoxyCodeLine{00897         Info = 1,}
\DoxyCodeLine{00898         Warning = 2,}
\DoxyCodeLine{00899 }
\DoxyCodeLine{00900         FailureBit = 0x10,}
\DoxyCodeLine{00901 }
\DoxyCodeLine{00902         ExpressionFailed = FailureBit | 1,}
\DoxyCodeLine{00903         ExplicitFailure = FailureBit | 2,}
\DoxyCodeLine{00904 }
\DoxyCodeLine{00905         Exception = 0x100 | FailureBit,}
\DoxyCodeLine{00906 }
\DoxyCodeLine{00907         ThrewException = Exception | 1,}
\DoxyCodeLine{00908         DidntThrowException = Exception | 2,}
\DoxyCodeLine{00909 }
\DoxyCodeLine{00910         FatalErrorCondition = 0x200 | FailureBit}
\DoxyCodeLine{00911 }
\DoxyCodeLine{00912     \}; \};}
\DoxyCodeLine{00913 }
\DoxyCodeLine{00914     \textcolor{keywordtype}{bool} isOk( ResultWas::OfType resultType );}
\DoxyCodeLine{00915     \textcolor{keywordtype}{bool} isJustInfo( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{00916 }
\DoxyCodeLine{00917     \textcolor{comment}{// ResultDisposition::Flags enum}}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00918}\mbox{\hyperlink{structCatch_1_1ResultDisposition}{00918}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ResultDisposition}{ResultDisposition}} \{ \textcolor{keyword}{enum} Flags \{}
\DoxyCodeLine{00919         Normal = 0x01,}
\DoxyCodeLine{00920 }
\DoxyCodeLine{00921         ContinueOnFailure = 0x02,   \textcolor{comment}{// Failures fail test, but execution continues}}
\DoxyCodeLine{00922         FalseTest = 0x04,           \textcolor{comment}{// Prefix expression with !}}
\DoxyCodeLine{00923         SuppressFail = 0x08         \textcolor{comment}{// Failures are reported but do not fail the test}}
\DoxyCodeLine{00924     \}; \};}
\DoxyCodeLine{00925 }
\DoxyCodeLine{00926     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );}
\DoxyCodeLine{00927 }
\DoxyCodeLine{00928     \textcolor{keywordtype}{bool} shouldContinueOnFailure( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{00929     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} isFalseTest( \textcolor{keywordtype}{int} flags ) \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::FalseTest ) != 0; \}}
\DoxyCodeLine{00930     \textcolor{keywordtype}{bool} shouldSuppressFailure( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{00931 }
\DoxyCodeLine{00932 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{00933 }
\DoxyCodeLine{00934 \textcolor{comment}{// end catch\_result\_type.h}}
\DoxyCodeLine{00935 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{00936 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00937}\mbox{\hyperlink{structCatch_1_1AssertionInfo}{00937}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}}}
\DoxyCodeLine{00938     \{}
\DoxyCodeLine{00939         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} macroName;}
\DoxyCodeLine{00940         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{00941         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} capturedExpression;}
\DoxyCodeLine{00942         ResultDisposition::Flags resultDisposition;}
\DoxyCodeLine{00943 }
\DoxyCodeLine{00944         \textcolor{comment}{// We want to delete this constructor but a compiler bug in 4.8 means}}
\DoxyCodeLine{00945         \textcolor{comment}{// the struct is then treated as non-aggregate}}
\DoxyCodeLine{00946         \textcolor{comment}{//AssertionInfo() = delete;}}
\DoxyCodeLine{00947     \};}
\DoxyCodeLine{00948 }
\DoxyCodeLine{00949 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{00950 }
\DoxyCodeLine{00951 \textcolor{comment}{// end catch\_assertioninfo.h}}
\DoxyCodeLine{00952 \textcolor{comment}{// start catch\_decomposer.h}}
\DoxyCodeLine{00953 }
\DoxyCodeLine{00954 \textcolor{comment}{// start catch\_tostring.h}}
\DoxyCodeLine{00955 }
\DoxyCodeLine{00956 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{00957 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{00958 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{00959 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{00960 \textcolor{comment}{// start catch\_stream.h}}
\DoxyCodeLine{00961 }
\DoxyCodeLine{00962 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{00963 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{00964 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{00965 }
\DoxyCodeLine{00966 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{00967 }
\DoxyCodeLine{00968     std::ostream\& cout();}
\DoxyCodeLine{00969     std::ostream\& cerr();}
\DoxyCodeLine{00970     std::ostream\& clog();}
\DoxyCodeLine{00971 }
\DoxyCodeLine{00972     \textcolor{keyword}{class }StringRef;}
\DoxyCodeLine{00973 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00974}\mbox{\hyperlink{structCatch_1_1IStream}{00974}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IStream}{IStream}} \{}
\DoxyCodeLine{00975         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1IStream}{IStream}}();}
\DoxyCodeLine{00976         \textcolor{keyword}{virtual} std::ostream\& stream() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{00977     \};}
\DoxyCodeLine{00978 }
\DoxyCodeLine{00979     \textcolor{keyword}{auto} makeStream( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const} \&filename ) -> \mbox{\hyperlink{structCatch_1_1IStream}{IStream}} \textcolor{keyword}{const}*;}
\DoxyCodeLine{00980 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l00981}\mbox{\hyperlink{classCatch_1_1ReusableStringStream}{00981}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ReusableStringStream}{ReusableStringStream}} \{}
\DoxyCodeLine{00982         std::size\_t m\_index;}
\DoxyCodeLine{00983         std::ostream* m\_oss;}
\DoxyCodeLine{00984     \textcolor{keyword}{public}:}
\DoxyCodeLine{00985         \mbox{\hyperlink{classCatch_1_1ReusableStringStream}{ReusableStringStream}}();}
\DoxyCodeLine{00986         ~\mbox{\hyperlink{classCatch_1_1ReusableStringStream}{ReusableStringStream}}();}
\DoxyCodeLine{00987 }
\DoxyCodeLine{00988         \textcolor{keyword}{auto} str() \textcolor{keyword}{const} -> std::string;}
\DoxyCodeLine{00989 }
\DoxyCodeLine{00990         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00991         \textcolor{keyword}{auto} operator << ( T \textcolor{keyword}{const}\& value ) -> \mbox{\hyperlink{classCatch_1_1ReusableStringStream}{ReusableStringStream}}\& \{}
\DoxyCodeLine{00992             *m\_oss << value;}
\DoxyCodeLine{00993             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{00994         \}}
\DoxyCodeLine{00995         \textcolor{keyword}{auto} get() -> std::ostream\& \{ \textcolor{keywordflow}{return} *m\_oss; \}}
\DoxyCodeLine{00996     \};}
\DoxyCodeLine{00997 \}}
\DoxyCodeLine{00998 }
\DoxyCodeLine{00999 \textcolor{comment}{// end catch\_stream.h}}
\DoxyCodeLine{01000 }
\DoxyCodeLine{01001 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{01002 \textcolor{preprocessor}{\#include <string\_view>}}
\DoxyCodeLine{01003 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01004 }
\DoxyCodeLine{01005 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{01006 \textcolor{comment}{// start catch\_objc\_arc.hpp}}
\DoxyCodeLine{01007 }
\DoxyCodeLine{01008 \textcolor{preprocessor}{\#import <Foundation/Foundation.h>}}
\DoxyCodeLine{01009 }
\DoxyCodeLine{01010 \textcolor{preprocessor}{\#ifdef \_\_has\_feature}}
\DoxyCodeLine{01011 \textcolor{preprocessor}{\#define CATCH\_ARC\_ENABLED \_\_has\_feature(objc\_arc)}}
\DoxyCodeLine{01012 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{01013 \textcolor{preprocessor}{\#define CATCH\_ARC\_ENABLED 0}}
\DoxyCodeLine{01014 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01015 }
\DoxyCodeLine{01016 \textcolor{keywordtype}{void} arcSafeRelease( NSObject* obj );}
\DoxyCodeLine{01017 \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel );}
\DoxyCodeLine{01018 }
\DoxyCodeLine{01019 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{01020 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} arcSafeRelease( NSObject* obj ) \{}
\DoxyCodeLine{01021     [obj release];}
\DoxyCodeLine{01022 \}}
\DoxyCodeLine{01023 \textcolor{keyword}{inline} \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel ) \{}
\DoxyCodeLine{01024     \textcolor{keywordflow}{if}( [obj respondsToSelector: sel] )}
\DoxyCodeLine{01025         \textcolor{keywordflow}{return} [obj performSelector: sel];}
\DoxyCodeLine{01026     \textcolor{keywordflow}{return} nil;}
\DoxyCodeLine{01027 \}}
\DoxyCodeLine{01028 \textcolor{preprocessor}{\#define CATCH\_UNSAFE\_UNRETAINED}}
\DoxyCodeLine{01029 \textcolor{preprocessor}{\#define CATCH\_ARC\_STRONG}}
\DoxyCodeLine{01030 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{01031 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} arcSafeRelease( NSObject* )\{\}}
\DoxyCodeLine{01032 \textcolor{keyword}{inline} \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel ) \{}
\DoxyCodeLine{01033 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{01034 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{01035 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "-Warc-performSelector-leaks"}}
\DoxyCodeLine{01036 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01037     \textcolor{keywordflow}{if}( [obj respondsToSelector: sel] )}
\DoxyCodeLine{01038         \textcolor{keywordflow}{return} [obj performSelector: sel];}
\DoxyCodeLine{01039 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{01040 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{01041 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01042     \textcolor{keywordflow}{return} nil;}
\DoxyCodeLine{01043 \}}
\DoxyCodeLine{01044 \textcolor{preprocessor}{\#define CATCH\_UNSAFE\_UNRETAINED \_\_unsafe\_unretained}}
\DoxyCodeLine{01045 \textcolor{preprocessor}{\#define CATCH\_ARC\_STRONG \_\_strong}}
\DoxyCodeLine{01046 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01047 }
\DoxyCodeLine{01048 \textcolor{comment}{// end catch\_objc\_arc.hpp}}
\DoxyCodeLine{01049 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01050 }
\DoxyCodeLine{01051 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{01052 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{01053 \textcolor{preprocessor}{\#pragma warning(disable:4180) // We attempt to stream a function (address) by const\&, which MSVC complains about but is harmless}}
\DoxyCodeLine{01054 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01055 }
\DoxyCodeLine{01056 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{01057     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{01058 }
\DoxyCodeLine{01059         \textcolor{keyword}{extern} \textcolor{keyword}{const} std::string unprintableString;}
\DoxyCodeLine{01060 }
\DoxyCodeLine{01061         std::string rawMemoryToString( \textcolor{keyword}{const} \textcolor{keywordtype}{void} *\textcolor{keywordtype}{object}, std::size\_t size );}
\DoxyCodeLine{01062 }
\DoxyCodeLine{01063         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01064         std::string rawMemoryToString( \textcolor{keyword}{const} T\& \textcolor{keywordtype}{object} ) \{}
\DoxyCodeLine{01065           \textcolor{keywordflow}{return} rawMemoryToString( \&\textcolor{keywordtype}{object}, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{object}) );}
\DoxyCodeLine{01066         \}}
\DoxyCodeLine{01067 }
\DoxyCodeLine{01068         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01069}\mbox{\hyperlink{classCatch_1_1Detail_1_1IsStreamInsertable}{01069}}         \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Detail_1_1IsStreamInsertable}{IsStreamInsertable}} \{}
\DoxyCodeLine{01070             \textcolor{keyword}{template}<\textcolor{keyword}{typename} SS, \textcolor{keyword}{typename} TT>}
\DoxyCodeLine{01071             \textcolor{keyword}{static} \textcolor{keyword}{auto} test(\textcolor{keywordtype}{int})}
\DoxyCodeLine{01072                 -> decltype(std::declval<SS\&>() << std::declval<TT>(), std::true\_type());}
\DoxyCodeLine{01073 }
\DoxyCodeLine{01074             \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}>}
\DoxyCodeLine{01075             \textcolor{keyword}{static} \textcolor{keyword}{auto} test(...)->std::false\_type;}
\DoxyCodeLine{01076 }
\DoxyCodeLine{01077         \textcolor{keyword}{public}:}
\DoxyCodeLine{01078             \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = decltype(test<std::ostream, const T\&>(0))::value;}
\DoxyCodeLine{01079         \};}
\DoxyCodeLine{01080 }
\DoxyCodeLine{01081         \textcolor{keyword}{template}<\textcolor{keyword}{typename} E>}
\DoxyCodeLine{01082         std::string convertUnknownEnumToString( E e );}
\DoxyCodeLine{01083 }
\DoxyCodeLine{01084         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01085         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{01086             !std::is\_enum<T>::value \&\& !std::is\_base\_of<std::exception, T>::value,}
\DoxyCodeLine{01087         std::string>::type convertUnstreamable( T \textcolor{keyword}{const}\& ) \{}
\DoxyCodeLine{01088             \textcolor{keywordflow}{return} Detail::unprintableString;}
\DoxyCodeLine{01089         \}}
\DoxyCodeLine{01090         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01091         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{01092             !std::is\_enum<T>::value \&\& std::is\_base\_of<std::exception, T>::value,}
\DoxyCodeLine{01093          std::string>::type convertUnstreamable(T \textcolor{keyword}{const}\& ex) \{}
\DoxyCodeLine{01094             \textcolor{keywordflow}{return} ex.what();}
\DoxyCodeLine{01095         \}}
\DoxyCodeLine{01096 }
\DoxyCodeLine{01097         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01098         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{01099             std::is\_enum<T>::value}
\DoxyCodeLine{01100         , std::string>::type convertUnstreamable( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{01101             \textcolor{keywordflow}{return} convertUnknownEnumToString( value );}
\DoxyCodeLine{01102         \}}
\DoxyCodeLine{01103 }
\DoxyCodeLine{01104 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{01105         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01107         std::string clrReferenceToString( T\string^ ref ) \{}
\DoxyCodeLine{01108             \textcolor{keywordflow}{if} (ref == \textcolor{keyword}{nullptr})}
\DoxyCodeLine{01109                 \textcolor{keywordflow}{return} std::string(\textcolor{stringliteral}{"null"});}
\DoxyCodeLine{01110             \textcolor{keyword}{auto} bytes = System::Text::Encoding::UTF8->GetBytes(ref->ToString());}
\DoxyCodeLine{01111             cli::pin\_ptr<System::Byte> p = \&bytes[0];}
\DoxyCodeLine{01112             \textcolor{keywordflow}{return} std::string(reinterpret\_cast<char const *>(p), bytes->Length);}
\DoxyCodeLine{01113         \}}
\DoxyCodeLine{01114 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01115 }
\DoxyCodeLine{01116     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{01117 }
\DoxyCodeLine{01118     \textcolor{comment}{// If we decide for C++14, change these to enable\_if\_ts}}
\DoxyCodeLine{01119     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01120}\mbox{\hyperlink{structCatch_1_1StringMaker}{01120}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}} \{}
\DoxyCodeLine{01121         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fake = T>}
\DoxyCodeLine{01122         \textcolor{keyword}{static}}
\DoxyCodeLine{01123         \textcolor{keyword}{typename} std::enable\_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type}
\DoxyCodeLine{01124             convert(\textcolor{keyword}{const} Fake\& value) \{}
\DoxyCodeLine{01125                 \mbox{\hyperlink{classCatch_1_1ReusableStringStream}{ReusableStringStream}} rss;}
\DoxyCodeLine{01126                 \textcolor{comment}{// NB: call using the function-like syntax to avoid ambiguity with}}
\DoxyCodeLine{01127                 \textcolor{comment}{// user-defined templated operator<< under clang.}}
\DoxyCodeLine{01128                 rss.operator<<(value);}
\DoxyCodeLine{01129                 \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{01130         \}}
\DoxyCodeLine{01131 }
\DoxyCodeLine{01132         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fake = T>}
\DoxyCodeLine{01133         \textcolor{keyword}{static}}
\DoxyCodeLine{01134         \textcolor{keyword}{typename} std::enable\_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type}
\DoxyCodeLine{01135             convert( \textcolor{keyword}{const} Fake\& value ) \{}
\DoxyCodeLine{01136 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_FALLBACK\_STRINGIFIER)}}
\DoxyCodeLine{01137             \textcolor{keywordflow}{return} Detail::convertUnstreamable(value);}
\DoxyCodeLine{01138 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{01139             \textcolor{keywordflow}{return} CATCH\_CONFIG\_FALLBACK\_STRINGIFIER(value);}
\DoxyCodeLine{01140 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01141         \}}
\DoxyCodeLine{01142     \};}
\DoxyCodeLine{01143 }
\DoxyCodeLine{01144     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{01145 }
\DoxyCodeLine{01146         \textcolor{comment}{// This function dispatches all stringification requests inside of Catch.}}
\DoxyCodeLine{01147         \textcolor{comment}{// Should be preferably called fully qualified, like ::Catch::Detail::stringify}}
\DoxyCodeLine{01148         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01149         std::string stringify(\textcolor{keyword}{const} T\& e) \{}
\DoxyCodeLine{01150             return ::Catch::StringMaker<typename std::remove\_cv<typename std::remove\_reference<T>::type>::type>::convert(e);}
\DoxyCodeLine{01151         \}}
\DoxyCodeLine{01152 }
\DoxyCodeLine{01153         \textcolor{keyword}{template}<\textcolor{keyword}{typename} E>}
\DoxyCodeLine{01154         std::string convertUnknownEnumToString( E e ) \{}
\DoxyCodeLine{01155             return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}typename std::underlying\_type<E>::type\textcolor{keyword}{>}(e));}
\DoxyCodeLine{01156         \}}
\DoxyCodeLine{01157 }
\DoxyCodeLine{01158 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{01159         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01160         std::string stringify( T\string^ e ) \{}
\DoxyCodeLine{01161             return ::Catch::StringMaker<T\string^>::convert(e);}
\DoxyCodeLine{01162         \}}
\DoxyCodeLine{01163 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01164 }
\DoxyCodeLine{01165     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{01166 }
\DoxyCodeLine{01167     \textcolor{comment}{// Some predefined specializations}}
\DoxyCodeLine{01168 }
\DoxyCodeLine{01169     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01170}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01std_1_1string_01_4}{01170}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<std::string> \{}
\DoxyCodeLine{01171         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::string\& str);}
\DoxyCodeLine{01172     \};}
\DoxyCodeLine{01173 }
\DoxyCodeLine{01174 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{01175     \textcolor{keyword}{template}<>}
\DoxyCodeLine{01176     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<std::string\_view> \{}
\DoxyCodeLine{01177         \textcolor{keyword}{static} std::string convert(std::string\_view str);}
\DoxyCodeLine{01178     \};}
\DoxyCodeLine{01179 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01180 }
\DoxyCodeLine{01181     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01182}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01char_01const_01_5_01_4}{01182}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<char const *> \{}
\DoxyCodeLine{01183         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const} * str);}
\DoxyCodeLine{01184     \};}
\DoxyCodeLine{01185     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01186}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01char_01_5_01_4}{01186}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<char *> \{}
\DoxyCodeLine{01187         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} * str);}
\DoxyCodeLine{01188     \};}
\DoxyCodeLine{01189 }
\DoxyCodeLine{01190 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{01191     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01192}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01std_1_1wstring_01_4}{01192}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<std::wstring> \{}
\DoxyCodeLine{01193         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::wstring\& wstr);}
\DoxyCodeLine{01194     \};}
\DoxyCodeLine{01195 }
\DoxyCodeLine{01196 \textcolor{preprocessor}{\# ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{01197     \textcolor{keyword}{template}<>}
\DoxyCodeLine{01198     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<std::wstring\_view> \{}
\DoxyCodeLine{01199         \textcolor{keyword}{static} std::string convert(std::wstring\_view str);}
\DoxyCodeLine{01200     \};}
\DoxyCodeLine{01201 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{01202 }
\DoxyCodeLine{01203     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01204}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01wchar__t_01const_01_5_01_4}{01204}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<wchar\_t const *> \{}
\DoxyCodeLine{01205         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * str);}
\DoxyCodeLine{01206     \};}
\DoxyCodeLine{01207     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01208}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01wchar__t_01_5_01_4}{01208}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<wchar\_t *> \{}
\DoxyCodeLine{01209         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{wchar\_t} * str);}
\DoxyCodeLine{01210     \};}
\DoxyCodeLine{01211 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01212 }
\DoxyCodeLine{01213     \textcolor{comment}{// TBD: Should we use `strnlen` to ensure that we don't go out of the buffer,}}
\DoxyCodeLine{01214     \textcolor{comment}{//      while keeping string semantics?}}
\DoxyCodeLine{01215     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01216}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01char[SZ]_4}{01216}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<char[SZ]> \{}
\DoxyCodeLine{01217         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{01218             return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{01219         \}}
\DoxyCodeLine{01220     \};}
\DoxyCodeLine{01221     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01222}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01signed_01char[SZ]_4}{01222}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<signed char[SZ]> \{}
\DoxyCodeLine{01223         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{01224             return ::Catch::Detail::stringify(std::string\{ reinterpret\_cast<char const *>(str) \});}
\DoxyCodeLine{01225         \}}
\DoxyCodeLine{01226     \};}
\DoxyCodeLine{01227     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01228}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01unsigned_01char[SZ]_4}{01228}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<unsigned char[SZ]> \{}
\DoxyCodeLine{01229         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{01230             return ::Catch::Detail::stringify(std::string\{ reinterpret\_cast<char const *>(str) \});}
\DoxyCodeLine{01231         \}}
\DoxyCodeLine{01232     \};}
\DoxyCodeLine{01233 }
\DoxyCodeLine{01234     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01235}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01int_01_4}{01235}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<int> \{}
\DoxyCodeLine{01236         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{int} value);}
\DoxyCodeLine{01237     \};}
\DoxyCodeLine{01238     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01239}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01long_01_4}{01239}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<long> \{}
\DoxyCodeLine{01240         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{long} value);}
\DoxyCodeLine{01241     \};}
\DoxyCodeLine{01242     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01243}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01long_01long_01_4}{01243}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<long long> \{}
\DoxyCodeLine{01244         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{01245     \};}
\DoxyCodeLine{01246     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01247}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01unsigned_01int_01_4}{01247}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<unsigned int> \{}
\DoxyCodeLine{01248         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} value);}
\DoxyCodeLine{01249     \};}
\DoxyCodeLine{01250     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01251}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01unsigned_01long_01_4}{01251}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<unsigned long> \{}
\DoxyCodeLine{01252         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{01253     \};}
\DoxyCodeLine{01254     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01255}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01unsigned_01long_01long_01_4}{01255}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<unsigned long long> \{}
\DoxyCodeLine{01256         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{01257     \};}
\DoxyCodeLine{01258 }
\DoxyCodeLine{01259     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01260}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01bool_01_4}{01260}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<bool> \{}
\DoxyCodeLine{01261         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{bool} b);}
\DoxyCodeLine{01262     \};}
\DoxyCodeLine{01263 }
\DoxyCodeLine{01264     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01265}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01char_01_4}{01265}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<char> \{}
\DoxyCodeLine{01266         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} c);}
\DoxyCodeLine{01267     \};}
\DoxyCodeLine{01268     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01269}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01signed_01char_01_4}{01269}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<signed char> \{}
\DoxyCodeLine{01270         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} c);}
\DoxyCodeLine{01271     \};}
\DoxyCodeLine{01272     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01273}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01unsigned_01char_01_4}{01273}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<unsigned char> \{}
\DoxyCodeLine{01274         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c);}
\DoxyCodeLine{01275     \};}
\DoxyCodeLine{01276 }
\DoxyCodeLine{01277     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01278}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01std_1_1nullptr__t_01_4}{01278}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<std::nullptr\_t> \{}
\DoxyCodeLine{01279         \textcolor{keyword}{static} std::string convert(std::nullptr\_t);}
\DoxyCodeLine{01280     \};}
\DoxyCodeLine{01281 }
\DoxyCodeLine{01282     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01283}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01float_01_4}{01283}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<float> \{}
\DoxyCodeLine{01284         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{float} value);}
\DoxyCodeLine{01285     \};}
\DoxyCodeLine{01286     \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01287}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01double_01_4}{01287}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<double> \{}
\DoxyCodeLine{01288         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{double} value);}
\DoxyCodeLine{01289     \};}
\DoxyCodeLine{01290 }
\DoxyCodeLine{01291     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01292}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01T_01_5_01_4}{01292}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<T*> \{}
\DoxyCodeLine{01293         \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{01294         \textcolor{keyword}{static} std::string convert(U* p) \{}
\DoxyCodeLine{01295             \textcolor{keywordflow}{if} (p) \{}
\DoxyCodeLine{01296                 return ::Catch::Detail::rawMemoryToString(p);}
\DoxyCodeLine{01297             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{01298                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"nullptr"};}
\DoxyCodeLine{01299             \}}
\DoxyCodeLine{01300         \}}
\DoxyCodeLine{01301     \};}
\DoxyCodeLine{01302 }
\DoxyCodeLine{01303     \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename} C>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01304}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01R_01C_1_1_5_01_4}{01304}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<R C::*> \{}
\DoxyCodeLine{01305         \textcolor{keyword}{static} std::string convert(R C::* p) \{}
\DoxyCodeLine{01306             \textcolor{keywordflow}{if} (p) \{}
\DoxyCodeLine{01307                 return ::Catch::Detail::rawMemoryToString(p);}
\DoxyCodeLine{01308             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{01309                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"nullptr"};}
\DoxyCodeLine{01310             \}}
\DoxyCodeLine{01311         \}}
\DoxyCodeLine{01312     \};}
\DoxyCodeLine{01313 }
\DoxyCodeLine{01314 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{01315     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01316     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<T\string^> \{}
\DoxyCodeLine{01317         \textcolor{keyword}{static} std::string convert( T\string^ ref ) \{}
\DoxyCodeLine{01318             return ::Catch::Detail::clrReferenceToString(ref);}
\DoxyCodeLine{01319         \}}
\DoxyCodeLine{01320     \};}
\DoxyCodeLine{01321 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01322 }
\DoxyCodeLine{01323     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{01324         \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterator>}
\DoxyCodeLine{01325         std::string rangeToString(InputIterator first, InputIterator last) \{}
\DoxyCodeLine{01326             ReusableStringStream rss;}
\DoxyCodeLine{01327             rss << \textcolor{stringliteral}{"\{ "};}
\DoxyCodeLine{01328             \textcolor{keywordflow}{if} (first != last) \{}
\DoxyCodeLine{01329                 rss << ::Catch::Detail::stringify(*first);}
\DoxyCodeLine{01330                 \textcolor{keywordflow}{for} (++first; first != last; ++first)}
\DoxyCodeLine{01331                     rss << \textcolor{stringliteral}{", "} << ::Catch::Detail::stringify(*first);}
\DoxyCodeLine{01332             \}}
\DoxyCodeLine{01333             rss << \textcolor{stringliteral}{" \}"};}
\DoxyCodeLine{01334             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{01335         \}}
\DoxyCodeLine{01336     \}}
\DoxyCodeLine{01337 }
\DoxyCodeLine{01338 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{01339     \textcolor{keyword}{template}<>}
\DoxyCodeLine{01340     \textcolor{keyword}{struct }StringMaker<NSString*> \{}
\DoxyCodeLine{01341         \textcolor{keyword}{static} std::string convert(NSString * nsstring) \{}
\DoxyCodeLine{01342             \textcolor{keywordflow}{if} (!nsstring)}
\DoxyCodeLine{01343                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"nil"};}
\DoxyCodeLine{01344             \textcolor{keywordflow}{return} std::string(\textcolor{stringliteral}{"@"}) + [nsstring UTF8String];}
\DoxyCodeLine{01345         \}}
\DoxyCodeLine{01346     \};}
\DoxyCodeLine{01347     \textcolor{keyword}{template}<>}
\DoxyCodeLine{01348     \textcolor{keyword}{struct }StringMaker<NSObject*> \{}
\DoxyCodeLine{01349         \textcolor{keyword}{static} std::string convert(NSObject* nsObject) \{}
\DoxyCodeLine{01350             return ::Catch::Detail::stringify([nsObject description]);}
\DoxyCodeLine{01351         \}}
\DoxyCodeLine{01352 }
\DoxyCodeLine{01353     \};}
\DoxyCodeLine{01354     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{01355         \textcolor{keyword}{inline} std::string stringify( NSString* nsstring ) \{}
\DoxyCodeLine{01356             \textcolor{keywordflow}{return} StringMaker<NSString*>::convert( nsstring );}
\DoxyCodeLine{01357         \}}
\DoxyCodeLine{01358 }
\DoxyCodeLine{01359     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{01360 \textcolor{preprocessor}{\#endif // \_\_OBJC\_\_}}
\DoxyCodeLine{01361 }
\DoxyCodeLine{01362 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{01363 }
\DoxyCodeLine{01365 \textcolor{comment}{// Separate std-lib types stringification, so it can be selectively enabled}}
\DoxyCodeLine{01366 \textcolor{comment}{// This means that we do not bring in}}
\DoxyCodeLine{01367 }
\DoxyCodeLine{01368 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_ALL\_STRINGMAKERS)}}
\DoxyCodeLine{01369 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER}}
\DoxyCodeLine{01370 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER}}
\DoxyCodeLine{01371 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER}}
\DoxyCodeLine{01372 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{01373 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01374 }
\DoxyCodeLine{01375 \textcolor{comment}{// Separate std::pair specialization}}
\DoxyCodeLine{01376 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER)}}
\DoxyCodeLine{01377 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{01378 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{01379     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{01380     \textcolor{keyword}{struct }StringMaker<std::pair<T1, T2> > \{}
\DoxyCodeLine{01381         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::pair<T1, T2>\& pair) \{}
\DoxyCodeLine{01382             ReusableStringStream rss;}
\DoxyCodeLine{01383             rss << \textcolor{stringliteral}{"\{ "}}
\DoxyCodeLine{01384                 << ::Catch::Detail::stringify(pair.first)}
\DoxyCodeLine{01385                 << \textcolor{stringliteral}{", "}}
\DoxyCodeLine{01386                 << ::Catch::Detail::stringify(pair.second)}
\DoxyCodeLine{01387                 << \textcolor{stringliteral}{" \}"};}
\DoxyCodeLine{01388             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{01389         \}}
\DoxyCodeLine{01390     \};}
\DoxyCodeLine{01391 \}}
\DoxyCodeLine{01392 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER}}
\DoxyCodeLine{01393 }
\DoxyCodeLine{01394 \textcolor{comment}{// Separate std::tuple specialization}}
\DoxyCodeLine{01395 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER)}}
\DoxyCodeLine{01396 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{01397 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{01398     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{01399         \textcolor{keyword}{template}<}
\DoxyCodeLine{01400             \textcolor{keyword}{typename} Tuple,}
\DoxyCodeLine{01401             std::size\_t N = 0,}
\DoxyCodeLine{01402             \textcolor{keywordtype}{bool} = (N < std::tuple\_size<Tuple>::value)}
\DoxyCodeLine{01403             >}
\DoxyCodeLine{01404             \textcolor{keyword}{struct} TupleElementPrinter \{}
\DoxyCodeLine{01405             \textcolor{keyword}{static} \textcolor{keywordtype}{void} print(\textcolor{keyword}{const} Tuple\& tuple, std::ostream\& os) \{}
\DoxyCodeLine{01406                 os << (N ? \textcolor{stringliteral}{", "} : \textcolor{stringliteral}{" "})}
\DoxyCodeLine{01407                     << ::Catch::Detail::stringify(std::get<N>(tuple));}
\DoxyCodeLine{01408                 TupleElementPrinter<Tuple, N + 1>::print(tuple, os);}
\DoxyCodeLine{01409             \}}
\DoxyCodeLine{01410         \};}
\DoxyCodeLine{01411 }
\DoxyCodeLine{01412         \textcolor{keyword}{template}<}
\DoxyCodeLine{01413             \textcolor{keyword}{typename} Tuple,}
\DoxyCodeLine{01414             std::size\_t N}
\DoxyCodeLine{01415         >}
\DoxyCodeLine{01416             \textcolor{keyword}{struct }TupleElementPrinter<Tuple, N, false> \{}
\DoxyCodeLine{01417             \textcolor{keyword}{static} \textcolor{keywordtype}{void} print(\textcolor{keyword}{const} Tuple\&, std::ostream\&) \{\}}
\DoxyCodeLine{01418         \};}
\DoxyCodeLine{01419 }
\DoxyCodeLine{01420     \}}
\DoxyCodeLine{01421 }
\DoxyCodeLine{01422     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...Types>}
\DoxyCodeLine{01423     \textcolor{keyword}{struct }StringMaker<std::tuple<Types...>> \{}
\DoxyCodeLine{01424         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::tuple<Types...>\& tuple) \{}
\DoxyCodeLine{01425             ReusableStringStream rss;}
\DoxyCodeLine{01426             rss << \textcolor{charliteral}{'\{'};}
\DoxyCodeLine{01427             Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());}
\DoxyCodeLine{01428             rss << \textcolor{stringliteral}{" \}"};}
\DoxyCodeLine{01429             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{01430         \}}
\DoxyCodeLine{01431     \};}
\DoxyCodeLine{01432 \}}
\DoxyCodeLine{01433 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER}}
\DoxyCodeLine{01434 }
\DoxyCodeLine{01435 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER) \&\& defined(CATCH\_CONFIG\_CPP17\_VARIANT)}}
\DoxyCodeLine{01436 \textcolor{preprocessor}{\#include <variant>}}
\DoxyCodeLine{01437 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{01438     \textcolor{keyword}{template}<>}
\DoxyCodeLine{01439     \textcolor{keyword}{struct }StringMaker<std::monostate> \{}
\DoxyCodeLine{01440         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::monostate\&) \{}
\DoxyCodeLine{01441             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"\{ \}"};}
\DoxyCodeLine{01442         \}}
\DoxyCodeLine{01443     \};}
\DoxyCodeLine{01444 }
\DoxyCodeLine{01445     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Elements>}
\DoxyCodeLine{01446     \textcolor{keyword}{struct }StringMaker<std::variant<Elements...>> \{}
\DoxyCodeLine{01447         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::variant<Elements...>\& variant) \{}
\DoxyCodeLine{01448             \textcolor{keywordflow}{if} (variant.valueless\_by\_exception()) \{}
\DoxyCodeLine{01449                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"\{valueless variant\}"};}
\DoxyCodeLine{01450             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{01451                 \textcolor{keywordflow}{return} std::visit(}
\DoxyCodeLine{01452                     [](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& value) \{}
\DoxyCodeLine{01453                         return ::Catch::Detail::stringify(value);}
\DoxyCodeLine{01454                     \},}
\DoxyCodeLine{01455                     variant}
\DoxyCodeLine{01456                 );}
\DoxyCodeLine{01457             \}}
\DoxyCodeLine{01458         \}}
\DoxyCodeLine{01459     \};}
\DoxyCodeLine{01460 \}}
\DoxyCodeLine{01461 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER}}
\DoxyCodeLine{01462 }
\DoxyCodeLine{01463 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01464}\mbox{\hyperlink{structCatch_1_1not__this__one}{01464}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1not__this__one}{not\_this\_one}} \{\}; \textcolor{comment}{// Tag type for detecting which begin/ end are being selected}}
\DoxyCodeLine{01465 }
\DoxyCodeLine{01466     \textcolor{comment}{// Import begin/ end from std here so they are considered alongside the fallback (...) overloads in this namespace}}
\DoxyCodeLine{01467     \textcolor{keyword}{using} std::begin;}
\DoxyCodeLine{01468     \textcolor{keyword}{using} std::end;}
\DoxyCodeLine{01469 }
\DoxyCodeLine{01470     \mbox{\hyperlink{structCatch_1_1not__this__one}{not\_this\_one}} begin( ... );}
\DoxyCodeLine{01471     \mbox{\hyperlink{structCatch_1_1not__this__one}{not\_this\_one}} end( ... );}
\DoxyCodeLine{01472 }
\DoxyCodeLine{01473     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01474}\mbox{\hyperlink{structCatch_1_1is__range}{01474}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1is__range}{is\_range}} \{}
\DoxyCodeLine{01475         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value =}
\DoxyCodeLine{01476             !std::is\_same<decltype(begin(std::declval<T>())), \mbox{\hyperlink{structCatch_1_1not__this__one}{not\_this\_one}}>::value \&\&}
\DoxyCodeLine{01477             !std::is\_same<decltype(end(std::declval<T>())), \mbox{\hyperlink{structCatch_1_1not__this__one}{not\_this\_one}}>::value;}
\DoxyCodeLine{01478     \};}
\DoxyCodeLine{01479 }
\DoxyCodeLine{01480 \textcolor{preprocessor}{\#if defined(\_MANAGED) // Managed types are never ranges}}
\DoxyCodeLine{01481     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01482     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1is__range}{is\_range}}<T\string^> \{}
\DoxyCodeLine{01483         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false};}
\DoxyCodeLine{01484     \};}
\DoxyCodeLine{01485 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01486 }
\DoxyCodeLine{01487     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{01488     std::string rangeToString( Range \textcolor{keyword}{const}\& range ) \{}
\DoxyCodeLine{01489         return ::Catch::Detail::rangeToString( begin( range ), end( range ) );}
\DoxyCodeLine{01490     \}}
\DoxyCodeLine{01491 }
\DoxyCodeLine{01492     \textcolor{comment}{// Handle vector<bool> specially}}
\DoxyCodeLine{01493     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Allocator>}
\DoxyCodeLine{01494     std::string rangeToString( std::vector<bool, Allocator> \textcolor{keyword}{const}\& v ) \{}
\DoxyCodeLine{01495         ReusableStringStream rss;}
\DoxyCodeLine{01496         rss << \textcolor{stringliteral}{"\{ "};}
\DoxyCodeLine{01497         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{01498         \textcolor{keywordflow}{for}( \textcolor{keywordtype}{bool} b : v ) \{}
\DoxyCodeLine{01499             \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{01500                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{01501             \textcolor{keywordflow}{else}}
\DoxyCodeLine{01502                 rss << \textcolor{stringliteral}{", "};}
\DoxyCodeLine{01503             rss << ::Catch::Detail::stringify( b );}
\DoxyCodeLine{01504         \}}
\DoxyCodeLine{01505         rss << \textcolor{stringliteral}{" \}"};}
\DoxyCodeLine{01506         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{01507     \}}
\DoxyCodeLine{01508 }
\DoxyCodeLine{01509     \textcolor{keyword}{template}<\textcolor{keyword}{typename} R>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01510}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01R_00_01typename_01std_1_1enable__if_3_01is__range_3_01R_01_4_1_1ve8233c20b54b69b4771fbd413409d181}{01510}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<R, typename std::enable\_if<is\_range<R>::value \&\& !::Catch::Detail::IsStreamInsertable<R>::value>::type> \{}
\DoxyCodeLine{01511         \textcolor{keyword}{static} std::string convert( R \textcolor{keyword}{const}\& range ) \{}
\DoxyCodeLine{01512             \textcolor{keywordflow}{return} rangeToString( range );}
\DoxyCodeLine{01513         \}}
\DoxyCodeLine{01514     \};}
\DoxyCodeLine{01515 }
\DoxyCodeLine{01516     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01517}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01T[SZ]_4}{01517}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<T[SZ]> \{}
\DoxyCodeLine{01518         \textcolor{keyword}{static} std::string convert(T \textcolor{keyword}{const}(\&arr)[SZ]) \{}
\DoxyCodeLine{01519             \textcolor{keywordflow}{return} rangeToString(arr);}
\DoxyCodeLine{01520         \}}
\DoxyCodeLine{01521     \};}
\DoxyCodeLine{01522 }
\DoxyCodeLine{01523 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{01524 }
\DoxyCodeLine{01525 \textcolor{comment}{// Separate std::chrono::duration specialization}}
\DoxyCodeLine{01526 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{01527 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{01528 \textcolor{preprocessor}{\#include <ratio>}}
\DoxyCodeLine{01529 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{01530 }
\DoxyCodeLine{01531 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{01532 }
\DoxyCodeLine{01533 \textcolor{keyword}{template} <\textcolor{keyword}{class} Ratio>}
\DoxyCodeLine{01534 \textcolor{keyword}{struct }ratio\_string \{}
\DoxyCodeLine{01535     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{01536 \};}
\DoxyCodeLine{01537 }
\DoxyCodeLine{01538 \textcolor{keyword}{template} <\textcolor{keyword}{class} Ratio>}
\DoxyCodeLine{01539 std::string ratio\_string<Ratio>::symbol() \{}
\DoxyCodeLine{01540     \mbox{\hyperlink{classCatch_1_1ReusableStringStream}{Catch::ReusableStringStream}} rss;}
\DoxyCodeLine{01541     rss << \textcolor{charliteral}{'['} << Ratio::num << \textcolor{charliteral}{'/'}}
\DoxyCodeLine{01542         << Ratio::den << \textcolor{charliteral}{']'};}
\DoxyCodeLine{01543     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{01544 \}}
\DoxyCodeLine{01545 \textcolor{keyword}{template} <>}
\DoxyCodeLine{01546 \textcolor{keyword}{struct }ratio\_string<std::atto> \{}
\DoxyCodeLine{01547     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{01548 \};}
\DoxyCodeLine{01549 \textcolor{keyword}{template} <>}
\DoxyCodeLine{01550 \textcolor{keyword}{struct }ratio\_string<std::femto> \{}
\DoxyCodeLine{01551     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{01552 \};}
\DoxyCodeLine{01553 \textcolor{keyword}{template} <>}
\DoxyCodeLine{01554 \textcolor{keyword}{struct }ratio\_string<std::pico> \{}
\DoxyCodeLine{01555     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{01556 \};}
\DoxyCodeLine{01557 \textcolor{keyword}{template} <>}
\DoxyCodeLine{01558 \textcolor{keyword}{struct }ratio\_string<std::nano> \{}
\DoxyCodeLine{01559     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{01560 \};}
\DoxyCodeLine{01561 \textcolor{keyword}{template} <>}
\DoxyCodeLine{01562 \textcolor{keyword}{struct }ratio\_string<std::micro> \{}
\DoxyCodeLine{01563     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{01564 \};}
\DoxyCodeLine{01565 \textcolor{keyword}{template} <>}
\DoxyCodeLine{01566 \textcolor{keyword}{struct }ratio\_string<std::milli> \{}
\DoxyCodeLine{01567     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{01568 \};}
\DoxyCodeLine{01569 }
\DoxyCodeLine{01571     \textcolor{comment}{// std::chrono::duration specializations}}
\DoxyCodeLine{01572     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} Ratio>}
\DoxyCodeLine{01573     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, Ratio>> \{}
\DoxyCodeLine{01574         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, Ratio> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{01575             ReusableStringStream rss;}
\DoxyCodeLine{01576             rss << duration.count() << \textcolor{charliteral}{' '} << ratio\_string<Ratio>::symbol() << \textcolor{charliteral}{'s'};}
\DoxyCodeLine{01577             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{01578         \}}
\DoxyCodeLine{01579     \};}
\DoxyCodeLine{01580     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{01581     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<1>>> \{}
\DoxyCodeLine{01582         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<1>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{01583             ReusableStringStream rss;}
\DoxyCodeLine{01584             rss << duration.count() << \textcolor{stringliteral}{" s"};}
\DoxyCodeLine{01585             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{01586         \}}
\DoxyCodeLine{01587     \};}
\DoxyCodeLine{01588     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{01589     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<60>>> \{}
\DoxyCodeLine{01590         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<60>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{01591             ReusableStringStream rss;}
\DoxyCodeLine{01592             rss << duration.count() << \textcolor{stringliteral}{" m"};}
\DoxyCodeLine{01593             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{01594         \}}
\DoxyCodeLine{01595     \};}
\DoxyCodeLine{01596     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{01597     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<3600>>> \{}
\DoxyCodeLine{01598         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<3600>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{01599             ReusableStringStream rss;}
\DoxyCodeLine{01600             rss << duration.count() << \textcolor{stringliteral}{" h"};}
\DoxyCodeLine{01601             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{01602         \}}
\DoxyCodeLine{01603     \};}
\DoxyCodeLine{01604 }
\DoxyCodeLine{01606     \textcolor{comment}{// std::chrono::time\_point specialization}}
\DoxyCodeLine{01607     \textcolor{comment}{// Generic time\_point cannot be specialized, only std::chrono::time\_point<system\_clock>}}
\DoxyCodeLine{01608     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{01609     \textcolor{keyword}{struct }StringMaker<std::chrono::time\_point<Clock, Duration>> \{}
\DoxyCodeLine{01610         \textcolor{keyword}{static} std::string convert(std::chrono::time\_point<Clock, Duration> \textcolor{keyword}{const}\& time\_point) \{}
\DoxyCodeLine{01611             return ::Catch::Detail::stringify(time\_point.time\_since\_epoch()) + \textcolor{stringliteral}{" since epoch"};}
\DoxyCodeLine{01612         \}}
\DoxyCodeLine{01613     \};}
\DoxyCodeLine{01614     \textcolor{comment}{// std::chrono::time\_point<system\_clock> specialization}}
\DoxyCodeLine{01615     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{01616     \textcolor{keyword}{struct }StringMaker<std::chrono::time\_point<std::chrono::system\_clock, Duration>> \{}
\DoxyCodeLine{01617         \textcolor{keyword}{static} std::string convert(std::chrono::time\_point<std::chrono::system\_clock, Duration> \textcolor{keyword}{const}\& time\_point) \{}
\DoxyCodeLine{01618             \textcolor{keyword}{auto} converted = std::chrono::system\_clock::to\_time\_t(time\_point);}
\DoxyCodeLine{01619 }
\DoxyCodeLine{01620 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{01621             std::tm timeInfo = \{\};}
\DoxyCodeLine{01622             gmtime\_s(\&timeInfo, \&converted);}
\DoxyCodeLine{01623 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{01624             std::tm* timeInfo = std::gmtime(\&converted);}
\DoxyCodeLine{01625 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01626 }
\DoxyCodeLine{01627             \textcolor{keyword}{auto} \textcolor{keyword}{const} timeStampSize = \textcolor{keyword}{sizeof}(\textcolor{stringliteral}{"2017-01-16T17:06:45Z"});}
\DoxyCodeLine{01628             \textcolor{keywordtype}{char} timeStamp[timeStampSize];}
\DoxyCodeLine{01629             \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} fmt = \textcolor{stringliteral}{"\%Y-\%m-\%dT\%H:\%M:\%SZ"};}
\DoxyCodeLine{01630 }
\DoxyCodeLine{01631 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{01632             std::strftime(timeStamp, timeStampSize, fmt, \&timeInfo);}
\DoxyCodeLine{01633 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{01634             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);}
\DoxyCodeLine{01635 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01636             \textcolor{keywordflow}{return} std::string(timeStamp);}
\DoxyCodeLine{01637         \}}
\DoxyCodeLine{01638     \};}
\DoxyCodeLine{01639 \}}
\DoxyCodeLine{01640 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{01641 }
\DoxyCodeLine{01642 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{01643 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{01644 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01645 }
\DoxyCodeLine{01646 \textcolor{comment}{// end catch\_tostring.h}}
\DoxyCodeLine{01647 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{01648 }
\DoxyCodeLine{01649 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{01650 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{01651 \textcolor{preprocessor}{\#pragma warning(disable:4389) // '==' : signed/unsigned mismatch}}
\DoxyCodeLine{01652 \textcolor{preprocessor}{\#pragma warning(disable:4018) // more "signed/unsigned mismatch"}}
\DoxyCodeLine{01653 \textcolor{preprocessor}{\#pragma warning(disable:4312) // Converting int to T* using reinterpret\_cast (issue on x64 platform)}}
\DoxyCodeLine{01654 \textcolor{preprocessor}{\#pragma warning(disable:4180) // qualifier applied to function type has no meaning}}
\DoxyCodeLine{01655 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01656 }
\DoxyCodeLine{01657 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{01658 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01659}\mbox{\hyperlink{structCatch_1_1ITransientExpression}{01659}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \{}
\DoxyCodeLine{01660         \textcolor{keyword}{auto} isBinaryExpression() \textcolor{keyword}{const} -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} m\_isBinaryExpression; \}}
\DoxyCodeLine{01661         \textcolor{keyword}{auto} getResult() \textcolor{keyword}{const} -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} m\_result; \}}
\DoxyCodeLine{01662         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{01663 }
\DoxyCodeLine{01664         \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}}( \textcolor{keywordtype}{bool} isBinaryExpression, \textcolor{keywordtype}{bool} result )}
\DoxyCodeLine{01665         :   m\_isBinaryExpression( isBinaryExpression ),}
\DoxyCodeLine{01666             m\_result( result )}
\DoxyCodeLine{01667         \{\}}
\DoxyCodeLine{01668 }
\DoxyCodeLine{01669         \textcolor{comment}{// We don't actually need a virtual destructor, but many static analysers}}
\DoxyCodeLine{01670         \textcolor{comment}{// complain if it's not here :-(}}
\DoxyCodeLine{01671         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}}();}
\DoxyCodeLine{01672 }
\DoxyCodeLine{01673         \textcolor{keywordtype}{bool} m\_isBinaryExpression;}
\DoxyCodeLine{01674         \textcolor{keywordtype}{bool} m\_result;}
\DoxyCodeLine{01675 }
\DoxyCodeLine{01676     \};}
\DoxyCodeLine{01677 }
\DoxyCodeLine{01678     \textcolor{keywordtype}{void} formatReconstructedExpression( std::ostream \&os, std::string \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} op, std::string \textcolor{keyword}{const}\& rhs );}
\DoxyCodeLine{01679 }
\DoxyCodeLine{01680     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01681}\mbox{\hyperlink{classCatch_1_1BinaryExpr}{01681}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr}}  : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \{}
\DoxyCodeLine{01682         LhsT m\_lhs;}
\DoxyCodeLine{01683         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} m\_op;}
\DoxyCodeLine{01684         RhsT m\_rhs;}
\DoxyCodeLine{01685 }
\DoxyCodeLine{01686         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{01687             formatReconstructedExpression}
\DoxyCodeLine{01688                     ( os, Catch::Detail::stringify( m\_lhs ), m\_op, Catch::Detail::stringify( m\_rhs ) );}
\DoxyCodeLine{01689         \}}
\DoxyCodeLine{01690 }
\DoxyCodeLine{01691     \textcolor{keyword}{public}:}
\DoxyCodeLine{01692         \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr}}( \textcolor{keywordtype}{bool} comparisonResult, LhsT lhs, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} op, RhsT rhs )}
\DoxyCodeLine{01693         :   \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}}\{ \textcolor{keyword}{true}, comparisonResult \},}
\DoxyCodeLine{01694             m\_lhs( lhs ),}
\DoxyCodeLine{01695             m\_op( op ),}
\DoxyCodeLine{01696             m\_rhs( rhs )}
\DoxyCodeLine{01697         \{\}}
\DoxyCodeLine{01698     \};}
\DoxyCodeLine{01699 }
\DoxyCodeLine{01700     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01701}\mbox{\hyperlink{classCatch_1_1UnaryExpr}{01701}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1UnaryExpr}{UnaryExpr}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \{}
\DoxyCodeLine{01702         LhsT m\_lhs;}
\DoxyCodeLine{01703 }
\DoxyCodeLine{01704         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{01705             os << Catch::Detail::stringify( m\_lhs );}
\DoxyCodeLine{01706         \}}
\DoxyCodeLine{01707 }
\DoxyCodeLine{01708     \textcolor{keyword}{public}:}
\DoxyCodeLine{01709         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1UnaryExpr}{UnaryExpr}}( LhsT lhs )}
\DoxyCodeLine{01710         :   \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}}\{ \textcolor{keyword}{false}, lhs ? true : \textcolor{keyword}{false} \},}
\DoxyCodeLine{01711             m\_lhs( lhs )}
\DoxyCodeLine{01712         \{\}}
\DoxyCodeLine{01713     \};}
\DoxyCodeLine{01714 }
\DoxyCodeLine{01715     \textcolor{comment}{// Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)}}
\DoxyCodeLine{01716     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{01717     \textcolor{keyword}{auto} compareEqual( LhsT \textcolor{keyword}{const}\& lhs, RhsT \textcolor{keyword}{const}\& rhs ) -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} static\_cast<bool>(lhs == rhs); \}}
\DoxyCodeLine{01718     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01719     \textcolor{keyword}{auto} compareEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{int} rhs ) -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs == reinterpret\_cast<void const*>( rhs ); \}}
\DoxyCodeLine{01720     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01721     \textcolor{keyword}{auto} compareEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{long} rhs ) -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs == reinterpret\_cast<void const*>( rhs ); \}}
\DoxyCodeLine{01722     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01723     \textcolor{keyword}{auto} compareEqual( \textcolor{keywordtype}{int} lhs, T* \textcolor{keyword}{const}\& rhs ) -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} reinterpret\_cast<void const*>( lhs ) == rhs; \}}
\DoxyCodeLine{01724     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01725     \textcolor{keyword}{auto} compareEqual( \textcolor{keywordtype}{long} lhs, T* \textcolor{keyword}{const}\& rhs ) -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} reinterpret\_cast<void const*>( lhs ) == rhs; \}}
\DoxyCodeLine{01726 }
\DoxyCodeLine{01727     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{01728     \textcolor{keyword}{auto} compareNotEqual( LhsT \textcolor{keyword}{const}\& lhs, RhsT\&\& rhs ) -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} static\_cast<bool>(lhs != rhs); \}}
\DoxyCodeLine{01729     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01730     \textcolor{keyword}{auto} compareNotEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{int} rhs ) -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs != reinterpret\_cast<void const*>( rhs ); \}}
\DoxyCodeLine{01731     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01732     \textcolor{keyword}{auto} compareNotEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{long} rhs ) -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs != reinterpret\_cast<void const*>( rhs ); \}}
\DoxyCodeLine{01733     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01734     \textcolor{keyword}{auto} compareNotEqual( \textcolor{keywordtype}{int} lhs, T* \textcolor{keyword}{const}\& rhs ) -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} reinterpret\_cast<void const*>( lhs ) != rhs; \}}
\DoxyCodeLine{01735     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01736     \textcolor{keyword}{auto} compareNotEqual( \textcolor{keywordtype}{long} lhs, T* \textcolor{keyword}{const}\& rhs ) -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} reinterpret\_cast<void const*>( lhs ) != rhs; \}}
\DoxyCodeLine{01737 }
\DoxyCodeLine{01738     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01739}\mbox{\hyperlink{classCatch_1_1ExprLhs}{01739}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs}} \{}
\DoxyCodeLine{01740         LhsT m\_lhs;}
\DoxyCodeLine{01741     \textcolor{keyword}{public}:}
\DoxyCodeLine{01742         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs}}( LhsT lhs ) : m\_lhs( lhs ) \{\}}
\DoxyCodeLine{01743 }
\DoxyCodeLine{01744         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{01745         \textcolor{keyword}{auto} operator == ( RhsT \textcolor{keyword}{const}\& rhs ) -> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{01746             \textcolor{keywordflow}{return} \{ compareEqual( m\_lhs, rhs ), m\_lhs, \textcolor{stringliteral}{"=="}, rhs \};}
\DoxyCodeLine{01747         \}}
\DoxyCodeLine{01748         \textcolor{keyword}{auto} operator == ( \textcolor{keywordtype}{bool} rhs ) -> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, bool>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{01749             \textcolor{keywordflow}{return} \{ m\_lhs == rhs, m\_lhs, \textcolor{stringliteral}{"=="}, rhs \};}
\DoxyCodeLine{01750         \}}
\DoxyCodeLine{01751 }
\DoxyCodeLine{01752         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{01753         \textcolor{keyword}{auto} operator != ( RhsT \textcolor{keyword}{const}\& rhs ) -> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{01754             \textcolor{keywordflow}{return} \{ compareNotEqual( m\_lhs, rhs ), m\_lhs, \textcolor{stringliteral}{"!="}, rhs \};}
\DoxyCodeLine{01755         \}}
\DoxyCodeLine{01756         \textcolor{keyword}{auto} operator != ( \textcolor{keywordtype}{bool} rhs ) -> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, bool>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{01757             \textcolor{keywordflow}{return} \{ m\_lhs != rhs, m\_lhs, \textcolor{stringliteral}{"!="}, rhs \};}
\DoxyCodeLine{01758         \}}
\DoxyCodeLine{01759 }
\DoxyCodeLine{01760         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{01761         \textcolor{keyword}{auto} operator > ( RhsT \textcolor{keyword}{const}\& rhs ) -> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{01762             \textcolor{keywordflow}{return} \{ static\_cast<bool>(m\_lhs > rhs), m\_lhs, \textcolor{stringliteral}{">"}, rhs \};}
\DoxyCodeLine{01763         \}}
\DoxyCodeLine{01764         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{01765         \textcolor{keyword}{auto} operator < ( RhsT \textcolor{keyword}{const}\& rhs ) -> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{01766             \textcolor{keywordflow}{return} \{ static\_cast<bool>(m\_lhs < rhs), m\_lhs, \textcolor{stringliteral}{"<"}, rhs \};}
\DoxyCodeLine{01767         \}}
\DoxyCodeLine{01768         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{01769         \textcolor{keyword}{auto} operator >= ( RhsT \textcolor{keyword}{const}\& rhs ) -> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{01770             \textcolor{keywordflow}{return} \{ static\_cast<bool>(m\_lhs >= rhs), m\_lhs, \textcolor{stringliteral}{">="}, rhs \};}
\DoxyCodeLine{01771         \}}
\DoxyCodeLine{01772         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{01773         \textcolor{keyword}{auto} operator <= ( RhsT \textcolor{keyword}{const}\& rhs ) -> \mbox{\hyperlink{classCatch_1_1BinaryExpr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{01774             \textcolor{keywordflow}{return} \{ static\_cast<bool>(m\_lhs <= rhs), m\_lhs, \textcolor{stringliteral}{"<="}, rhs \};}
\DoxyCodeLine{01775         \}}
\DoxyCodeLine{01776 }
\DoxyCodeLine{01777         \textcolor{keyword}{auto} makeUnaryExpr() \textcolor{keyword}{const} -> \mbox{\hyperlink{classCatch_1_1UnaryExpr}{UnaryExpr<LhsT>}} \{}
\DoxyCodeLine{01778             \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1UnaryExpr}{UnaryExpr<LhsT>}}\{ m\_lhs \};}
\DoxyCodeLine{01779         \}}
\DoxyCodeLine{01780     \};}
\DoxyCodeLine{01781 }
\DoxyCodeLine{01782     \textcolor{keywordtype}{void} handleExpression( \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \textcolor{keyword}{const}\& expr );}
\DoxyCodeLine{01783 }
\DoxyCodeLine{01784     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01785     \textcolor{keywordtype}{void} handleExpression( \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<T>}} \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{01786         handleExpression( expr.makeUnaryExpr() );}
\DoxyCodeLine{01787     \}}
\DoxyCodeLine{01788 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01789}\mbox{\hyperlink{structCatch_1_1Decomposer}{01789}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Decomposer}{Decomposer}} \{}
\DoxyCodeLine{01790         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01791         \textcolor{keyword}{auto} operator <= ( T \textcolor{keyword}{const}\& lhs ) -> \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<T const\&>}} \{}
\DoxyCodeLine{01792             \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<T const\&>}}\{ lhs \};}
\DoxyCodeLine{01793         \}}
\DoxyCodeLine{01794 }
\DoxyCodeLine{01795         \textcolor{keyword}{auto} operator <=( \textcolor{keywordtype}{bool} value ) -> \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<bool>}} \{}
\DoxyCodeLine{01796             \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<bool>}}\{ value \};}
\DoxyCodeLine{01797         \}}
\DoxyCodeLine{01798     \};}
\DoxyCodeLine{01799 }
\DoxyCodeLine{01800 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{01801 }
\DoxyCodeLine{01802 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{01803 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{01804 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01805 }
\DoxyCodeLine{01806 \textcolor{comment}{// end catch\_decomposer.h}}
\DoxyCodeLine{01807 \textcolor{comment}{// start catch\_interfaces\_capture.h}}
\DoxyCodeLine{01808 }
\DoxyCodeLine{01809 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{01810 }
\DoxyCodeLine{01811 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{01812 }
\DoxyCodeLine{01813     \textcolor{keyword}{class }AssertionResult;}
\DoxyCodeLine{01814     \textcolor{keyword}{struct }AssertionInfo;}
\DoxyCodeLine{01815     \textcolor{keyword}{struct }SectionInfo;}
\DoxyCodeLine{01816     \textcolor{keyword}{struct }SectionEndInfo;}
\DoxyCodeLine{01817     \textcolor{keyword}{struct }MessageInfo;}
\DoxyCodeLine{01818     \textcolor{keyword}{struct }Counts;}
\DoxyCodeLine{01819     \textcolor{keyword}{struct }BenchmarkInfo;}
\DoxyCodeLine{01820     \textcolor{keyword}{struct }BenchmarkStats;}
\DoxyCodeLine{01821     \textcolor{keyword}{struct }AssertionReaction;}
\DoxyCodeLine{01822     \textcolor{keyword}{struct }SourceLineInfo;}
\DoxyCodeLine{01823 }
\DoxyCodeLine{01824     \textcolor{keyword}{struct }ITransientExpression;}
\DoxyCodeLine{01825     \textcolor{keyword}{struct }IGeneratorTracker;}
\DoxyCodeLine{01826 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01827}\mbox{\hyperlink{structCatch_1_1IResultCapture}{01827}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}} \{}
\DoxyCodeLine{01828 }
\DoxyCodeLine{01829         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}();}
\DoxyCodeLine{01830 }
\DoxyCodeLine{01831         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} sectionStarted(    \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} \textcolor{keyword}{const}\& sectionInfo,}
\DoxyCodeLine{01832                                         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}}\& assertions ) = 0;}
\DoxyCodeLine{01833         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( \mbox{\hyperlink{structCatch_1_1SectionEndInfo}{SectionEndInfo}} \textcolor{keyword}{const}\& endInfo ) = 0;}
\DoxyCodeLine{01834         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEndedEarly( \mbox{\hyperlink{structCatch_1_1SectionEndInfo}{SectionEndInfo}} \textcolor{keyword}{const}\& endInfo ) = 0;}
\DoxyCodeLine{01835 }
\DoxyCodeLine{01836         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} acquireGeneratorTracker( \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo ) -> \mbox{\hyperlink{structCatch_1_1IGeneratorTracker}{IGeneratorTracker}}\& = 0;}
\DoxyCodeLine{01837 }
\DoxyCodeLine{01838         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) = 0;}
\DoxyCodeLine{01839         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats \textcolor{keyword}{const}\& stats ) = 0;}
\DoxyCodeLine{01840 }
\DoxyCodeLine{01841         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} pushScopedMessage( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& message ) = 0;}
\DoxyCodeLine{01842         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} popScopedMessage( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& message ) = 0;}
\DoxyCodeLine{01843 }
\DoxyCodeLine{01844         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleFatalErrorCondition( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} message ) = 0;}
\DoxyCodeLine{01845 }
\DoxyCodeLine{01846         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleExpr}
\DoxyCodeLine{01847                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{01848                     \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{01849                     \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{01850         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleMessage}
\DoxyCodeLine{01851                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{01852                     ResultWas::OfType resultType,}
\DoxyCodeLine{01853                     \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{01854                     \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{01855         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown}
\DoxyCodeLine{01856                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{01857                     \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{01858         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleUnexpectedInflightException}
\DoxyCodeLine{01859                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{01860                     std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{01861                     \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{01862         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleIncomplete}
\DoxyCodeLine{01863                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const}\& info ) = 0;}
\DoxyCodeLine{01864         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleNonExpr}
\DoxyCodeLine{01865                 (   \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{01866                     ResultWas::OfType resultType,}
\DoxyCodeLine{01867                     \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}} \&reaction ) = 0;}
\DoxyCodeLine{01868 }
\DoxyCodeLine{01869         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} lastAssertionPassed() = 0;}
\DoxyCodeLine{01870         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionPassed() = 0;}
\DoxyCodeLine{01871 }
\DoxyCodeLine{01872         \textcolor{comment}{// Deprecated, do not use:}}
\DoxyCodeLine{01873         \textcolor{keyword}{virtual} std::string getCurrentTestName() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{01874         \textcolor{keyword}{virtual} \textcolor{keyword}{const} AssertionResult* getLastResult() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{01875         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} exceptionEarlyReported() = 0;}
\DoxyCodeLine{01876     \};}
\DoxyCodeLine{01877 }
\DoxyCodeLine{01878     \mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}\& getResultCapture();}
\DoxyCodeLine{01879 \}}
\DoxyCodeLine{01880 }
\DoxyCodeLine{01881 \textcolor{comment}{// end catch\_interfaces\_capture.h}}
\DoxyCodeLine{01882 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{01883 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01884}\mbox{\hyperlink{structCatch_1_1TestFailureException}{01884}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1TestFailureException}{TestFailureException}}\{\};}
\DoxyCodeLine{01885     \textcolor{keyword}{struct }AssertionResultData;}
\DoxyCodeLine{01886     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}};}
\DoxyCodeLine{01887     \textcolor{keyword}{class }RunContext;}
\DoxyCodeLine{01888 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01889}\mbox{\hyperlink{classCatch_1_1LazyExpression}{01889}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}} \{}
\DoxyCodeLine{01890         \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1AssertionHandler}{AssertionHandler}};}
\DoxyCodeLine{01891         \textcolor{keyword}{friend} \textcolor{keyword}{struct }AssertionStats;}
\DoxyCodeLine{01892         \textcolor{keyword}{friend} \textcolor{keyword}{class }RunContext;}
\DoxyCodeLine{01893 }
\DoxyCodeLine{01894         \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \textcolor{keyword}{const}* m\_transientExpression = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{01895         \textcolor{keywordtype}{bool} m\_isNegated;}
\DoxyCodeLine{01896     \textcolor{keyword}{public}:}
\DoxyCodeLine{01897         \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}}( \textcolor{keywordtype}{bool} isNegated );}
\DoxyCodeLine{01898         \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}}( \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{01899         \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}}\& operator = ( \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{01900 }
\DoxyCodeLine{01901         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \textcolor{keyword}{const};}
\DoxyCodeLine{01902 }
\DoxyCodeLine{01903         \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator << ( std::ostream\& os, \mbox{\hyperlink{classCatch_1_1LazyExpression}{LazyExpression}} \textcolor{keyword}{const}\& lazyExpr ) -> std::ostream\&;}
\DoxyCodeLine{01904     \};}
\DoxyCodeLine{01905 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01906}\mbox{\hyperlink{structCatch_1_1AssertionReaction}{01906}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}} \{}
\DoxyCodeLine{01907         \textcolor{keywordtype}{bool} shouldDebugBreak = \textcolor{keyword}{false};}
\DoxyCodeLine{01908         \textcolor{keywordtype}{bool} shouldThrow = \textcolor{keyword}{false};}
\DoxyCodeLine{01909     \};}
\DoxyCodeLine{01910 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01911}\mbox{\hyperlink{classCatch_1_1AssertionHandler}{01911}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1AssertionHandler}{AssertionHandler}} \{}
\DoxyCodeLine{01912         \mbox{\hyperlink{structCatch_1_1AssertionInfo}{AssertionInfo}} m\_assertionInfo;}
\DoxyCodeLine{01913         \mbox{\hyperlink{structCatch_1_1AssertionReaction}{AssertionReaction}} m\_reaction;}
\DoxyCodeLine{01914         \textcolor{keywordtype}{bool} m\_completed = \textcolor{keyword}{false};}
\DoxyCodeLine{01915         \mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}\& m\_resultCapture;}
\DoxyCodeLine{01916 }
\DoxyCodeLine{01917     \textcolor{keyword}{public}:}
\DoxyCodeLine{01918         \mbox{\hyperlink{classCatch_1_1AssertionHandler}{AssertionHandler}}}
\DoxyCodeLine{01919             (   \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{01920                 \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{01921                 \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} capturedExpression,}
\DoxyCodeLine{01922                 ResultDisposition::Flags resultDisposition );}
\DoxyCodeLine{01923         ~\mbox{\hyperlink{classCatch_1_1AssertionHandler}{AssertionHandler}}() \{}
\DoxyCodeLine{01924             \textcolor{keywordflow}{if} ( !m\_completed ) \{}
\DoxyCodeLine{01925                 m\_resultCapture.handleIncomplete( m\_assertionInfo );}
\DoxyCodeLine{01926             \}}
\DoxyCodeLine{01927         \}}
\DoxyCodeLine{01928 }
\DoxyCodeLine{01929         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01930         \textcolor{keywordtype}{void} handleExpr( \mbox{\hyperlink{classCatch_1_1ExprLhs}{ExprLhs<T>}} \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{01931             handleExpr( expr.makeUnaryExpr() );}
\DoxyCodeLine{01932         \}}
\DoxyCodeLine{01933         \textcolor{keywordtype}{void} handleExpr( \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \textcolor{keyword}{const}\& expr );}
\DoxyCodeLine{01934 }
\DoxyCodeLine{01935         \textcolor{keywordtype}{void} handleMessage(ResultWas::OfType resultType, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& message);}
\DoxyCodeLine{01936 }
\DoxyCodeLine{01937         \textcolor{keywordtype}{void} handleExceptionThrownAsExpected();}
\DoxyCodeLine{01938         \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown();}
\DoxyCodeLine{01939         \textcolor{keywordtype}{void} handleExceptionNotThrownAsExpected();}
\DoxyCodeLine{01940         \textcolor{keywordtype}{void} handleThrowingCallSkipped();}
\DoxyCodeLine{01941         \textcolor{keywordtype}{void} handleUnexpectedInflightException();}
\DoxyCodeLine{01942 }
\DoxyCodeLine{01943         \textcolor{keywordtype}{void} complete();}
\DoxyCodeLine{01944         \textcolor{keywordtype}{void} setCompleted();}
\DoxyCodeLine{01945 }
\DoxyCodeLine{01946         \textcolor{comment}{// query}}
\DoxyCodeLine{01947         \textcolor{keyword}{auto} allowThrows() \textcolor{keyword}{const} -> bool;}
\DoxyCodeLine{01948     \};}
\DoxyCodeLine{01949 }
\DoxyCodeLine{01950     \textcolor{keywordtype}{void} handleExceptionMatchExpr( \mbox{\hyperlink{classCatch_1_1AssertionHandler}{AssertionHandler}}\& handler, std::string \textcolor{keyword}{const}\& str, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& matcherString );}
\DoxyCodeLine{01951 }
\DoxyCodeLine{01952 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{01953 }
\DoxyCodeLine{01954 \textcolor{comment}{// end catch\_assertionhandler.h}}
\DoxyCodeLine{01955 \textcolor{comment}{// start catch\_message.h}}
\DoxyCodeLine{01956 }
\DoxyCodeLine{01957 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{01958 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{01959 }
\DoxyCodeLine{01960 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{01961 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01962}\mbox{\hyperlink{structCatch_1_1MessageInfo}{01962}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \{}
\DoxyCodeLine{01963         \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}}(    \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& \_macroName,}
\DoxyCodeLine{01964                         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{01965                         ResultWas::OfType \_type );}
\DoxyCodeLine{01966 }
\DoxyCodeLine{01967         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} macroName;}
\DoxyCodeLine{01968         std::string message;}
\DoxyCodeLine{01969         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{01970         ResultWas::OfType type;}
\DoxyCodeLine{01971         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sequence;}
\DoxyCodeLine{01972 }
\DoxyCodeLine{01973         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{01974         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{01975     \textcolor{keyword}{private}:}
\DoxyCodeLine{01976         \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} globalCount;}
\DoxyCodeLine{01977     \};}
\DoxyCodeLine{01978 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01979}\mbox{\hyperlink{structCatch_1_1MessageStream}{01979}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1MessageStream}{MessageStream}} \{}
\DoxyCodeLine{01980 }
\DoxyCodeLine{01981         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01982         \mbox{\hyperlink{structCatch_1_1MessageStream}{MessageStream}}\& operator << ( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{01983             m\_stream << value;}
\DoxyCodeLine{01984             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{01985         \}}
\DoxyCodeLine{01986 }
\DoxyCodeLine{01987         \mbox{\hyperlink{classCatch_1_1ReusableStringStream}{ReusableStringStream}} m\_stream;}
\DoxyCodeLine{01988     \};}
\DoxyCodeLine{01989 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l01990}\mbox{\hyperlink{structCatch_1_1MessageBuilder}{01990}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}} : \mbox{\hyperlink{structCatch_1_1MessageStream}{MessageStream}} \{}
\DoxyCodeLine{01991         \mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}}( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{01992                         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{01993                         ResultWas::OfType type );}
\DoxyCodeLine{01994 }
\DoxyCodeLine{01995         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{01996         \mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}}\& operator << ( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{01997             m\_stream << value;}
\DoxyCodeLine{01998             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{01999         \}}
\DoxyCodeLine{02000 }
\DoxyCodeLine{02001         \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} m\_info;}
\DoxyCodeLine{02002     \};}
\DoxyCodeLine{02003 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02004}\mbox{\hyperlink{classCatch_1_1ScopedMessage}{02004}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}} \{}
\DoxyCodeLine{02005     \textcolor{keyword}{public}:}
\DoxyCodeLine{02006         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}}( \mbox{\hyperlink{structCatch_1_1MessageBuilder}{MessageBuilder}} \textcolor{keyword}{const}\& builder );}
\DoxyCodeLine{02007         ~\mbox{\hyperlink{classCatch_1_1ScopedMessage}{ScopedMessage}}();}
\DoxyCodeLine{02008 }
\DoxyCodeLine{02009         \mbox{\hyperlink{structCatch_1_1MessageInfo}{MessageInfo}} m\_info;}
\DoxyCodeLine{02010     \};}
\DoxyCodeLine{02011 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02012}\mbox{\hyperlink{classCatch_1_1Capturer}{02012}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Capturer}{Capturer}} \{}
\DoxyCodeLine{02013         std::vector<MessageInfo> m\_messages;}
\DoxyCodeLine{02014         \mbox{\hyperlink{structCatch_1_1IResultCapture}{IResultCapture}}\& m\_resultCapture = getResultCapture();}
\DoxyCodeLine{02015         \textcolor{keywordtype}{size\_t} m\_captured = 0;}
\DoxyCodeLine{02016     \textcolor{keyword}{public}:}
\DoxyCodeLine{02017         \mbox{\hyperlink{classCatch_1_1Capturer}{Capturer}}( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} macroName, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo, ResultWas::OfType resultType, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} names );}
\DoxyCodeLine{02018         ~\mbox{\hyperlink{classCatch_1_1Capturer}{Capturer}}();}
\DoxyCodeLine{02019 }
\DoxyCodeLine{02020         \textcolor{keywordtype}{void} captureValue( \textcolor{keywordtype}{size\_t} index, std::string \textcolor{keyword}{const}\& value );}
\DoxyCodeLine{02021 }
\DoxyCodeLine{02022         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{02023         \textcolor{keywordtype}{void} captureValues( \textcolor{keywordtype}{size\_t} index, T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{02024             captureValue( index, Catch::Detail::stringify( value ) );}
\DoxyCodeLine{02025         \}}
\DoxyCodeLine{02026 }
\DoxyCodeLine{02027         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{02028         \textcolor{keywordtype}{void} captureValues( \textcolor{keywordtype}{size\_t} index, T \textcolor{keyword}{const}\& value, Ts \textcolor{keyword}{const}\&... values ) \{}
\DoxyCodeLine{02029             captureValue( index, Catch::Detail::stringify(value) );}
\DoxyCodeLine{02030             captureValues( index+1, values... );}
\DoxyCodeLine{02031         \}}
\DoxyCodeLine{02032     \};}
\DoxyCodeLine{02033 }
\DoxyCodeLine{02034 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{02035 }
\DoxyCodeLine{02036 \textcolor{comment}{// end catch\_message.h}}
\DoxyCodeLine{02037 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{02038 }
\DoxyCodeLine{02039 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_STRINGIFICATION)}}
\DoxyCodeLine{02040 \textcolor{preprocessor}{  \#define CATCH\_INTERNAL\_STRINGIFY(...) \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{02041 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{02042 \textcolor{preprocessor}{  \#define CATCH\_INTERNAL\_STRINGIFY(...) "Disabled by CATCH\_CONFIG\_DISABLE\_STRINGIFICATION"}}
\DoxyCodeLine{02043 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02044 }
\DoxyCodeLine{02045 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_FAST\_COMPILE) || defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{02046 }
\DoxyCodeLine{02048 \textcolor{comment}{// Another way to speed-up compilation is to omit local try-catch for REQUIRE*}}
\DoxyCodeLine{02049 \textcolor{comment}{// macros.}}
\DoxyCodeLine{02050 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRY}}
\DoxyCodeLine{02051 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CATCH( capturer )}}
\DoxyCodeLine{02052 }
\DoxyCodeLine{02053 \textcolor{preprocessor}{\#else // CATCH\_CONFIG\_FAST\_COMPILE}}
\DoxyCodeLine{02054 }
\DoxyCodeLine{02055 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRY try}}
\DoxyCodeLine{02056 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CATCH( handler ) catch(...) \{ handler.handleUnexpectedInflightException(); \}}}
\DoxyCodeLine{02057 }
\DoxyCodeLine{02058 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02059 }
\DoxyCodeLine{02060 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REACT( handler ) handler.complete();}}
\DoxyCodeLine{02061 }
\DoxyCodeLine{02063 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEST( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{02064 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{02065 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{02066 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TRY \{ \(\backslash\)}}
\DoxyCodeLine{02067 \textcolor{preprocessor}{            CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{02068 \textcolor{preprocessor}{            catchAssertionHandler.handleExpr( Catch::Decomposer() <= \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{02069 \textcolor{preprocessor}{            CATCH\_INTERNAL\_UNSUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{02070 \textcolor{preprocessor}{        \} INTERNAL\_CATCH\_CATCH( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{02071 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{02072 \textcolor{preprocessor}{    \} while( (void)0, false \&\& static\_cast<bool>( !!(\_\_VA\_ARGS\_\_) ) ) // the expression here is never evaluated at runtime but it forces the compiler to give it a look}}
\DoxyCodeLine{02073     \textcolor{comment}{// The double negation silences MSVC's C4800 warning, the static\_cast forces short-circuit evaluation if the type has overloaded \&\&.}}
\DoxyCodeLine{02074 }
\DoxyCodeLine{02076 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_IF( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{02077 \textcolor{preprocessor}{    INTERNAL\_CATCH\_TEST( macroName, resultDisposition, \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{02078 \textcolor{preprocessor}{    if( Catch::getResultCapture().lastAssertionPassed() )}}
\DoxyCodeLine{02079 }
\DoxyCodeLine{02081 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_ELSE( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{02082 \textcolor{preprocessor}{    INTERNAL\_CATCH\_TEST( macroName, resultDisposition, \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{02083 \textcolor{preprocessor}{    if( !Catch::getResultCapture().lastAssertionPassed() )}}
\DoxyCodeLine{02084 }
\DoxyCodeLine{02086 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NO\_THROW( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{02087 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{02088 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{02089 \textcolor{preprocessor}{        try \{ \(\backslash\)}}
\DoxyCodeLine{02090 \textcolor{preprocessor}{            static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{02091 \textcolor{preprocessor}{            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \(\backslash\)}}
\DoxyCodeLine{02092 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{02093 \textcolor{preprocessor}{        catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{02094 \textcolor{preprocessor}{            catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}}
\DoxyCodeLine{02095 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{02096 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{02097 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{02098 }
\DoxyCodeLine{02100 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{02101 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{02102 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition); \(\backslash\)}}
\DoxyCodeLine{02103 \textcolor{preprocessor}{        if( catchAssertionHandler.allowThrows() ) \(\backslash\)}}
\DoxyCodeLine{02104 \textcolor{preprocessor}{            try \{ \(\backslash\)}}
\DoxyCodeLine{02105 \textcolor{preprocessor}{                static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{02106 \textcolor{preprocessor}{                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}}
\DoxyCodeLine{02107 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{02108 \textcolor{preprocessor}{            catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{02109 \textcolor{preprocessor}{                catchAssertionHandler.handleExceptionThrownAsExpected(); \(\backslash\)}}
\DoxyCodeLine{02110 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{02111 \textcolor{preprocessor}{        else \(\backslash\)}}
\DoxyCodeLine{02112 \textcolor{preprocessor}{            catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}}
\DoxyCodeLine{02113 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{02114 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{02115 }
\DoxyCodeLine{02117 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_AS( macroName, exceptionType, resultDisposition, expr ) \(\backslash\)}}
\DoxyCodeLine{02118 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{02119 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(expr) ", " CATCH\_INTERNAL\_STRINGIFY(exceptionType), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{02120 \textcolor{preprocessor}{        if( catchAssertionHandler.allowThrows() ) \(\backslash\)}}
\DoxyCodeLine{02121 \textcolor{preprocessor}{            try \{ \(\backslash\)}}
\DoxyCodeLine{02122 \textcolor{preprocessor}{                static\_cast<void>(expr); \(\backslash\)}}
\DoxyCodeLine{02123 \textcolor{preprocessor}{                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}}
\DoxyCodeLine{02124 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{02125 \textcolor{preprocessor}{            catch( exceptionType const\& ) \{ \(\backslash\)}}
\DoxyCodeLine{02126 \textcolor{preprocessor}{                catchAssertionHandler.handleExceptionThrownAsExpected(); \(\backslash\)}}
\DoxyCodeLine{02127 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{02128 \textcolor{preprocessor}{            catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{02129 \textcolor{preprocessor}{                catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}}
\DoxyCodeLine{02130 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{02131 \textcolor{preprocessor}{        else \(\backslash\)}}
\DoxyCodeLine{02132 \textcolor{preprocessor}{            catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}}
\DoxyCodeLine{02133 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{02134 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{02135 }
\DoxyCodeLine{02137 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MSG( macroName, messageType, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{02138 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{02139 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{02140 \textcolor{preprocessor}{        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << \_\_VA\_ARGS\_\_ + ::Catch::StreamEndStop() ).m\_stream.str() ); \(\backslash\)}}
\DoxyCodeLine{02141 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{02142 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{02143 }
\DoxyCodeLine{02145 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CAPTURE( varName, macroName, ... ) \(\backslash\)}}
\DoxyCodeLine{02146 \textcolor{preprocessor}{    auto varName = Catch::Capturer( macroName, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info, \#\_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{02147 \textcolor{preprocessor}{    varName.captureValues( 0, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{02148 }
\DoxyCodeLine{02150 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_INFO( macroName, log ) \(\backslash\)}}
\DoxyCodeLine{02151 \textcolor{preprocessor}{    Catch::ScopedMessage INTERNAL\_CATCH\_UNIQUE\_NAME( scopedMessage )( Catch::MessageBuilder( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info ) << log );}}
\DoxyCodeLine{02152 }
\DoxyCodeLine{02154 \textcolor{comment}{// Although this is matcher-based, it can be used with just a string}}
\DoxyCodeLine{02155 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( macroName, resultDisposition, matcher, ... ) \(\backslash\)}}
\DoxyCodeLine{02156 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{02157 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_) ", " CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{02158 \textcolor{preprocessor}{        if( catchAssertionHandler.allowThrows() ) \(\backslash\)}}
\DoxyCodeLine{02159 \textcolor{preprocessor}{            try \{ \(\backslash\)}}
\DoxyCodeLine{02160 \textcolor{preprocessor}{                static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{02161 \textcolor{preprocessor}{                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}}
\DoxyCodeLine{02162 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{02163 \textcolor{preprocessor}{            catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{02164 \textcolor{preprocessor}{                Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, \#matcher\#\#\_catch\_sr ); \(\backslash\)}}
\DoxyCodeLine{02165 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{02166 \textcolor{preprocessor}{        else \(\backslash\)}}
\DoxyCodeLine{02167 \textcolor{preprocessor}{            catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}}
\DoxyCodeLine{02168 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{02169 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{02170 }
\DoxyCodeLine{02171 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{02172 }
\DoxyCodeLine{02173 \textcolor{comment}{// end catch\_capture.hpp}}
\DoxyCodeLine{02174 \textcolor{comment}{// start catch\_section.h}}
\DoxyCodeLine{02175 }
\DoxyCodeLine{02176 \textcolor{comment}{// start catch\_section\_info.h}}
\DoxyCodeLine{02177 }
\DoxyCodeLine{02178 \textcolor{comment}{// start catch\_totals.h}}
\DoxyCodeLine{02179 }
\DoxyCodeLine{02180 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{02181 }
\DoxyCodeLine{02182 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02183 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02184}\mbox{\hyperlink{structCatch_1_1Counts}{02184}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Counts}{Counts}} \{}
\DoxyCodeLine{02185         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} operator - ( \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{02186         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}}\& operator += ( \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{02187 }
\DoxyCodeLine{02188         std::size\_t total() \textcolor{keyword}{const};}
\DoxyCodeLine{02189         \textcolor{keywordtype}{bool} allPassed() \textcolor{keyword}{const};}
\DoxyCodeLine{02190         \textcolor{keywordtype}{bool} allOk() \textcolor{keyword}{const};}
\DoxyCodeLine{02191 }
\DoxyCodeLine{02192         std::size\_t passed = 0;}
\DoxyCodeLine{02193         std::size\_t failed = 0;}
\DoxyCodeLine{02194         std::size\_t failedButOk = 0;}
\DoxyCodeLine{02195     \};}
\DoxyCodeLine{02196 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02197}\mbox{\hyperlink{structCatch_1_1Totals}{02197}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \{}
\DoxyCodeLine{02198 }
\DoxyCodeLine{02199         \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} operator - ( \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{02200         \mbox{\hyperlink{structCatch_1_1Totals}{Totals}}\& operator += ( \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{02201 }
\DoxyCodeLine{02202         \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} delta( \mbox{\hyperlink{structCatch_1_1Totals}{Totals}} \textcolor{keyword}{const}\& prevTotals ) \textcolor{keyword}{const};}
\DoxyCodeLine{02203 }
\DoxyCodeLine{02204         \textcolor{keywordtype}{int} error = 0;}
\DoxyCodeLine{02205         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} assertions;}
\DoxyCodeLine{02206         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} testCases;}
\DoxyCodeLine{02207     \};}
\DoxyCodeLine{02208 \}}
\DoxyCodeLine{02209 }
\DoxyCodeLine{02210 \textcolor{comment}{// end catch\_totals.h}}
\DoxyCodeLine{02211 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{02212 }
\DoxyCodeLine{02213 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02214 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02215}\mbox{\hyperlink{structCatch_1_1SectionInfo}{02215}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} \{}
\DoxyCodeLine{02216         \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}}}
\DoxyCodeLine{02217             (   \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{02218                 std::string \textcolor{keyword}{const}\& \_name );}
\DoxyCodeLine{02219 }
\DoxyCodeLine{02220         \textcolor{comment}{// Deprecated}}
\DoxyCodeLine{02221         \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}}}
\DoxyCodeLine{02222             (   \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{02223                 std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{02224                 std::string \textcolor{keyword}{const}\& ) : \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}}( \_lineInfo, \_name ) \{\}}
\DoxyCodeLine{02225 }
\DoxyCodeLine{02226         std::string name;}
\DoxyCodeLine{02227         std::string description; \textcolor{comment}{// !Deprecated: this will always be empty}}
\DoxyCodeLine{02228         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{02229     \};}
\DoxyCodeLine{02230 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02231}\mbox{\hyperlink{structCatch_1_1SectionEndInfo}{02231}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1SectionEndInfo}{SectionEndInfo}} \{}
\DoxyCodeLine{02232         \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} sectionInfo;}
\DoxyCodeLine{02233         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} prevAssertions;}
\DoxyCodeLine{02234         \textcolor{keywordtype}{double} durationInSeconds;}
\DoxyCodeLine{02235     \};}
\DoxyCodeLine{02236 }
\DoxyCodeLine{02237 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{02238 }
\DoxyCodeLine{02239 \textcolor{comment}{// end catch\_section\_info.h}}
\DoxyCodeLine{02240 \textcolor{comment}{// start catch\_timer.h}}
\DoxyCodeLine{02241 }
\DoxyCodeLine{02242 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{02243 }
\DoxyCodeLine{02244 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02245 }
\DoxyCodeLine{02246     \textcolor{keyword}{auto} getCurrentNanosecondsSinceEpoch() -> uint64\_t;}
\DoxyCodeLine{02247     \textcolor{keyword}{auto} getEstimatedClockResolution() -> uint64\_t;}
\DoxyCodeLine{02248 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02249}\mbox{\hyperlink{classCatch_1_1Timer}{02249}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Timer}{Timer}} \{}
\DoxyCodeLine{02250         uint64\_t m\_nanoseconds = 0;}
\DoxyCodeLine{02251     \textcolor{keyword}{public}:}
\DoxyCodeLine{02252         \textcolor{keywordtype}{void} start();}
\DoxyCodeLine{02253         \textcolor{keyword}{auto} getElapsedNanoseconds() \textcolor{keyword}{const} -> uint64\_t;}
\DoxyCodeLine{02254         \textcolor{keyword}{auto} getElapsedMicroseconds() \textcolor{keyword}{const} -> uint64\_t;}
\DoxyCodeLine{02255         \textcolor{keyword}{auto} getElapsedMilliseconds() \textcolor{keyword}{const} -> \textcolor{keywordtype}{unsigned} int;}
\DoxyCodeLine{02256         \textcolor{keyword}{auto} getElapsedSeconds() \textcolor{keyword}{const} -> double;}
\DoxyCodeLine{02257     \};}
\DoxyCodeLine{02258 }
\DoxyCodeLine{02259 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{02260 }
\DoxyCodeLine{02261 \textcolor{comment}{// end catch\_timer.h}}
\DoxyCodeLine{02262 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{02263 }
\DoxyCodeLine{02264 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02265 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02266}\mbox{\hyperlink{classCatch_1_1Section}{02266}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Section}{Section}} : \mbox{\hyperlink{classCatch_1_1NonCopyable}{NonCopyable}} \{}
\DoxyCodeLine{02267     \textcolor{keyword}{public}:}
\DoxyCodeLine{02268         \mbox{\hyperlink{classCatch_1_1Section}{Section}}( \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{02269         ~\mbox{\hyperlink{classCatch_1_1Section}{Section}}();}
\DoxyCodeLine{02270 }
\DoxyCodeLine{02271         \textcolor{comment}{// This indicates whether the section should be executed or not}}
\DoxyCodeLine{02272         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \textcolor{keyword}{const};}
\DoxyCodeLine{02273 }
\DoxyCodeLine{02274     \textcolor{keyword}{private}:}
\DoxyCodeLine{02275         \mbox{\hyperlink{structCatch_1_1SectionInfo}{SectionInfo}} m\_info;}
\DoxyCodeLine{02276 }
\DoxyCodeLine{02277         std::string m\_name;}
\DoxyCodeLine{02278         \mbox{\hyperlink{structCatch_1_1Counts}{Counts}} m\_assertions;}
\DoxyCodeLine{02279         \textcolor{keywordtype}{bool} m\_sectionIncluded;}
\DoxyCodeLine{02280         \mbox{\hyperlink{classCatch_1_1Timer}{Timer}} m\_timer;}
\DoxyCodeLine{02281     \};}
\DoxyCodeLine{02282 }
\DoxyCodeLine{02283 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{02284 }
\DoxyCodeLine{02285 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_SECTION( ... ) \(\backslash\)}}
\DoxyCodeLine{02286 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{02287 \textcolor{preprocessor}{    if( Catch::Section const\& INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_Section ) = Catch::SectionInfo( CATCH\_INTERNAL\_LINEINFO, \_\_VA\_ARGS\_\_ ) ) \(\backslash\)}}
\DoxyCodeLine{02288 \textcolor{preprocessor}{    CATCH\_INTERNAL\_UNSUPPRESS\_UNUSED\_WARNINGS}}
\DoxyCodeLine{02289 }
\DoxyCodeLine{02290 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DYNAMIC\_SECTION( ... ) \(\backslash\)}}
\DoxyCodeLine{02291 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{02292 \textcolor{preprocessor}{    if( Catch::Section const\& INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_Section ) = Catch::SectionInfo( CATCH\_INTERNAL\_LINEINFO, (Catch::ReusableStringStream() << \_\_VA\_ARGS\_\_).str() ) ) \(\backslash\)}}
\DoxyCodeLine{02293 \textcolor{preprocessor}{    CATCH\_INTERNAL\_UNSUPPRESS\_UNUSED\_WARNINGS}}
\DoxyCodeLine{02294 }
\DoxyCodeLine{02295 \textcolor{comment}{// end catch\_section.h}}
\DoxyCodeLine{02296 \textcolor{comment}{// start catch\_benchmark.h}}
\DoxyCodeLine{02297 }
\DoxyCodeLine{02298 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{02299 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{02300 }
\DoxyCodeLine{02301 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02302 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02303}\mbox{\hyperlink{classCatch_1_1BenchmarkLooper}{02303}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1BenchmarkLooper}{BenchmarkLooper}} \{}
\DoxyCodeLine{02304 }
\DoxyCodeLine{02305         std::string m\_name;}
\DoxyCodeLine{02306         std::size\_t m\_count = 0;}
\DoxyCodeLine{02307         std::size\_t m\_iterationsToRun = 1;}
\DoxyCodeLine{02308         uint64\_t m\_resolution;}
\DoxyCodeLine{02309         \mbox{\hyperlink{classCatch_1_1Timer}{Timer}} m\_timer;}
\DoxyCodeLine{02310 }
\DoxyCodeLine{02311         \textcolor{keyword}{static} \textcolor{keyword}{auto} getResolution() -> uint64\_t;}
\DoxyCodeLine{02312     \textcolor{keyword}{public}:}
\DoxyCodeLine{02313         \textcolor{comment}{// Keep most of this inline as it's on the code path that is being timed}}
\DoxyCodeLine{02314         \mbox{\hyperlink{classCatch_1_1BenchmarkLooper}{BenchmarkLooper}}( \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} name )}
\DoxyCodeLine{02315         :   m\_name( name ),}
\DoxyCodeLine{02316             m\_resolution( getResolution() )}
\DoxyCodeLine{02317         \{}
\DoxyCodeLine{02318             reportStart();}
\DoxyCodeLine{02319             m\_timer.start();}
\DoxyCodeLine{02320         \}}
\DoxyCodeLine{02321 }
\DoxyCodeLine{02322         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \{}
\DoxyCodeLine{02323             \textcolor{keywordflow}{if}( m\_count < m\_iterationsToRun )}
\DoxyCodeLine{02324                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{02325             \textcolor{keywordflow}{return} needsMoreIterations();}
\DoxyCodeLine{02326         \}}
\DoxyCodeLine{02327 }
\DoxyCodeLine{02328         \textcolor{keywordtype}{void} increment() \{}
\DoxyCodeLine{02329             ++m\_count;}
\DoxyCodeLine{02330         \}}
\DoxyCodeLine{02331 }
\DoxyCodeLine{02332         \textcolor{keywordtype}{void} reportStart();}
\DoxyCodeLine{02333         \textcolor{keyword}{auto} needsMoreIterations() -> bool;}
\DoxyCodeLine{02334     \};}
\DoxyCodeLine{02335 }
\DoxyCodeLine{02336 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{02337 }
\DoxyCodeLine{02338 \textcolor{preprocessor}{\#define BENCHMARK( name ) \(\backslash\)}}
\DoxyCodeLine{02339 \textcolor{preprocessor}{    for( Catch::BenchmarkLooper looper( name ); looper; looper.increment() )}}
\DoxyCodeLine{02340 }
\DoxyCodeLine{02341 \textcolor{comment}{// end catch\_benchmark.h}}
\DoxyCodeLine{02342 \textcolor{comment}{// start catch\_interfaces\_exception.h}}
\DoxyCodeLine{02343 }
\DoxyCodeLine{02344 \textcolor{comment}{// start catch\_interfaces\_registry\_hub.h}}
\DoxyCodeLine{02345 }
\DoxyCodeLine{02346 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{02347 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{02348 }
\DoxyCodeLine{02349 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02350 }
\DoxyCodeLine{02351     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{02352     \textcolor{keyword}{struct }ITestCaseRegistry;}
\DoxyCodeLine{02353     \textcolor{keyword}{struct }IExceptionTranslatorRegistry;}
\DoxyCodeLine{02354     \textcolor{keyword}{struct }IExceptionTranslator;}
\DoxyCodeLine{02355     \textcolor{keyword}{struct }IReporterRegistry;}
\DoxyCodeLine{02356     \textcolor{keyword}{struct }IReporterFactory;}
\DoxyCodeLine{02357     \textcolor{keyword}{struct }ITagAliasRegistry;}
\DoxyCodeLine{02358     \textcolor{keyword}{class }StartupExceptionRegistry;}
\DoxyCodeLine{02359 }
\DoxyCodeLine{02360     \textcolor{keyword}{using} IReporterFactoryPtr = std::shared\_ptr<IReporterFactory>;}
\DoxyCodeLine{02361 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02362}\mbox{\hyperlink{structCatch_1_1IRegistryHub}{02362}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IRegistryHub}{IRegistryHub}} \{}
\DoxyCodeLine{02363         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1IRegistryHub}{IRegistryHub}}();}
\DoxyCodeLine{02364 }
\DoxyCodeLine{02365         \textcolor{keyword}{virtual} IReporterRegistry \textcolor{keyword}{const}\& getReporterRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{02366         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1ITestCaseRegistry}{ITestCaseRegistry}} \textcolor{keyword}{const}\& getTestCaseRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{02367         \textcolor{keyword}{virtual} ITagAliasRegistry \textcolor{keyword}{const}\& getTagAliasRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{02368 }
\DoxyCodeLine{02369         \textcolor{keyword}{virtual} \mbox{\hyperlink{structCatch_1_1IExceptionTranslatorRegistry}{IExceptionTranslatorRegistry}} \textcolor{keyword}{const}\& getExceptionTranslatorRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{02370 }
\DoxyCodeLine{02371         \textcolor{keyword}{virtual} StartupExceptionRegistry \textcolor{keyword}{const}\& getStartupExceptionRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{02372     \};}
\DoxyCodeLine{02373 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02374}\mbox{\hyperlink{structCatch_1_1IMutableRegistryHub}{02374}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IMutableRegistryHub}{IMutableRegistryHub}} \{}
\DoxyCodeLine{02375         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1IMutableRegistryHub}{IMutableRegistryHub}}();}
\DoxyCodeLine{02376         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) = 0;}
\DoxyCodeLine{02377         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) = 0;}
\DoxyCodeLine{02378         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTest( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{02379         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} \mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{IExceptionTranslator}}* translator ) = 0;}
\DoxyCodeLine{02380         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTagAlias( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo ) = 0;}
\DoxyCodeLine{02381         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerStartupException() noexcept = 0;}
\DoxyCodeLine{02382     \};}
\DoxyCodeLine{02383 }
\DoxyCodeLine{02384     \mbox{\hyperlink{structCatch_1_1IRegistryHub}{IRegistryHub}} \textcolor{keyword}{const}\& getRegistryHub();}
\DoxyCodeLine{02385     \mbox{\hyperlink{structCatch_1_1IMutableRegistryHub}{IMutableRegistryHub}}\& getMutableRegistryHub();}
\DoxyCodeLine{02386     \textcolor{keywordtype}{void} cleanUp();}
\DoxyCodeLine{02387     std::string translateActiveException();}
\DoxyCodeLine{02388 }
\DoxyCodeLine{02389 \}}
\DoxyCodeLine{02390 }
\DoxyCodeLine{02391 \textcolor{comment}{// end catch\_interfaces\_registry\_hub.h}}
\DoxyCodeLine{02392 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{02393 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION\_NO\_REG( translatorName, signature) \(\backslash\)}}
\DoxyCodeLine{02394 \textcolor{preprocessor}{        static std::string translatorName( signature )}}
\DoxyCodeLine{02395 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02396 }
\DoxyCodeLine{02397 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{02398 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{02399 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{02400 }
\DoxyCodeLine{02401 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02402     \textcolor{keyword}{using} exceptionTranslateFunction = std::string(*)();}
\DoxyCodeLine{02403 }
\DoxyCodeLine{02404     \textcolor{keyword}{struct }IExceptionTranslator;}
\DoxyCodeLine{02405     \textcolor{keyword}{using} ExceptionTranslators = std::vector<std::unique\_ptr<IExceptionTranslator const>>;}
\DoxyCodeLine{02406 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02407}\mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{02407}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{IExceptionTranslator}} \{}
\DoxyCodeLine{02408         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{IExceptionTranslator}}();}
\DoxyCodeLine{02409         \textcolor{keyword}{virtual} std::string translate( ExceptionTranslators::const\_iterator it, ExceptionTranslators::const\_iterator itEnd ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{02410     \};}
\DoxyCodeLine{02411 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02412}\mbox{\hyperlink{structCatch_1_1IExceptionTranslatorRegistry}{02412}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IExceptionTranslatorRegistry}{IExceptionTranslatorRegistry}} \{}
\DoxyCodeLine{02413         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1IExceptionTranslatorRegistry}{IExceptionTranslatorRegistry}}();}
\DoxyCodeLine{02414 }
\DoxyCodeLine{02415         \textcolor{keyword}{virtual} std::string translateActiveException() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{02416     \};}
\DoxyCodeLine{02417 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02418}\mbox{\hyperlink{classCatch_1_1ExceptionTranslatorRegistrar}{02418}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1ExceptionTranslatorRegistrar}{ExceptionTranslatorRegistrar}} \{}
\DoxyCodeLine{02419         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{02420         \textcolor{keyword}{class }ExceptionTranslator : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1IExceptionTranslator}{IExceptionTranslator}} \{}
\DoxyCodeLine{02421         \textcolor{keyword}{public}:}
\DoxyCodeLine{02422 }
\DoxyCodeLine{02423             ExceptionTranslator( std::string(*translateFunction)( T\& ) )}
\DoxyCodeLine{02424             : m\_translateFunction( translateFunction )}
\DoxyCodeLine{02425             \{\}}
\DoxyCodeLine{02426 }
\DoxyCodeLine{02427             std::string translate( ExceptionTranslators::const\_iterator it, ExceptionTranslators::const\_iterator itEnd )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02428                 \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{02429                     \textcolor{keywordflow}{if}( it == itEnd )}
\DoxyCodeLine{02430                         std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{02431                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02432                         \textcolor{keywordflow}{return} (*it)->translate( it+1, itEnd );}
\DoxyCodeLine{02433                 \}}
\DoxyCodeLine{02434                 \textcolor{keywordflow}{catch}( T\& ex ) \{}
\DoxyCodeLine{02435                     \textcolor{keywordflow}{return} m\_translateFunction( ex );}
\DoxyCodeLine{02436                 \}}
\DoxyCodeLine{02437             \}}
\DoxyCodeLine{02438 }
\DoxyCodeLine{02439         \textcolor{keyword}{protected}:}
\DoxyCodeLine{02440             std::string(*m\_translateFunction)( T\& );}
\DoxyCodeLine{02441         \};}
\DoxyCodeLine{02442 }
\DoxyCodeLine{02443     \textcolor{keyword}{public}:}
\DoxyCodeLine{02444         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{02445         \mbox{\hyperlink{classCatch_1_1ExceptionTranslatorRegistrar}{ExceptionTranslatorRegistrar}}( std::string(*translateFunction)( T\& ) ) \{}
\DoxyCodeLine{02446             getMutableRegistryHub().registerTranslator}
\DoxyCodeLine{02447                 ( \textcolor{keyword}{new} ExceptionTranslator<T>( translateFunction ) );}
\DoxyCodeLine{02448         \}}
\DoxyCodeLine{02449     \};}
\DoxyCodeLine{02450 \}}
\DoxyCodeLine{02451 }
\DoxyCodeLine{02453 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION2( translatorName, signature ) \(\backslash\)}}
\DoxyCodeLine{02454 \textcolor{preprocessor}{    static std::string translatorName( signature ); \(\backslash\)}}
\DoxyCodeLine{02455 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{02456 \textcolor{preprocessor}{    namespace\{ Catch::ExceptionTranslatorRegistrar INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionRegistrar )( \&translatorName ); \} \(\backslash\)}}
\DoxyCodeLine{02457 \textcolor{preprocessor}{    CATCH\_INTERNAL\_UNSUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{02458 \textcolor{preprocessor}{    static std::string translatorName( signature )}}
\DoxyCodeLine{02459 }
\DoxyCodeLine{02460 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION2( INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionTranslator ), signature )}}
\DoxyCodeLine{02461 }
\DoxyCodeLine{02462 \textcolor{comment}{// end catch\_interfaces\_exception.h}}
\DoxyCodeLine{02463 \textcolor{comment}{// start catch\_approx.h}}
\DoxyCodeLine{02464 }
\DoxyCodeLine{02465 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{02466 }
\DoxyCodeLine{02467 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02468 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{02469 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02470}\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{02470}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \{}
\DoxyCodeLine{02471     \textcolor{keyword}{private}:}
\DoxyCodeLine{02472         \textcolor{keywordtype}{bool} equalityComparisonImpl(\textcolor{keywordtype}{double} other) \textcolor{keyword}{const};}
\DoxyCodeLine{02473         \textcolor{comment}{// Validates the new margin (margin >= 0)}}
\DoxyCodeLine{02474         \textcolor{comment}{// out-of-line to avoid including stdexcept in the header}}
\DoxyCodeLine{02475         \textcolor{keywordtype}{void} setMargin(\textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{02476         \textcolor{comment}{// Validates the new epsilon (0 < epsilon < 1)}}
\DoxyCodeLine{02477         \textcolor{comment}{// out-of-line to avoid including stdexcept in the header}}
\DoxyCodeLine{02478         \textcolor{keywordtype}{void} setEpsilon(\textcolor{keywordtype}{double} epsilon);}
\DoxyCodeLine{02479 }
\DoxyCodeLine{02480     \textcolor{keyword}{public}:}
\DoxyCodeLine{02481         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} ( \textcolor{keywordtype}{double} value );}
\DoxyCodeLine{02482 }
\DoxyCodeLine{02483         \textcolor{keyword}{static} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} custom();}
\DoxyCodeLine{02484 }
\DoxyCodeLine{02485         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} operator-() \textcolor{keyword}{const};}
\DoxyCodeLine{02486 }
\DoxyCodeLine{02487         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02488         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} operator()( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{02489             \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} approx( static\_cast<double>(value) );}
\DoxyCodeLine{02490             approx.m\_epsilon = m\_epsilon;}
\DoxyCodeLine{02491             approx.m\_margin = m\_margin;}
\DoxyCodeLine{02492             approx.m\_scale = m\_scale;}
\DoxyCodeLine{02493             \textcolor{keywordflow}{return} approx;}
\DoxyCodeLine{02494         \}}
\DoxyCodeLine{02495 }
\DoxyCodeLine{02496         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02497         \textcolor{keyword}{explicit} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}( T \textcolor{keyword}{const}\& value ): \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}(static\_cast<double>(value))}
\DoxyCodeLine{02498         \{\}}
\DoxyCodeLine{02499 }
\DoxyCodeLine{02500         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02501         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \textcolor{keyword}{const} T\& lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{02502             \textcolor{keyword}{auto} lhs\_v = static\_cast<double>(lhs);}
\DoxyCodeLine{02503             \textcolor{keywordflow}{return} rhs.equalityComparisonImpl(lhs\_v);}
\DoxyCodeLine{02504         \}}
\DoxyCodeLine{02505 }
\DoxyCodeLine{02506         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02507         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, \textcolor{keyword}{const} T\& rhs ) \{}
\DoxyCodeLine{02508             \textcolor{keywordflow}{return} operator==( rhs, lhs );}
\DoxyCodeLine{02509         \}}
\DoxyCodeLine{02510 }
\DoxyCodeLine{02511         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02512         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{02513             \textcolor{keywordflow}{return} !operator==( lhs, rhs );}
\DoxyCodeLine{02514         \}}
\DoxyCodeLine{02515 }
\DoxyCodeLine{02516         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02517         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{02518             \textcolor{keywordflow}{return} !operator==( rhs, lhs );}
\DoxyCodeLine{02519         \}}
\DoxyCodeLine{02520 }
\DoxyCodeLine{02521         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02522         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{02523             \textcolor{keywordflow}{return} static\_cast<double>(lhs) < rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{02524         \}}
\DoxyCodeLine{02525 }
\DoxyCodeLine{02526         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02527         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{02528             \textcolor{keywordflow}{return} lhs.m\_value < static\_cast<double>(rhs) || lhs == rhs;}
\DoxyCodeLine{02529         \}}
\DoxyCodeLine{02530 }
\DoxyCodeLine{02531         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02532         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{02533             \textcolor{keywordflow}{return} static\_cast<double>(lhs) > rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{02534         \}}
\DoxyCodeLine{02535 }
\DoxyCodeLine{02536         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02537         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{02538             \textcolor{keywordflow}{return} lhs.m\_value > static\_cast<double>(rhs) || lhs == rhs;}
\DoxyCodeLine{02539         \}}
\DoxyCodeLine{02540 }
\DoxyCodeLine{02541         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02542         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& epsilon( T \textcolor{keyword}{const}\& newEpsilon ) \{}
\DoxyCodeLine{02543             \textcolor{keywordtype}{double} epsilonAsDouble = static\_cast<double>(newEpsilon);}
\DoxyCodeLine{02544             setEpsilon(epsilonAsDouble);}
\DoxyCodeLine{02545             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{02546         \}}
\DoxyCodeLine{02547 }
\DoxyCodeLine{02548         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02549         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& margin( T \textcolor{keyword}{const}\& newMargin ) \{}
\DoxyCodeLine{02550             \textcolor{keywordtype}{double} marginAsDouble = static\_cast<double>(newMargin);}
\DoxyCodeLine{02551             setMargin(marginAsDouble);}
\DoxyCodeLine{02552             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{02553         \}}
\DoxyCodeLine{02554 }
\DoxyCodeLine{02555         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{02556         \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}\& scale( T \textcolor{keyword}{const}\& newScale ) \{}
\DoxyCodeLine{02557             m\_scale = static\_cast<double>(newScale);}
\DoxyCodeLine{02558             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{02559         \}}
\DoxyCodeLine{02560 }
\DoxyCodeLine{02561         std::string toString() \textcolor{keyword}{const};}
\DoxyCodeLine{02562 }
\DoxyCodeLine{02563     \textcolor{keyword}{private}:}
\DoxyCodeLine{02564         \textcolor{keywordtype}{double} m\_epsilon;}
\DoxyCodeLine{02565         \textcolor{keywordtype}{double} m\_margin;}
\DoxyCodeLine{02566         \textcolor{keywordtype}{double} m\_scale;}
\DoxyCodeLine{02567         \textcolor{keywordtype}{double} m\_value;}
\DoxyCodeLine{02568     \};}
\DoxyCodeLine{02569 \} \textcolor{comment}{// end namespace Detail}}
\DoxyCodeLine{02570 }
\DoxyCodeLine{02571 \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{02572     \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Detail::Approx}} \textcolor{keyword}{operator} \textcolor{stringliteral}{""} \_a(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val);}
\DoxyCodeLine{02573     \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Detail::Approx}} \textcolor{keyword}{operator} \textcolor{stringliteral}{""} \_a(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val);}
\DoxyCodeLine{02574 \} \textcolor{comment}{// end namespace literals}}
\DoxyCodeLine{02575 }
\DoxyCodeLine{02576 \textcolor{keyword}{template}<>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02577}\mbox{\hyperlink{structCatch_1_1StringMaker_3_01Catch_1_1Detail_1_1Approx_01_4}{02577}} \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1StringMaker}{StringMaker}}<Catch::\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Detail::Approx}}> \{}
\DoxyCodeLine{02578     \textcolor{keyword}{static} std::string convert(\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Catch::Detail::Approx}} \textcolor{keyword}{const}\& value);}
\DoxyCodeLine{02579 \};}
\DoxyCodeLine{02580 }
\DoxyCodeLine{02581 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{02582 }
\DoxyCodeLine{02583 \textcolor{comment}{// end catch\_approx.h}}
\DoxyCodeLine{02584 \textcolor{comment}{// start catch\_string\_manip.h}}
\DoxyCodeLine{02585 }
\DoxyCodeLine{02586 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{02587 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{02588 }
\DoxyCodeLine{02589 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02590 }
\DoxyCodeLine{02591     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& prefix );}
\DoxyCodeLine{02592     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} prefix );}
\DoxyCodeLine{02593     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& suffix );}
\DoxyCodeLine{02594     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} suffix );}
\DoxyCodeLine{02595     \textcolor{keywordtype}{bool} contains( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& infix );}
\DoxyCodeLine{02596     \textcolor{keywordtype}{void} toLowerInPlace( std::string\& s );}
\DoxyCodeLine{02597     std::string toLower( std::string \textcolor{keyword}{const}\& s );}
\DoxyCodeLine{02598     std::string trim( std::string \textcolor{keyword}{const}\& str );}
\DoxyCodeLine{02599     \textcolor{keywordtype}{bool} replaceInPlace( std::string\& str, std::string \textcolor{keyword}{const}\& replaceThis, std::string \textcolor{keyword}{const}\& withThis );}
\DoxyCodeLine{02600 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02601}\mbox{\hyperlink{structCatch_1_1pluralise}{02601}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1pluralise}{pluralise}} \{}
\DoxyCodeLine{02602         \mbox{\hyperlink{structCatch_1_1pluralise}{pluralise}}( std::size\_t count, std::string \textcolor{keyword}{const}\& label );}
\DoxyCodeLine{02603 }
\DoxyCodeLine{02604         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, \mbox{\hyperlink{structCatch_1_1pluralise}{pluralise}} \textcolor{keyword}{const}\& pluraliser );}
\DoxyCodeLine{02605 }
\DoxyCodeLine{02606         std::size\_t m\_count;}
\DoxyCodeLine{02607         std::string m\_label;}
\DoxyCodeLine{02608     \};}
\DoxyCodeLine{02609 \}}
\DoxyCodeLine{02610 }
\DoxyCodeLine{02611 \textcolor{comment}{// end catch\_string\_manip.h}}
\DoxyCodeLine{02612 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{02613 \textcolor{comment}{// start catch\_capture\_matchers.h}}
\DoxyCodeLine{02614 }
\DoxyCodeLine{02615 \textcolor{comment}{// start catch\_matchers.h}}
\DoxyCodeLine{02616 }
\DoxyCodeLine{02617 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{02618 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{02619 }
\DoxyCodeLine{02620 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02621 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{02622     \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{02623 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02624}\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{02624}}         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf}};}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02625}\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAnyOf}{02625}}         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAnyOf}{MatchAnyOf}};}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02626}\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchNotOf}{02626}}         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchNotOf}{MatchNotOf}};}
\DoxyCodeLine{02627 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02628}\mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{02628}}         \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}} \{}
\DoxyCodeLine{02629         \textcolor{keyword}{public}:}
\DoxyCodeLine{02630             \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{02631             \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}} ( \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}} \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{02632             \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}}\& operator = ( \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{02633             std::string toString() \textcolor{keyword}{const};}
\DoxyCodeLine{02634 }
\DoxyCodeLine{02635         \textcolor{keyword}{protected}:}
\DoxyCodeLine{02636             \textcolor{keyword}{virtual} ~\mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}}();}
\DoxyCodeLine{02637             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{02638             \textcolor{keyword}{mutable} std::string m\_cachedToString;}
\DoxyCodeLine{02639         \};}
\DoxyCodeLine{02640 }
\DoxyCodeLine{02641 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{02642 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{02643 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "-Wnon-virtual-dtor"}}
\DoxyCodeLine{02644 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02645 }
\DoxyCodeLine{02646         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectT>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02647}\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherMethod}{02647}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherMethod}{MatcherMethod}} \{}
\DoxyCodeLine{02648             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( ObjectT \textcolor{keyword}{const}\& arg ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{02649         \};}
\DoxyCodeLine{02650 }
\DoxyCodeLine{02651 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{02652 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{02653 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02654 }
\DoxyCodeLine{02655         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02656}\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{02656}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} : \mbox{\hyperlink{classCatch_1_1Matchers_1_1Impl_1_1MatcherUntypedBase}{MatcherUntypedBase}}, \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherMethod}{MatcherMethod}}<T> \{}
\DoxyCodeLine{02657 }
\DoxyCodeLine{02658             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf<T>}} operator \&\& ( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{02659             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAnyOf}{MatchAnyOf<T>}} operator || ( \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{02660             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchNotOf}{MatchNotOf<T>}} operator ! () \textcolor{keyword}{const};}
\DoxyCodeLine{02661         \};}
\DoxyCodeLine{02662 }
\DoxyCodeLine{02663         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{02664         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatchAllOf}{MatchAllOf}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{02665             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02666                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{02667                     \textcolor{keywordflow}{if} (!matcher->match(arg))}
\DoxyCodeLine{02668                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{02669                 \}}
\DoxyCodeLine{02670                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{02671             \}}
\DoxyCodeLine{02672             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02673                 std::string description;}
\DoxyCodeLine{02674                 description.reserve( 4 + m\_matchers.size()*32 );}
\DoxyCodeLine{02675                 description += \textcolor{stringliteral}{"( "};}
\DoxyCodeLine{02676                 \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{02677                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{02678                     \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{02679                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{02680                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02681                         description += \textcolor{stringliteral}{" and "};}
\DoxyCodeLine{02682                     description += matcher->toString();}
\DoxyCodeLine{02683                 \}}
\DoxyCodeLine{02684                 description += \textcolor{stringliteral}{" )"};}
\DoxyCodeLine{02685                 \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{02686             \}}
\DoxyCodeLine{02687 }
\DoxyCodeLine{02688             MatchAllOf<ArgT>\& operator \&\& ( MatcherBase<ArgT> \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{02689                 m\_matchers.push\_back( \&other );}
\DoxyCodeLine{02690                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{02691             \}}
\DoxyCodeLine{02692 }
\DoxyCodeLine{02693             std::vector<MatcherBase<ArgT> \textcolor{keyword}{const}*> m\_matchers;}
\DoxyCodeLine{02694         \};}
\DoxyCodeLine{02695         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{02696         \textcolor{keyword}{struct }MatchAnyOf : MatcherBase<ArgT> \{}
\DoxyCodeLine{02697 }
\DoxyCodeLine{02698             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02699                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{02700                     \textcolor{keywordflow}{if} (matcher->match(arg))}
\DoxyCodeLine{02701                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{02702                 \}}
\DoxyCodeLine{02703                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{02704             \}}
\DoxyCodeLine{02705             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02706                 std::string description;}
\DoxyCodeLine{02707                 description.reserve( 4 + m\_matchers.size()*32 );}
\DoxyCodeLine{02708                 description += \textcolor{stringliteral}{"( "};}
\DoxyCodeLine{02709                 \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{02710                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{02711                     \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{02712                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{02713                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02714                         description += \textcolor{stringliteral}{" or "};}
\DoxyCodeLine{02715                     description += matcher->toString();}
\DoxyCodeLine{02716                 \}}
\DoxyCodeLine{02717                 description += \textcolor{stringliteral}{" )"};}
\DoxyCodeLine{02718                 \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{02719             \}}
\DoxyCodeLine{02720 }
\DoxyCodeLine{02721             MatchAnyOf<ArgT>\& operator || ( MatcherBase<ArgT> \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{02722                 m\_matchers.push\_back( \&other );}
\DoxyCodeLine{02723                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{02724             \}}
\DoxyCodeLine{02725 }
\DoxyCodeLine{02726             std::vector<MatcherBase<ArgT> \textcolor{keyword}{const}*> m\_matchers;}
\DoxyCodeLine{02727         \};}
\DoxyCodeLine{02728 }
\DoxyCodeLine{02729         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{02730         \textcolor{keyword}{struct }MatchNotOf : MatcherBase<ArgT> \{}
\DoxyCodeLine{02731 }
\DoxyCodeLine{02732             MatchNotOf( MatcherBase<ArgT> \textcolor{keyword}{const}\& underlyingMatcher ) : m\_underlyingMatcher( underlyingMatcher ) \{\}}
\DoxyCodeLine{02733 }
\DoxyCodeLine{02734             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02735                 \textcolor{keywordflow}{return} !m\_underlyingMatcher.match( arg );}
\DoxyCodeLine{02736             \}}
\DoxyCodeLine{02737 }
\DoxyCodeLine{02738             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02739                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"not "} + m\_underlyingMatcher.toString();}
\DoxyCodeLine{02740             \}}
\DoxyCodeLine{02741             MatcherBase<ArgT> \textcolor{keyword}{const}\& m\_underlyingMatcher;}
\DoxyCodeLine{02742         \};}
\DoxyCodeLine{02743 }
\DoxyCodeLine{02744         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{02745         MatchAllOf<T> MatcherBase<T>::operator \&\& ( MatcherBase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{02746             \textcolor{keywordflow}{return} MatchAllOf<T>() \&\& *\textcolor{keyword}{this} \&\& other;}
\DoxyCodeLine{02747         \}}
\DoxyCodeLine{02748         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{02749         MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{02750             \textcolor{keywordflow}{return} MatchAnyOf<T>() || *\textcolor{keyword}{this} || other;}
\DoxyCodeLine{02751         \}}
\DoxyCodeLine{02752         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{02753         MatchNotOf<T> MatcherBase<T>::operator ! ()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{02754             \textcolor{keywordflow}{return} MatchNotOf<T>( *\textcolor{keyword}{this} );}
\DoxyCodeLine{02755         \}}
\DoxyCodeLine{02756 }
\DoxyCodeLine{02757     \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{02758 }
\DoxyCodeLine{02759 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{02760 }
\DoxyCodeLine{02761 \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{02762 \textcolor{keyword}{using} Matchers::Impl::MatcherBase;}
\DoxyCodeLine{02763 }
\DoxyCodeLine{02764 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{02765 }
\DoxyCodeLine{02766 \textcolor{comment}{// end catch\_matchers.h}}
\DoxyCodeLine{02767 \textcolor{comment}{// start catch\_matchers\_floating.h}}
\DoxyCodeLine{02768 }
\DoxyCodeLine{02769 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{02770 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{02771 }
\DoxyCodeLine{02772 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02773 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{02774 }
\DoxyCodeLine{02775     \textcolor{keyword}{namespace }Floating \{}
\DoxyCodeLine{02776 }
\DoxyCodeLine{02777         \textcolor{keyword}{enum class} FloatingPointKind : uint8\_t;}
\DoxyCodeLine{02778 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02779}\mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinAbsMatcher}{02779}}         struct \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinAbsMatcher}{WithinAbsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<double> \{}
\DoxyCodeLine{02780             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinAbsMatcher}{WithinAbsMatcher}}(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{02781             \textcolor{keywordtype}{bool} match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee) \textcolor{keyword}{const override};}
\DoxyCodeLine{02782             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{02783         \textcolor{keyword}{private}:}
\DoxyCodeLine{02784             \textcolor{keywordtype}{double} m\_target;}
\DoxyCodeLine{02785             \textcolor{keywordtype}{double} m\_margin;}
\DoxyCodeLine{02786         \};}
\DoxyCodeLine{02787 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02788}\mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinUlpsMatcher}{02788}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinUlpsMatcher}{WithinUlpsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<double> \{}
\DoxyCodeLine{02789             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinUlpsMatcher}{WithinUlpsMatcher}}(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{int} ulps, FloatingPointKind baseType);}
\DoxyCodeLine{02790             \textcolor{keywordtype}{bool} match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee) \textcolor{keyword}{const override};}
\DoxyCodeLine{02791             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{02792         \textcolor{keyword}{private}:}
\DoxyCodeLine{02793             \textcolor{keywordtype}{double} m\_target;}
\DoxyCodeLine{02794             \textcolor{keywordtype}{int} m\_ulps;}
\DoxyCodeLine{02795             FloatingPointKind m\_type;}
\DoxyCodeLine{02796         \};}
\DoxyCodeLine{02797 }
\DoxyCodeLine{02798     \} \textcolor{comment}{// namespace Floating}}
\DoxyCodeLine{02799 }
\DoxyCodeLine{02800     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{02801     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{02802     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinUlpsMatcher}{Floating::WithinUlpsMatcher}} WithinULP(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{int} maxUlpDiff);}
\DoxyCodeLine{02803     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinUlpsMatcher}{Floating::WithinUlpsMatcher}} WithinULP(\textcolor{keywordtype}{float} target, \textcolor{keywordtype}{int} maxUlpDiff);}
\DoxyCodeLine{02804     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Floating_1_1WithinAbsMatcher}{Floating::WithinAbsMatcher}} WithinAbs(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{02805 }
\DoxyCodeLine{02806 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{02807 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{02808 }
\DoxyCodeLine{02809 \textcolor{comment}{// end catch\_matchers\_floating.h}}
\DoxyCodeLine{02810 \textcolor{comment}{// start catch\_matchers\_generic.hpp}}
\DoxyCodeLine{02811 }
\DoxyCodeLine{02812 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{02813 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{02814 }
\DoxyCodeLine{02815 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02816 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{02817 \textcolor{keyword}{namespace }Generic \{}
\DoxyCodeLine{02818 }
\DoxyCodeLine{02819 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{02820     std::string finalizeDescription(\textcolor{keyword}{const} std::string\& desc);}
\DoxyCodeLine{02821 \}}
\DoxyCodeLine{02822 }
\DoxyCodeLine{02823 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02824}\mbox{\hyperlink{classCatch_1_1Matchers_1_1Generic_1_1PredicateMatcher}{02824}} \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Matchers_1_1Generic_1_1PredicateMatcher}{PredicateMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<T> \{}
\DoxyCodeLine{02825     std::function<bool(T \textcolor{keyword}{const}\&)> m\_predicate;}
\DoxyCodeLine{02826     std::string m\_description;}
\DoxyCodeLine{02827 \textcolor{keyword}{public}:}
\DoxyCodeLine{02828 }
\DoxyCodeLine{02829     \mbox{\hyperlink{classCatch_1_1Matchers_1_1Generic_1_1PredicateMatcher}{PredicateMatcher}}(std::function<\textcolor{keywordtype}{bool}(T \textcolor{keyword}{const}\&)> \textcolor{keyword}{const}\& elem, std::string \textcolor{keyword}{const}\& descr)}
\DoxyCodeLine{02830         :m\_predicate(std::move(elem)),}
\DoxyCodeLine{02831         m\_description(Detail::finalizeDescription(descr))}
\DoxyCodeLine{02832     \{\}}
\DoxyCodeLine{02833 }
\DoxyCodeLine{02834     \textcolor{keywordtype}{bool} match( T \textcolor{keyword}{const}\& item )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02835         \textcolor{keywordflow}{return} m\_predicate(item);}
\DoxyCodeLine{02836     \}}
\DoxyCodeLine{02837 }
\DoxyCodeLine{02838     std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02839         \textcolor{keywordflow}{return} m\_description;}
\DoxyCodeLine{02840     \}}
\DoxyCodeLine{02841 \};}
\DoxyCodeLine{02842 }
\DoxyCodeLine{02843 \} \textcolor{comment}{// namespace Generic}}
\DoxyCodeLine{02844 }
\DoxyCodeLine{02845     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{02846     \textcolor{comment}{// The user has to explicitly specify type to the function, because}}
\DoxyCodeLine{02847     \textcolor{comment}{// infering std::function<bool(T const\&)> is hard (but possible) and}}
\DoxyCodeLine{02848     \textcolor{comment}{// requires a lot of TMP.}}
\DoxyCodeLine{02849     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{02850     \mbox{\hyperlink{classCatch_1_1Matchers_1_1Generic_1_1PredicateMatcher}{Generic::PredicateMatcher<T>}} Predicate(std::function<\textcolor{keywordtype}{bool}(T \textcolor{keyword}{const}\&)> \textcolor{keyword}{const}\& predicate, std::string \textcolor{keyword}{const}\& description = \textcolor{stringliteral}{""}) \{}
\DoxyCodeLine{02851         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Matchers_1_1Generic_1_1PredicateMatcher}{Generic::PredicateMatcher<T>}}(predicate, description);}
\DoxyCodeLine{02852     \}}
\DoxyCodeLine{02853 }
\DoxyCodeLine{02854 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{02855 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{02856 }
\DoxyCodeLine{02857 \textcolor{comment}{// end catch\_matchers\_generic.hpp}}
\DoxyCodeLine{02858 \textcolor{comment}{// start catch\_matchers\_string.h}}
\DoxyCodeLine{02859 }
\DoxyCodeLine{02860 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{02861 }
\DoxyCodeLine{02862 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02863 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{02864 }
\DoxyCodeLine{02865     \textcolor{keyword}{namespace }StdString \{}
\DoxyCodeLine{02866 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02867}\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{02867}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}}}
\DoxyCodeLine{02868         \{}
\DoxyCodeLine{02869             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}}( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{02870             std::string adjustString( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{02871             std::string caseSensitivitySuffix() \textcolor{keyword}{const};}
\DoxyCodeLine{02872 }
\DoxyCodeLine{02873             CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{02874             std::string m\_str;}
\DoxyCodeLine{02875         \};}
\DoxyCodeLine{02876 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02877}\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{02877}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::string> \{}
\DoxyCodeLine{02878             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}}( std::string \textcolor{keyword}{const}\& operation, \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{02879             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{02880 }
\DoxyCodeLine{02881             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} m\_comparator;}
\DoxyCodeLine{02882             std::string m\_operation;}
\DoxyCodeLine{02883         \};}
\DoxyCodeLine{02884 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02885}\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EqualsMatcher}{02885}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EqualsMatcher}{EqualsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{02886             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EqualsMatcher}{EqualsMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{02887             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{02888         \};}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02889}\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1ContainsMatcher}{02889}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1ContainsMatcher}{ContainsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{02890             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1ContainsMatcher}{ContainsMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{02891             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{02892         \};}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02893}\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StartsWithMatcher}{02893}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StartsWithMatcher}{StartsWithMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{02894             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StartsWithMatcher}{StartsWithMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{02895             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{02896         \};}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02897}\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EndsWithMatcher}{02897}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EndsWithMatcher}{EndsWithMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StringMatcherBase}{StringMatcherBase}} \{}
\DoxyCodeLine{02898             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EndsWithMatcher}{EndsWithMatcher}}( \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1CasedString}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{02899             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{02900         \};}
\DoxyCodeLine{02901 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02902}\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1RegexMatcher}{02902}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1RegexMatcher}{RegexMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::string> \{}
\DoxyCodeLine{02903             \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1RegexMatcher}{RegexMatcher}}( std::string regex, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{02904             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& matchee ) \textcolor{keyword}{const override};}
\DoxyCodeLine{02905             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{02906 }
\DoxyCodeLine{02907         \textcolor{keyword}{private}:}
\DoxyCodeLine{02908             std::string m\_regex;}
\DoxyCodeLine{02909             CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{02910         \};}
\DoxyCodeLine{02911 }
\DoxyCodeLine{02912     \} \textcolor{comment}{// namespace StdString}}
\DoxyCodeLine{02913 }
\DoxyCodeLine{02914     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{02915     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{02916 }
\DoxyCodeLine{02917     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EqualsMatcher}{StdString::EqualsMatcher}} Equals( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{02918     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1ContainsMatcher}{StdString::ContainsMatcher}} Contains( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{02919     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1EndsWithMatcher}{StdString::EndsWithMatcher}} EndsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{02920     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1StartsWithMatcher}{StdString::StartsWithMatcher}} StartsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{02921     \mbox{\hyperlink{structCatch_1_1Matchers_1_1StdString_1_1RegexMatcher}{StdString::RegexMatcher}} Matches( std::string \textcolor{keyword}{const}\& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{02922 }
\DoxyCodeLine{02923 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{02924 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{02925 }
\DoxyCodeLine{02926 \textcolor{comment}{// end catch\_matchers\_string.h}}
\DoxyCodeLine{02927 \textcolor{comment}{// start catch\_matchers\_vector.h}}
\DoxyCodeLine{02928 }
\DoxyCodeLine{02929 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{02930 }
\DoxyCodeLine{02931 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{02932 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{02933 }
\DoxyCodeLine{02934     \textcolor{keyword}{namespace }Vector \{}
\DoxyCodeLine{02935         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{02936             \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIterator, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{02937             \textcolor{keywordtype}{size\_t} count(InputIterator first, InputIterator last, T \textcolor{keyword}{const}\& item) \{}
\DoxyCodeLine{02938                 \textcolor{keywordtype}{size\_t} cnt = 0;}
\DoxyCodeLine{02939                 \textcolor{keywordflow}{for} (; first != last; ++first) \{}
\DoxyCodeLine{02940                     \textcolor{keywordflow}{if} (*first == item) \{}
\DoxyCodeLine{02941                         ++cnt;}
\DoxyCodeLine{02942                     \}}
\DoxyCodeLine{02943                 \}}
\DoxyCodeLine{02944                 \textcolor{keywordflow}{return} cnt;}
\DoxyCodeLine{02945             \}}
\DoxyCodeLine{02946             \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIterator, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{02947             \textcolor{keywordtype}{bool} contains(InputIterator first, InputIterator last, T \textcolor{keyword}{const}\& item) \{}
\DoxyCodeLine{02948                 \textcolor{keywordflow}{for} (; first != last; ++first) \{}
\DoxyCodeLine{02949                     \textcolor{keywordflow}{if} (*first == item) \{}
\DoxyCodeLine{02950                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{02951                     \}}
\DoxyCodeLine{02952                 \}}
\DoxyCodeLine{02953                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{02954             \}}
\DoxyCodeLine{02955         \}}
\DoxyCodeLine{02956 }
\DoxyCodeLine{02957         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02958}\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{02958}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{ContainsElementMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T>> \{}
\DoxyCodeLine{02959 }
\DoxyCodeLine{02960             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{ContainsElementMatcher}}(T \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator) \{\}}
\DoxyCodeLine{02961 }
\DoxyCodeLine{02962             \textcolor{keywordtype}{bool} match(std::vector<T> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02963                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& el : v) \{}
\DoxyCodeLine{02964                     \textcolor{keywordflow}{if} (el == m\_comparator) \{}
\DoxyCodeLine{02965                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{02966                     \}}
\DoxyCodeLine{02967                 \}}
\DoxyCodeLine{02968                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{02969             \}}
\DoxyCodeLine{02970 }
\DoxyCodeLine{02971             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02972                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Contains: "} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{02973             \}}
\DoxyCodeLine{02974 }
\DoxyCodeLine{02975             T \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{02976         \};}
\DoxyCodeLine{02977 }
\DoxyCodeLine{02978         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l02979}\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{02979}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{ContainsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T>> \{}
\DoxyCodeLine{02980 }
\DoxyCodeLine{02981             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{ContainsMatcher}}(std::vector<T> \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{02982 }
\DoxyCodeLine{02983             \textcolor{keywordtype}{bool} match(std::vector<T> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{02984                 \textcolor{comment}{// !TBD: see note in EqualsMatcher}}
\DoxyCodeLine{02985                 \textcolor{keywordflow}{if} (m\_comparator.size() > v.size())}
\DoxyCodeLine{02986                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{02987                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& comparator : m\_comparator) \{}
\DoxyCodeLine{02988                     \textcolor{keyword}{auto} present = \textcolor{keyword}{false};}
\DoxyCodeLine{02989                     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : v) \{}
\DoxyCodeLine{02990                         \textcolor{keywordflow}{if} (el == comparator) \{}
\DoxyCodeLine{02991                             present = \textcolor{keyword}{true};}
\DoxyCodeLine{02992                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{02993                         \}}
\DoxyCodeLine{02994                     \}}
\DoxyCodeLine{02995                     \textcolor{keywordflow}{if} (!present) \{}
\DoxyCodeLine{02996                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{02997                     \}}
\DoxyCodeLine{02998                 \}}
\DoxyCodeLine{02999                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{03000             \}}
\DoxyCodeLine{03001             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03002                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Contains: "} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{03003             \}}
\DoxyCodeLine{03004 }
\DoxyCodeLine{03005             std::vector<T> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{03006         \};}
\DoxyCodeLine{03007 }
\DoxyCodeLine{03008         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03009}\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1EqualsMatcher}{03009}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1EqualsMatcher}{EqualsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T>> \{}
\DoxyCodeLine{03010 }
\DoxyCodeLine{03011             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1EqualsMatcher}{EqualsMatcher}}(std::vector<T> \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{03012 }
\DoxyCodeLine{03013             \textcolor{keywordtype}{bool} match(std::vector<T> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03014                 \textcolor{comment}{// !TBD: This currently works if all elements can be compared using !=}}
\DoxyCodeLine{03015                 \textcolor{comment}{// - a more general approach would be via a compare template that defaults}}
\DoxyCodeLine{03016                 \textcolor{comment}{// to using !=. but could be specialised for, e.g. std::vector<T> etc}}
\DoxyCodeLine{03017                 \textcolor{comment}{// - then just call that directly}}
\DoxyCodeLine{03018                 \textcolor{keywordflow}{if} (m\_comparator.size() != v.size())}
\DoxyCodeLine{03019                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{03020                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < v.size(); ++i)}
\DoxyCodeLine{03021                     \textcolor{keywordflow}{if} (m\_comparator[i] != v[i])}
\DoxyCodeLine{03022                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{03023                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{03024             \}}
\DoxyCodeLine{03025             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03026                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Equals: "} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{03027             \}}
\DoxyCodeLine{03028             std::vector<T> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{03029         \};}
\DoxyCodeLine{03030 }
\DoxyCodeLine{03031         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03032}\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1UnorderedEqualsMatcher}{03032}}         \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1UnorderedEqualsMatcher}{UnorderedEqualsMatcher}} : \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{MatcherBase}}<std::vector<T>> \{}
\DoxyCodeLine{03033             \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1UnorderedEqualsMatcher}{UnorderedEqualsMatcher}}(std::vector<T> \textcolor{keyword}{const}\& target) : m\_target(target) \{\}}
\DoxyCodeLine{03034             \textcolor{keywordtype}{bool} match(std::vector<T> \textcolor{keyword}{const}\& vec)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03035                 \textcolor{comment}{// Note: This is a reimplementation of std::is\_permutation,}}
\DoxyCodeLine{03036                 \textcolor{comment}{//       because I don't want to include <algorithm> inside the common path}}
\DoxyCodeLine{03037                 \textcolor{keywordflow}{if} (m\_target.size() != vec.size()) \{}
\DoxyCodeLine{03038                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{03039                 \}}
\DoxyCodeLine{03040                 \textcolor{keyword}{auto} lfirst = m\_target.begin(), llast = m\_target.end();}
\DoxyCodeLine{03041                 \textcolor{keyword}{auto} rfirst = vec.begin(), rlast = vec.end();}
\DoxyCodeLine{03042                 \textcolor{comment}{// Cut common prefix to optimize checking of permuted parts}}
\DoxyCodeLine{03043                 \textcolor{keywordflow}{while} (lfirst != llast \&\& *lfirst == *rfirst) \{}
\DoxyCodeLine{03044                     ++lfirst; ++rfirst;}
\DoxyCodeLine{03045                 \}}
\DoxyCodeLine{03046                 \textcolor{keywordflow}{if} (lfirst == llast) \{}
\DoxyCodeLine{03047                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{03048                 \}}
\DoxyCodeLine{03049 }
\DoxyCodeLine{03050                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} mid = lfirst; mid != llast; ++mid) \{}
\DoxyCodeLine{03051                     \textcolor{comment}{// Skip already counted items}}
\DoxyCodeLine{03052                     \textcolor{keywordflow}{if} (Detail::contains(lfirst, mid, *mid)) \{}
\DoxyCodeLine{03053                         \textcolor{keywordflow}{continue};}
\DoxyCodeLine{03054                     \}}
\DoxyCodeLine{03055                     \textcolor{keywordtype}{size\_t} num\_vec = Detail::count(rfirst, rlast, *mid);}
\DoxyCodeLine{03056                     \textcolor{keywordflow}{if} (num\_vec == 0 || Detail::count(lfirst, llast, *mid) != num\_vec) \{}
\DoxyCodeLine{03057                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{03058                     \}}
\DoxyCodeLine{03059                 \}}
\DoxyCodeLine{03060 }
\DoxyCodeLine{03061                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{03062             \}}
\DoxyCodeLine{03063 }
\DoxyCodeLine{03064             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03065                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"UnorderedEquals: "} + ::Catch::Detail::stringify(m\_target);}
\DoxyCodeLine{03066             \}}
\DoxyCodeLine{03067         \textcolor{keyword}{private}:}
\DoxyCodeLine{03068             std::vector<T> \textcolor{keyword}{const}\& m\_target;}
\DoxyCodeLine{03069         \};}
\DoxyCodeLine{03070 }
\DoxyCodeLine{03071     \} \textcolor{comment}{// namespace Vector}}
\DoxyCodeLine{03072 }
\DoxyCodeLine{03073     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{03074     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{03075 }
\DoxyCodeLine{03076     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03077     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{Vector::ContainsMatcher<T>}} Contains( std::vector<T> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{03078         \textcolor{keywordflow}{return} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsMatcher}{Vector::ContainsMatcher<T>}}( comparator );}
\DoxyCodeLine{03079     \}}
\DoxyCodeLine{03080 }
\DoxyCodeLine{03081     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03082     \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{Vector::ContainsElementMatcher<T>}} VectorContains( T \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{03083         \textcolor{keywordflow}{return} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Vector_1_1ContainsElementMatcher}{Vector::ContainsElementMatcher<T>}}( comparator );}
\DoxyCodeLine{03084     \}}
\DoxyCodeLine{03085 }
\DoxyCodeLine{03086     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03087     Vector::EqualsMatcher<T> Equals( std::vector<T> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{03088         \textcolor{keywordflow}{return} Vector::EqualsMatcher<T>( comparator );}
\DoxyCodeLine{03089     \}}
\DoxyCodeLine{03090 }
\DoxyCodeLine{03091     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03092     Vector::UnorderedEqualsMatcher<T> UnorderedEquals(std::vector<T> \textcolor{keyword}{const}\& target) \{}
\DoxyCodeLine{03093         \textcolor{keywordflow}{return} Vector::UnorderedEqualsMatcher<T>(target);}
\DoxyCodeLine{03094     \}}
\DoxyCodeLine{03095 }
\DoxyCodeLine{03096 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{03097 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{03098 }
\DoxyCodeLine{03099 \textcolor{comment}{// end catch\_matchers\_vector.h}}
\DoxyCodeLine{03100 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{03101 }
\DoxyCodeLine{03102     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03103}\mbox{\hyperlink{classCatch_1_1MatchExpr}{03103}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1MatchExpr}{MatchExpr}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}} \{}
\DoxyCodeLine{03104         ArgT \textcolor{keyword}{const}\& m\_arg;}
\DoxyCodeLine{03105         MatcherT m\_matcher;}
\DoxyCodeLine{03106         \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} m\_matcherString;}
\DoxyCodeLine{03107     \textcolor{keyword}{public}:}
\DoxyCodeLine{03108         \mbox{\hyperlink{classCatch_1_1MatchExpr}{MatchExpr}}( ArgT \textcolor{keyword}{const}\& arg, MatcherT \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& matcherString )}
\DoxyCodeLine{03109         :   \mbox{\hyperlink{structCatch_1_1ITransientExpression}{ITransientExpression}}\{ \textcolor{keyword}{true}, matcher.match( arg ) \},}
\DoxyCodeLine{03110             m\_arg( arg ),}
\DoxyCodeLine{03111             m\_matcher( matcher ),}
\DoxyCodeLine{03112             m\_matcherString( matcherString )}
\DoxyCodeLine{03113         \{\}}
\DoxyCodeLine{03114 }
\DoxyCodeLine{03115         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03116             \textcolor{keyword}{auto} matcherAsString = m\_matcher.toString();}
\DoxyCodeLine{03117             os << Catch::Detail::stringify( m\_arg ) << \textcolor{charliteral}{' '};}
\DoxyCodeLine{03118             \textcolor{keywordflow}{if}( matcherAsString == Detail::unprintableString )}
\DoxyCodeLine{03119                 os << m\_matcherString;}
\DoxyCodeLine{03120             \textcolor{keywordflow}{else}}
\DoxyCodeLine{03121                 os << matcherAsString;}
\DoxyCodeLine{03122         \}}
\DoxyCodeLine{03123     \};}
\DoxyCodeLine{03124 }
\DoxyCodeLine{03125     \textcolor{keyword}{using} \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{StringMatcher}} = \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{Matchers::Impl::MatcherBase<std::string>}};}
\DoxyCodeLine{03126 }
\DoxyCodeLine{03127     \textcolor{keywordtype}{void} handleExceptionMatchExpr( \mbox{\hyperlink{classCatch_1_1AssertionHandler}{AssertionHandler}}\& handler, \mbox{\hyperlink{structCatch_1_1Matchers_1_1Impl_1_1MatcherBase}{StringMatcher}} \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& matcherString  );}
\DoxyCodeLine{03128 }
\DoxyCodeLine{03129     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{03130     \textcolor{keyword}{auto} makeMatchExpr( ArgT \textcolor{keyword}{const}\& arg, MatcherT \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{classCatch_1_1StringRef}{StringRef}} \textcolor{keyword}{const}\& matcherString  ) -> \mbox{\hyperlink{classCatch_1_1MatchExpr}{MatchExpr<ArgT, MatcherT>}} \{}
\DoxyCodeLine{03131         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1MatchExpr}{MatchExpr<ArgT, MatcherT>}}( arg, matcher, matcherString );}
\DoxyCodeLine{03132     \}}
\DoxyCodeLine{03133 }
\DoxyCodeLine{03134 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{03135 }
\DoxyCodeLine{03137 \textcolor{preprocessor}{\#define INTERNAL\_CHECK\_THAT( macroName, matcher, resultDisposition, arg ) \(\backslash\)}}
\DoxyCodeLine{03138 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{03139 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(arg) ", " CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{03140 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TRY \{ \(\backslash\)}}
\DoxyCodeLine{03141 \textcolor{preprocessor}{            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, \#matcher\#\#\_catch\_sr ) ); \(\backslash\)}}
\DoxyCodeLine{03142 \textcolor{preprocessor}{        \} INTERNAL\_CATCH\_CATCH( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{03143 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{03144 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{03145 }
\DoxyCodeLine{03147 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \(\backslash\)}}
\DoxyCodeLine{03148 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{03149 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_) ", " CATCH\_INTERNAL\_STRINGIFY(exceptionType) ", " CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{03150 \textcolor{preprocessor}{        if( catchAssertionHandler.allowThrows() ) \(\backslash\)}}
\DoxyCodeLine{03151 \textcolor{preprocessor}{            try \{ \(\backslash\)}}
\DoxyCodeLine{03152 \textcolor{preprocessor}{                static\_cast<void>(\_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{03153 \textcolor{preprocessor}{                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}}
\DoxyCodeLine{03154 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{03155 \textcolor{preprocessor}{            catch( exceptionType const\& ex ) \{ \(\backslash\)}}
\DoxyCodeLine{03156 \textcolor{preprocessor}{                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, \#matcher\#\#\_catch\_sr ) ); \(\backslash\)}}
\DoxyCodeLine{03157 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{03158 \textcolor{preprocessor}{            catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{03159 \textcolor{preprocessor}{                catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}}
\DoxyCodeLine{03160 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{03161 \textcolor{preprocessor}{        else \(\backslash\)}}
\DoxyCodeLine{03162 \textcolor{preprocessor}{            catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}}
\DoxyCodeLine{03163 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{03164 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{03165 }
\DoxyCodeLine{03166 \textcolor{comment}{// end catch\_capture\_matchers.h}}
\DoxyCodeLine{03167 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03168 \textcolor{comment}{// start catch\_generators.hpp}}
\DoxyCodeLine{03169 }
\DoxyCodeLine{03170 \textcolor{comment}{// start catch\_interfaces\_generatortracker.h}}
\DoxyCodeLine{03171 }
\DoxyCodeLine{03172 }
\DoxyCodeLine{03173 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{03174 }
\DoxyCodeLine{03175 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{03176 }
\DoxyCodeLine{03177     \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03178}\mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorBase}{03178}}         \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorBase}{GeneratorBase}} \{}
\DoxyCodeLine{03179         \textcolor{keyword}{protected}:}
\DoxyCodeLine{03180             \textcolor{keywordtype}{size\_t} m\_size = 0;}
\DoxyCodeLine{03181 }
\DoxyCodeLine{03182         \textcolor{keyword}{public}:}
\DoxyCodeLine{03183             \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorBase}{GeneratorBase}}( \textcolor{keywordtype}{size\_t} size ) : m\_size( size ) \{\}}
\DoxyCodeLine{03184             \textcolor{keyword}{virtual} ~\mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorBase}{GeneratorBase}}();}
\DoxyCodeLine{03185             \textcolor{keyword}{auto} size() \textcolor{keyword}{const} -> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} m\_size; \}}
\DoxyCodeLine{03186         \};}
\DoxyCodeLine{03187         \textcolor{keyword}{using} GeneratorBasePtr = std::unique\_ptr<GeneratorBase>;}
\DoxyCodeLine{03188 }
\DoxyCodeLine{03189     \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{03190 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03191}\mbox{\hyperlink{structCatch_1_1IGeneratorTracker}{03191}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IGeneratorTracker}{IGeneratorTracker}} \{}
\DoxyCodeLine{03192         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1IGeneratorTracker}{IGeneratorTracker}}();}
\DoxyCodeLine{03193         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} hasGenerator() \textcolor{keyword}{const} -> \textcolor{keywordtype}{bool} = 0;}
\DoxyCodeLine{03194         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} getGenerator() \textcolor{keyword}{const} -> Generators::GeneratorBasePtr \textcolor{keyword}{const}\& = 0;}
\DoxyCodeLine{03195         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setGenerator( Generators::GeneratorBasePtr\&\& generator ) = 0;}
\DoxyCodeLine{03196         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} getIndex() \textcolor{keyword}{const} -> std::size\_t = 0;}
\DoxyCodeLine{03197     \};}
\DoxyCodeLine{03198 }
\DoxyCodeLine{03199 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{03200 }
\DoxyCodeLine{03201 \textcolor{comment}{// end catch\_interfaces\_generatortracker.h}}
\DoxyCodeLine{03202 \textcolor{comment}{// start catch\_enforce.h}}
\DoxyCodeLine{03203 }
\DoxyCodeLine{03204 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{03205 }
\DoxyCodeLine{03206 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{03207 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{03208     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Ex>}
\DoxyCodeLine{03209     [[noreturn]]}
\DoxyCodeLine{03210     \textcolor{keywordtype}{void} throw\_exception(Ex \textcolor{keyword}{const}\& e) \{}
\DoxyCodeLine{03211         \textcolor{keywordflow}{throw} e;}
\DoxyCodeLine{03212     \}}
\DoxyCodeLine{03213 \textcolor{preprocessor}{\#else // \string^\string^ Exceptions are enabled //  Exceptions are disabled vv}}
\DoxyCodeLine{03214     [[noreturn]]}
\DoxyCodeLine{03215     \textcolor{keywordtype}{void} throw\_exception(std::exception \textcolor{keyword}{const}\& e);}
\DoxyCodeLine{03216 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03217 \} \textcolor{comment}{// namespace Catch;}}
\DoxyCodeLine{03218 }
\DoxyCodeLine{03219 \textcolor{preprocessor}{\#define CATCH\_PREPARE\_EXCEPTION( type, msg ) \(\backslash\)}}
\DoxyCodeLine{03220 \textcolor{preprocessor}{    type( ( Catch::ReusableStringStream() << msg ).str() )}}
\DoxyCodeLine{03221 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_ERROR( msg ) \(\backslash\)}}
\DoxyCodeLine{03222 \textcolor{preprocessor}{    Catch::throw\_exception(CATCH\_PREPARE\_EXCEPTION( std::logic\_error, CATCH\_INTERNAL\_LINEINFO << ": Internal Catch error: " << msg))}}
\DoxyCodeLine{03223 \textcolor{preprocessor}{\#define CATCH\_ERROR( msg ) \(\backslash\)}}
\DoxyCodeLine{03224 \textcolor{preprocessor}{    Catch::throw\_exception(CATCH\_PREPARE\_EXCEPTION( std::domain\_error, msg ))}}
\DoxyCodeLine{03225 \textcolor{preprocessor}{\#define CATCH\_RUNTIME\_ERROR( msg ) \(\backslash\)}}
\DoxyCodeLine{03226 \textcolor{preprocessor}{    Catch::throw\_exception(CATCH\_PREPARE\_EXCEPTION( std::runtime\_error, msg ))}}
\DoxyCodeLine{03227 \textcolor{preprocessor}{\#define CATCH\_ENFORCE( condition, msg ) \(\backslash\)}}
\DoxyCodeLine{03228 \textcolor{preprocessor}{    do\{ if( !(condition) ) CATCH\_ERROR( msg ); \} while(false)}}
\DoxyCodeLine{03229 }
\DoxyCodeLine{03230 \textcolor{comment}{// end catch\_enforce.h}}
\DoxyCodeLine{03231 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{03232 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{03233 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{03234 }
\DoxyCodeLine{03235 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{03236 }
\DoxyCodeLine{03237 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{03238 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{03239 }
\DoxyCodeLine{03240     \textcolor{comment}{// !TBD move this into its own location?}}
\DoxyCodeLine{03241     \textcolor{keyword}{namespace }pf\{}
\DoxyCodeLine{03242         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{03243         std::unique\_ptr<T> make\_unique( Args\&\&... args ) \{}
\DoxyCodeLine{03244             \textcolor{keywordflow}{return} std::unique\_ptr<T>(\textcolor{keyword}{new} T(std::forward<Args>(args)...));}
\DoxyCodeLine{03245         \}}
\DoxyCodeLine{03246     \}}
\DoxyCodeLine{03247 }
\DoxyCodeLine{03248     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03249}\mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{03249}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}} \{}
\DoxyCodeLine{03250         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}() \{\}}
\DoxyCodeLine{03251         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} get( \textcolor{keywordtype}{size\_t} index ) \textcolor{keyword}{const} -> T = 0;}
\DoxyCodeLine{03252     \};}
\DoxyCodeLine{03253 }
\DoxyCodeLine{03254     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03255}\mbox{\hyperlink{classCatch_1_1Generators_1_1SingleValueGenerator}{03255}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1SingleValueGenerator}{SingleValueGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{03256         T m\_value;}
\DoxyCodeLine{03257     \textcolor{keyword}{public}:}
\DoxyCodeLine{03258         \mbox{\hyperlink{classCatch_1_1Generators_1_1SingleValueGenerator}{SingleValueGenerator}}( T \textcolor{keyword}{const}\& value ) : m\_value( value ) \{\}}
\DoxyCodeLine{03259 }
\DoxyCodeLine{03260         \textcolor{keyword}{auto} get( \textcolor{keywordtype}{size\_t} ) \textcolor{keyword}{const} -> T \textcolor{keyword}{override} \{}
\DoxyCodeLine{03261             \textcolor{keywordflow}{return} m\_value;}
\DoxyCodeLine{03262         \}}
\DoxyCodeLine{03263     \};}
\DoxyCodeLine{03264 }
\DoxyCodeLine{03265     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03266}\mbox{\hyperlink{classCatch_1_1Generators_1_1FixedValuesGenerator}{03266}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1FixedValuesGenerator}{FixedValuesGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{03267         std::vector<T> m\_values;}
\DoxyCodeLine{03268 }
\DoxyCodeLine{03269     \textcolor{keyword}{public}:}
\DoxyCodeLine{03270         \mbox{\hyperlink{classCatch_1_1Generators_1_1FixedValuesGenerator}{FixedValuesGenerator}}( std::initializer\_list<T> values ) : m\_values( values ) \{\}}
\DoxyCodeLine{03271 }
\DoxyCodeLine{03272         \textcolor{keyword}{auto} get( \textcolor{keywordtype}{size\_t} index ) \textcolor{keyword}{const} -> T \textcolor{keyword}{override} \{}
\DoxyCodeLine{03273             \textcolor{keywordflow}{return} m\_values[index];}
\DoxyCodeLine{03274         \}}
\DoxyCodeLine{03275     \};}
\DoxyCodeLine{03276 }
\DoxyCodeLine{03277     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03278}\mbox{\hyperlink{classCatch_1_1Generators_1_1RangeGenerator}{03278}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1RangeGenerator}{RangeGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{03279         T \textcolor{keyword}{const} m\_first;}
\DoxyCodeLine{03280         T \textcolor{keyword}{const} m\_last;}
\DoxyCodeLine{03281 }
\DoxyCodeLine{03282     \textcolor{keyword}{public}:}
\DoxyCodeLine{03283         \mbox{\hyperlink{classCatch_1_1Generators_1_1RangeGenerator}{RangeGenerator}}( T \textcolor{keyword}{const}\& first, T \textcolor{keyword}{const}\& last ) : m\_first( first ), m\_last( last ) \{}
\DoxyCodeLine{03284             assert( m\_last > m\_first );}
\DoxyCodeLine{03285         \}}
\DoxyCodeLine{03286 }
\DoxyCodeLine{03287         \textcolor{keyword}{auto} get( \textcolor{keywordtype}{size\_t} index ) \textcolor{keyword}{const} -> T \textcolor{keyword}{override} \{}
\DoxyCodeLine{03288             \textcolor{comment}{// ToDo:: introduce a safe cast to catch potential overflows}}
\DoxyCodeLine{03289             \textcolor{keywordflow}{return} static\_cast<T>(m\_first+index);}
\DoxyCodeLine{03290         \}}
\DoxyCodeLine{03291     \};}
\DoxyCodeLine{03292 }
\DoxyCodeLine{03293     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03294}\mbox{\hyperlink{structCatch_1_1Generators_1_1NullGenerator}{03294}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Generators_1_1NullGenerator}{NullGenerator}} : \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{03295         \textcolor{keyword}{auto} get( \textcolor{keywordtype}{size\_t} ) \textcolor{keyword}{const} -> T \textcolor{keyword}{override} \{}
\DoxyCodeLine{03296             CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"A Null Generator is always empty"});}
\DoxyCodeLine{03297         \}}
\DoxyCodeLine{03298     \};}
\DoxyCodeLine{03299 }
\DoxyCodeLine{03300     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03301}\mbox{\hyperlink{classCatch_1_1Generators_1_1Generator}{03301}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1Generator}{Generator}} \{}
\DoxyCodeLine{03302         std::unique\_ptr<IGenerator<T>> m\_generator;}
\DoxyCodeLine{03303         \textcolor{keywordtype}{size\_t} m\_size;}
\DoxyCodeLine{03304 }
\DoxyCodeLine{03305     \textcolor{keyword}{public}:}
\DoxyCodeLine{03306         \mbox{\hyperlink{classCatch_1_1Generators_1_1Generator}{Generator}}( \textcolor{keywordtype}{size\_t} size, std::unique\_ptr<\mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator<T>}}> generator )}
\DoxyCodeLine{03307         :   m\_generator( std::move( generator ) ),}
\DoxyCodeLine{03308             m\_size( size )}
\DoxyCodeLine{03309         \{\}}
\DoxyCodeLine{03310 }
\DoxyCodeLine{03311         \textcolor{keyword}{auto} size() \textcolor{keyword}{const} -> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} m\_size; \}}
\DoxyCodeLine{03312         \textcolor{keyword}{auto} operator[]( \textcolor{keywordtype}{size\_t} index ) \textcolor{keyword}{const} -> T \{}
\DoxyCodeLine{03313             assert( index < m\_size );}
\DoxyCodeLine{03314             \textcolor{keywordflow}{return} m\_generator->get( index );}
\DoxyCodeLine{03315         \}}
\DoxyCodeLine{03316     \};}
\DoxyCodeLine{03317 }
\DoxyCodeLine{03318     std::vector<size\_t> randomiseIndices( \textcolor{keywordtype}{size\_t} selectionSize, \textcolor{keywordtype}{size\_t} sourceSize );}
\DoxyCodeLine{03319 }
\DoxyCodeLine{03320     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03321}\mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorRandomiser}{03321}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorRandomiser}{GeneratorRandomiser}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1Generators_1_1IGenerator}{IGenerator}}<T> \{}
\DoxyCodeLine{03322         \mbox{\hyperlink{classCatch_1_1Generators_1_1Generator}{Generator<T>}} m\_baseGenerator;}
\DoxyCodeLine{03323 }
\DoxyCodeLine{03324         std::vector<size\_t> m\_indices;}
\DoxyCodeLine{03325     \textcolor{keyword}{public}:}
\DoxyCodeLine{03326         \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorRandomiser}{GeneratorRandomiser}}( \mbox{\hyperlink{classCatch_1_1Generators_1_1Generator}{Generator<T>}}\&\& baseGenerator, \textcolor{keywordtype}{size\_t} numberOfItems )}
\DoxyCodeLine{03327         :   m\_baseGenerator( std::move( baseGenerator ) ),}
\DoxyCodeLine{03328             m\_indices( randomiseIndices( numberOfItems, m\_baseGenerator.size() ) )}
\DoxyCodeLine{03329         \{\}}
\DoxyCodeLine{03330 }
\DoxyCodeLine{03331         \textcolor{keyword}{auto} get( \textcolor{keywordtype}{size\_t} index ) \textcolor{keyword}{const} -> T \textcolor{keyword}{override} \{}
\DoxyCodeLine{03332             \textcolor{keywordflow}{return} m\_baseGenerator[m\_indices[index]];}
\DoxyCodeLine{03333         \}}
\DoxyCodeLine{03334     \};}
\DoxyCodeLine{03335 }
\DoxyCodeLine{03336     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03337}\mbox{\hyperlink{structCatch_1_1Generators_1_1RequiresASpecialisationFor}{03337}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Generators_1_1RequiresASpecialisationFor}{RequiresASpecialisationFor}};}
\DoxyCodeLine{03338 }
\DoxyCodeLine{03339     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03340     \textcolor{keyword}{auto} all() -> \mbox{\hyperlink{classCatch_1_1Generators_1_1Generator}{Generator<T>}} \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{structCatch_1_1Generators_1_1RequiresASpecialisationFor}{RequiresASpecialisationFor<T>}}(); \}}
\DoxyCodeLine{03341 }
\DoxyCodeLine{03342     \textcolor{keyword}{template}<>}
\DoxyCodeLine{03343     \textcolor{keyword}{auto} all<int>() -> \mbox{\hyperlink{classCatch_1_1Generators_1_1Generator}{Generator<int>}};}
\DoxyCodeLine{03344 }
\DoxyCodeLine{03345     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03346     \textcolor{keyword}{auto} range( T \textcolor{keyword}{const}\& first, T \textcolor{keyword}{const}\& last ) -> \mbox{\hyperlink{classCatch_1_1Generators_1_1Generator}{Generator<T>}} \{}
\DoxyCodeLine{03347         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Generators_1_1Generator}{Generator<T>}}( (last-first), pf::make\_unique<\mbox{\hyperlink{classCatch_1_1Generators_1_1RangeGenerator}{RangeGenerator<T>}}>( first, last ) );}
\DoxyCodeLine{03348     \}}
\DoxyCodeLine{03349 }
\DoxyCodeLine{03350     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03351     \textcolor{keyword}{auto} random( T \textcolor{keyword}{const}\& first, T \textcolor{keyword}{const}\& last ) -> Generator<T> \{}
\DoxyCodeLine{03352         \textcolor{keyword}{auto} gen = range( first, last );}
\DoxyCodeLine{03353         \textcolor{keyword}{auto} size = gen.size();}
\DoxyCodeLine{03354 }
\DoxyCodeLine{03355         \textcolor{keywordflow}{return} Generator<T>( size, pf::make\_unique<GeneratorRandomiser<T>>( std::move( gen ), size ) );}
\DoxyCodeLine{03356     \}}
\DoxyCodeLine{03357     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03358     \textcolor{keyword}{auto} random( \textcolor{keywordtype}{size\_t} size ) -> Generator<T> \{}
\DoxyCodeLine{03359         \textcolor{keywordflow}{return} Generator<T>( size, pf::make\_unique<GeneratorRandomiser<T>>( all<T>(), size ) );}
\DoxyCodeLine{03360     \}}
\DoxyCodeLine{03361 }
\DoxyCodeLine{03362     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03363     \textcolor{keyword}{auto} values( std::initializer\_list<T> values ) -> Generator<T> \{}
\DoxyCodeLine{03364         \textcolor{keywordflow}{return} Generator<T>( values.size(), pf::make\_unique<FixedValuesGenerator<T>>( values ) );}
\DoxyCodeLine{03365     \}}
\DoxyCodeLine{03366     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03367     \textcolor{keyword}{auto} value( T \textcolor{keyword}{const}\& val ) -> Generator<T> \{}
\DoxyCodeLine{03368         \textcolor{keywordflow}{return} Generator<T>( 1, pf::make\_unique<SingleValueGenerator<T>>( val ) );}
\DoxyCodeLine{03369     \}}
\DoxyCodeLine{03370 }
\DoxyCodeLine{03371     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03372     \textcolor{keyword}{auto} as() -> Generator<T> \{}
\DoxyCodeLine{03373         \textcolor{keywordflow}{return} Generator<T>( 0, pf::make\_unique<NullGenerator<T>>() );}
\DoxyCodeLine{03374     \}}
\DoxyCodeLine{03375 }
\DoxyCodeLine{03376     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{03377     \textcolor{keyword}{auto} table( std::initializer\_list<std::tuple<Ts...>>\&\& tuples ) -> Generator<std::tuple<Ts...>> \{}
\DoxyCodeLine{03378         \textcolor{keywordflow}{return} values<std::tuple<Ts...>>( std::forward<std::initializer\_list<std::tuple<Ts...>>>( tuples ) );}
\DoxyCodeLine{03379     \}}
\DoxyCodeLine{03380 }
\DoxyCodeLine{03381     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03382}\mbox{\hyperlink{structCatch_1_1Generators_1_1Generators}{03382}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1Generators_1_1Generators}{Generators}} : \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorBase}{GeneratorBase}} \{}
\DoxyCodeLine{03383         std::vector<Generator<T>> m\_generators;}
\DoxyCodeLine{03384 }
\DoxyCodeLine{03385         \textcolor{keyword}{using} type = T;}
\DoxyCodeLine{03386 }
\DoxyCodeLine{03387         \mbox{\hyperlink{structCatch_1_1Generators_1_1Generators}{Generators}}() : \mbox{\hyperlink{classCatch_1_1Generators_1_1GeneratorBase}{GeneratorBase}}( 0 ) \{\}}
\DoxyCodeLine{03388 }
\DoxyCodeLine{03389         \textcolor{keywordtype}{void} populate( T\&\& val ) \{}
\DoxyCodeLine{03390             m\_size += 1;}
\DoxyCodeLine{03391             m\_generators.emplace\_back( value( std::move( val ) ) );}
\DoxyCodeLine{03392         \}}
\DoxyCodeLine{03393         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{03394         \textcolor{keywordtype}{void} populate( U\&\& val ) \{}
\DoxyCodeLine{03395             populate( T( std::move( val ) ) );}
\DoxyCodeLine{03396         \}}
\DoxyCodeLine{03397         \textcolor{keywordtype}{void} populate( \mbox{\hyperlink{classCatch_1_1Generators_1_1Generator}{Generator<T>}}\&\& generator ) \{}
\DoxyCodeLine{03398             m\_size += generator.size();}
\DoxyCodeLine{03399             m\_generators.emplace\_back( std::move( generator ) );}
\DoxyCodeLine{03400         \}}
\DoxyCodeLine{03401 }
\DoxyCodeLine{03402         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{03403         \textcolor{keywordtype}{void} populate( U\&\& valueOrGenerator, Gs... moreGenerators ) \{}
\DoxyCodeLine{03404             populate( std::forward<U>( valueOrGenerator ) );}
\DoxyCodeLine{03405             populate( std::forward<Gs>( moreGenerators )... );}
\DoxyCodeLine{03406         \}}
\DoxyCodeLine{03407 }
\DoxyCodeLine{03408         \textcolor{keyword}{auto} operator[]( \textcolor{keywordtype}{size\_t} index ) \textcolor{keyword}{const} -> T \{}
\DoxyCodeLine{03409             \textcolor{keywordtype}{size\_t} sizes = 0;}
\DoxyCodeLine{03410             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& gen : m\_generators ) \{}
\DoxyCodeLine{03411                 \textcolor{keyword}{auto} localIndex = index-sizes;}
\DoxyCodeLine{03412                 sizes += gen.size();}
\DoxyCodeLine{03413                 \textcolor{keywordflow}{if}( index < sizes )}
\DoxyCodeLine{03414                     \textcolor{keywordflow}{return} gen[localIndex];}
\DoxyCodeLine{03415             \}}
\DoxyCodeLine{03416             CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"Index '"} << index << \textcolor{stringliteral}{"' is out of range ("} << sizes << \textcolor{charliteral}{')'});}
\DoxyCodeLine{03417         \}}
\DoxyCodeLine{03418     \};}
\DoxyCodeLine{03419 }
\DoxyCodeLine{03420     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{03421     \textcolor{keyword}{auto} makeGenerators( \mbox{\hyperlink{classCatch_1_1Generators_1_1Generator}{Generator<T>}}\&\& generator, Gs... moreGenerators ) -> \mbox{\hyperlink{structCatch_1_1Generators_1_1Generators}{Generators<T>}} \{}
\DoxyCodeLine{03422         \mbox{\hyperlink{structCatch_1_1Generators_1_1Generators}{Generators<T>}} generators;}
\DoxyCodeLine{03423         generators.m\_generators.reserve( 1+\textcolor{keyword}{sizeof}...(Gs) );}
\DoxyCodeLine{03424         generators.populate( std::move( generator ), std::forward<Gs>( moreGenerators )... );}
\DoxyCodeLine{03425         \textcolor{keywordflow}{return} generators;}
\DoxyCodeLine{03426     \}}
\DoxyCodeLine{03427     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03428     \textcolor{keyword}{auto} makeGenerators( Generator<T>\&\& generator ) -> Generators<T> \{}
\DoxyCodeLine{03429         Generators<T> generators;}
\DoxyCodeLine{03430         generators.populate( std::move( generator ) );}
\DoxyCodeLine{03431         \textcolor{keywordflow}{return} generators;}
\DoxyCodeLine{03432     \}}
\DoxyCodeLine{03433     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{03434     \textcolor{keyword}{auto} makeGenerators( T\&\& val, Gs... moreGenerators ) -> Generators<T> \{}
\DoxyCodeLine{03435         \textcolor{keywordflow}{return} makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );}
\DoxyCodeLine{03436     \}}
\DoxyCodeLine{03437     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{03438     \textcolor{keyword}{auto} makeGenerators( U\&\& val, Gs... moreGenerators ) -> Generators<T> \{}
\DoxyCodeLine{03439         \textcolor{keywordflow}{return} makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );}
\DoxyCodeLine{03440     \}}
\DoxyCodeLine{03441 }
\DoxyCodeLine{03442     \textcolor{keyword}{auto} acquireGeneratorTracker( SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -> IGeneratorTracker\&;}
\DoxyCodeLine{03443 }
\DoxyCodeLine{03444     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{03445     \textcolor{comment}{// Note: The type after -> is weird, because VS2015 cannot parse}}
\DoxyCodeLine{03446     \textcolor{comment}{//       the expression used in the typedef inside, when it is in}}
\DoxyCodeLine{03447     \textcolor{comment}{//       return type. Yeah, \(\backslash\)\_()\_/}}
\DoxyCodeLine{03448     \textcolor{keyword}{auto} generate( SourceLineInfo \textcolor{keyword}{const}\& lineInfo, L \textcolor{keyword}{const}\& generatorExpression ) -> decltype(std::declval<decltype(generatorExpression())>()[0]) \{}
\DoxyCodeLine{03449         \textcolor{keyword}{using} UnderlyingType = \textcolor{keyword}{typename} decltype(generatorExpression())::type;}
\DoxyCodeLine{03450 }
\DoxyCodeLine{03451         IGeneratorTracker\& tracker = acquireGeneratorTracker( lineInfo );}
\DoxyCodeLine{03452         \textcolor{keywordflow}{if}( !tracker.hasGenerator() )}
\DoxyCodeLine{03453             tracker.setGenerator( pf::make\_unique<Generators<UnderlyingType>>( generatorExpression() ) );}
\DoxyCodeLine{03454 }
\DoxyCodeLine{03455         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& generator = \textcolor{keyword}{static\_cast<}Generators<UnderlyingType> const\&\textcolor{keyword}{>}( *tracker.getGenerator() );}
\DoxyCodeLine{03456         \textcolor{keywordflow}{return} generator[tracker.getIndex()];}
\DoxyCodeLine{03457     \}}
\DoxyCodeLine{03458 }
\DoxyCodeLine{03459 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{03460 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{03461 }
\DoxyCodeLine{03462 \textcolor{preprocessor}{\#define GENERATE( ... ) \(\backslash\)}}
\DoxyCodeLine{03463 \textcolor{preprocessor}{    Catch::Generators::generate( CATCH\_INTERNAL\_LINEINFO, []\{ using namespace Catch::Generators; return makeGenerators( \_\_VA\_ARGS\_\_ ); \} )}}
\DoxyCodeLine{03464 }
\DoxyCodeLine{03465 \textcolor{comment}{// end catch\_generators.hpp}}
\DoxyCodeLine{03466 }
\DoxyCodeLine{03467 \textcolor{comment}{// These files are included here so the single\_include script doesn't put them}}
\DoxyCodeLine{03468 \textcolor{comment}{// in the conditionally compiled sections}}
\DoxyCodeLine{03469 \textcolor{comment}{// start catch\_test\_case\_info.h}}
\DoxyCodeLine{03470 }
\DoxyCodeLine{03471 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{03472 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{03473 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{03474 }
\DoxyCodeLine{03475 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{03476 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{03477 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "-Wpadded"}}
\DoxyCodeLine{03478 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03479 }
\DoxyCodeLine{03480 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{03481 }
\DoxyCodeLine{03482     \textcolor{keyword}{struct }ITestInvoker;}
\DoxyCodeLine{03483 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03484}\mbox{\hyperlink{structCatch_1_1TestCaseInfo}{03484}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}} \{}
\DoxyCodeLine{03485         \textcolor{keyword}{enum} SpecialProperties\{}
\DoxyCodeLine{03486             None = 0,}
\DoxyCodeLine{03487             IsHidden = 1 << 1,}
\DoxyCodeLine{03488             ShouldFail = 1 << 2,}
\DoxyCodeLine{03489             MayFail = 1 << 3,}
\DoxyCodeLine{03490             Throws = 1 << 4,}
\DoxyCodeLine{03491             NonPortable = 1 << 5,}
\DoxyCodeLine{03492             Benchmark = 1 << 6}
\DoxyCodeLine{03493         \};}
\DoxyCodeLine{03494 }
\DoxyCodeLine{03495         \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}}(   std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{03496                         std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{03497                         std::string \textcolor{keyword}{const}\& \_description,}
\DoxyCodeLine{03498                         std::vector<std::string> \textcolor{keyword}{const}\& \_tags,}
\DoxyCodeLine{03499                         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo );}
\DoxyCodeLine{03500 }
\DoxyCodeLine{03501         \textcolor{keyword}{friend} \textcolor{keywordtype}{void} setTags( \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}}\& testCaseInfo, std::vector<std::string> tags );}
\DoxyCodeLine{03502 }
\DoxyCodeLine{03503         \textcolor{keywordtype}{bool} isHidden() \textcolor{keyword}{const};}
\DoxyCodeLine{03504         \textcolor{keywordtype}{bool} \textcolor{keywordflow}{throws}() \textcolor{keyword}{const};}
\DoxyCodeLine{03505         \textcolor{keywordtype}{bool} okToFail() \textcolor{keyword}{const};}
\DoxyCodeLine{03506         \textcolor{keywordtype}{bool} expectedToFail() \textcolor{keyword}{const};}
\DoxyCodeLine{03507 }
\DoxyCodeLine{03508         std::string tagsAsString() \textcolor{keyword}{const};}
\DoxyCodeLine{03509 }
\DoxyCodeLine{03510         std::string name;}
\DoxyCodeLine{03511         std::string className;}
\DoxyCodeLine{03512         std::string description;}
\DoxyCodeLine{03513         std::vector<std::string> tags;}
\DoxyCodeLine{03514         std::vector<std::string> lcaseTags;}
\DoxyCodeLine{03515         \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{03516         SpecialProperties properties;}
\DoxyCodeLine{03517     \};}
\DoxyCodeLine{03518 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03519}\mbox{\hyperlink{classCatch_1_1TestCase}{03519}}     \textcolor{keyword}{class }\mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} : \textcolor{keyword}{public} \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}} \{}
\DoxyCodeLine{03520     \textcolor{keyword}{public}:}
\DoxyCodeLine{03521 }
\DoxyCodeLine{03522         \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}}( \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}}* testCase, \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}}\&\& info );}
\DoxyCodeLine{03523 }
\DoxyCodeLine{03524         \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} withName( std::string \textcolor{keyword}{const}\& \_newName ) \textcolor{keyword}{const};}
\DoxyCodeLine{03525 }
\DoxyCodeLine{03526         \textcolor{keywordtype}{void} invoke() \textcolor{keyword}{const};}
\DoxyCodeLine{03527 }
\DoxyCodeLine{03528         \mbox{\hyperlink{structCatch_1_1TestCaseInfo}{TestCaseInfo}} \textcolor{keyword}{const}\& getTestCaseInfo() \textcolor{keyword}{const};}
\DoxyCodeLine{03529 }
\DoxyCodeLine{03530         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{03531         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{03532 }
\DoxyCodeLine{03533     \textcolor{keyword}{private}:}
\DoxyCodeLine{03534         std::shared\_ptr<ITestInvoker> test;}
\DoxyCodeLine{03535     \};}
\DoxyCodeLine{03536 }
\DoxyCodeLine{03537     \mbox{\hyperlink{classCatch_1_1TestCase}{TestCase}} makeTestCase(  \mbox{\hyperlink{structCatch_1_1ITestInvoker}{ITestInvoker}}* testCase,}
\DoxyCodeLine{03538                             std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{03539                             \mbox{\hyperlink{structCatch_1_1NameAndTags}{NameAndTags}} \textcolor{keyword}{const}\& nameAndTags,}
\DoxyCodeLine{03540                             \mbox{\hyperlink{structCatch_1_1SourceLineInfo}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{03541 \}}
\DoxyCodeLine{03542 }
\DoxyCodeLine{03543 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{03544 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{03545 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03546 }
\DoxyCodeLine{03547 \textcolor{comment}{// end catch\_test\_case\_info.h}}
\DoxyCodeLine{03548 \textcolor{comment}{// start catch\_interfaces\_runner.h}}
\DoxyCodeLine{03549 }
\DoxyCodeLine{03550 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{03551 }
\DoxyCodeLine{\Hypertarget{catch_8hpp_source_l03552}\mbox{\hyperlink{structCatch_1_1IRunner}{03552}}     \textcolor{keyword}{struct }\mbox{\hyperlink{structCatch_1_1IRunner}{IRunner}} \{}
\DoxyCodeLine{03553         \textcolor{keyword}{virtual} ~\mbox{\hyperlink{structCatch_1_1IRunner}{IRunner}}();}
\DoxyCodeLine{03554         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} aborting() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{03555     \};}
\DoxyCodeLine{03556 \}}
\DoxyCodeLine{03557 }
\DoxyCodeLine{03558 \textcolor{comment}{// end catch\_interfaces\_runner.h}}
\DoxyCodeLine{03559 }
\DoxyCodeLine{03560 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{03561 \textcolor{comment}{// start catch\_objc.hpp}}
\DoxyCodeLine{03562 }
\DoxyCodeLine{03563 \textcolor{preprocessor}{\#import <objc/runtime.h>}}
\DoxyCodeLine{03564 }
\DoxyCodeLine{03565 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{03566 }
\DoxyCodeLine{03567 \textcolor{comment}{// NB. Any general catch headers included here must be included}}
\DoxyCodeLine{03568 \textcolor{comment}{// in catch.hpp first to make sure they are included by the single}}
\DoxyCodeLine{03569 \textcolor{comment}{// header for non obj-usage}}
\DoxyCodeLine{03570 }
\DoxyCodeLine{03572 \textcolor{comment}{// This protocol is really only here for (self) documenting purposes, since}}
\DoxyCodeLine{03573 \textcolor{comment}{// all its methods are optional.}}
\DoxyCodeLine{03574 \textcolor{keyword}{@protocol }OcFixture}
\DoxyCodeLine{03575 }
\DoxyCodeLine{03576 \textcolor{keyword}{@optional}}
\DoxyCodeLine{03577 }
\DoxyCodeLine{03578 -(void) setUp;}
\DoxyCodeLine{03579 -(void) tearDown;}
\DoxyCodeLine{03580 }
\DoxyCodeLine{03581 \textcolor{keyword}{@end}}
\DoxyCodeLine{03582 }
\DoxyCodeLine{03583 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{03584 }
\DoxyCodeLine{03585     \textcolor{keyword}{class }OcMethod : \textcolor{keyword}{public} ITestInvoker \{}
\DoxyCodeLine{03586 }
\DoxyCodeLine{03587     \textcolor{keyword}{public}:}
\DoxyCodeLine{03588         OcMethod( Class cls, \textcolor{keywordtype}{SEL} sel ) : m\_cls( cls ), m\_sel( sel ) \{\}}
\DoxyCodeLine{03589 }
\DoxyCodeLine{03590         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{03591             \textcolor{keywordtype}{id} obj = [[m\_cls alloc] init];}
\DoxyCodeLine{03592 }
\DoxyCodeLine{03593             performOptionalSelector( obj, \textcolor{keyword}{@selector}(setUp)  );}
\DoxyCodeLine{03594             performOptionalSelector( obj, m\_sel );}
\DoxyCodeLine{03595             performOptionalSelector( obj, \textcolor{keyword}{@selector}(tearDown)  );}
\DoxyCodeLine{03596 }
\DoxyCodeLine{03597             arcSafeRelease( obj );}
\DoxyCodeLine{03598         \}}
\DoxyCodeLine{03599     \textcolor{keyword}{private}:}
\DoxyCodeLine{03600         \textcolor{keyword}{virtual} ~OcMethod() \{\}}
\DoxyCodeLine{03601 }
\DoxyCodeLine{03602         Class m\_cls;}
\DoxyCodeLine{03603         \textcolor{keywordtype}{SEL} m\_sel;}
\DoxyCodeLine{03604     \};}
\DoxyCodeLine{03605 }
\DoxyCodeLine{03606     \textcolor{keyword}{namespace }Detail\{}
\DoxyCodeLine{03607 }
\DoxyCodeLine{03608         \textcolor{keyword}{inline} std::string getAnnotation(   Class cls,}
\DoxyCodeLine{03609                                             std::string \textcolor{keyword}{const}\& annotationName,}
\DoxyCodeLine{03610                                             std::string \textcolor{keyword}{const}\& testCaseName ) \{}
\DoxyCodeLine{03611             NSString* selStr = [[NSString alloc] initWithFormat:@"Catch\_\%s\_\%s", annotationName.c\_str(), testCaseName.c\_str()];}
\DoxyCodeLine{03612             \textcolor{keywordtype}{SEL} sel = NSSelectorFromString( selStr );}
\DoxyCodeLine{03613             arcSafeRelease( selStr );}
\DoxyCodeLine{03614             \textcolor{keywordtype}{id} value = performOptionalSelector( cls, sel );}
\DoxyCodeLine{03615             \textcolor{keywordflow}{if}( value )}
\DoxyCodeLine{03616                 \textcolor{keywordflow}{return} [(NSString*)value UTF8String];}
\DoxyCodeLine{03617             \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};}
\DoxyCodeLine{03618         \}}
\DoxyCodeLine{03619     \}}
\DoxyCodeLine{03620 }
\DoxyCodeLine{03621     \textcolor{keyword}{inline} std::size\_t registerTestMethods() \{}
\DoxyCodeLine{03622         std::size\_t noTestMethods = 0;}
\DoxyCodeLine{03623         \textcolor{keywordtype}{int} noClasses = objc\_getClassList( \textcolor{keyword}{nullptr}, 0 );}
\DoxyCodeLine{03624 }
\DoxyCodeLine{03625         Class* classes = (CATCH\_UNSAFE\_UNRETAINED Class *)malloc( \textcolor{keyword}{sizeof}(Class) * noClasses);}
\DoxyCodeLine{03626         objc\_getClassList( classes, noClasses );}
\DoxyCodeLine{03627 }
\DoxyCodeLine{03628         \textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} c = 0; c < noClasses; c++ ) \{}
\DoxyCodeLine{03629             Class cls = classes[c];}
\DoxyCodeLine{03630             \{}
\DoxyCodeLine{03631                 u\_int count;}
\DoxyCodeLine{03632                 Method* methods = class\_copyMethodList( cls, \&count );}
\DoxyCodeLine{03633                 \textcolor{keywordflow}{for}( u\_int m = 0; m < count ; m++ ) \{}
\DoxyCodeLine{03634                     \textcolor{keywordtype}{SEL} selector = method\_getName(methods[m]);}
\DoxyCodeLine{03635                     std::string methodName = sel\_getName(selector);}
\DoxyCodeLine{03636                     \textcolor{keywordflow}{if}( startsWith( methodName, \textcolor{stringliteral}{"Catch\_TestCase\_"} ) ) \{}
\DoxyCodeLine{03637                         std::string testCaseName = methodName.substr( 15 );}
\DoxyCodeLine{03638                         std::string name = Detail::getAnnotation( cls, \textcolor{stringliteral}{"Name"}, testCaseName );}
\DoxyCodeLine{03639                         std::string desc = Detail::getAnnotation( cls, \textcolor{stringliteral}{"Description"}, testCaseName );}
\DoxyCodeLine{03640                         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* className = class\_getName( cls );}
\DoxyCodeLine{03641 }
\DoxyCodeLine{03642                         getMutableRegistryHub().registerTest( makeTestCase( \textcolor{keyword}{new} OcMethod( cls, selector ), className, NameAndTags( name.c\_str(), desc.c\_str() ), SourceLineInfo(\textcolor{stringliteral}{""},0) ) );}
\DoxyCodeLine{03643                         noTestMethods++;}
\DoxyCodeLine{03644                     \}}
\DoxyCodeLine{03645                 \}}
\DoxyCodeLine{03646                 free(methods);}
\DoxyCodeLine{03647             \}}
\DoxyCodeLine{03648         \}}
\DoxyCodeLine{03649         \textcolor{keywordflow}{return} noTestMethods;}
\DoxyCodeLine{03650     \}}
\DoxyCodeLine{03651 }
\DoxyCodeLine{03652 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{03653 }
\DoxyCodeLine{03654     \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{03655         \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{03656         \textcolor{keyword}{namespace }NSStringMatchers \{}
\DoxyCodeLine{03657 }
\DoxyCodeLine{03658             \textcolor{keyword}{struct }StringHolder : MatcherBase<NSString*>\{}
\DoxyCodeLine{03659                 StringHolder( NSString* substr ) : m\_substr( [substr copy] )\{\}}
\DoxyCodeLine{03660                 StringHolder( StringHolder \textcolor{keyword}{const}\& other ) : m\_substr( [other.m\_substr copy] )\{\}}
\DoxyCodeLine{03661                 StringHolder() \{}
\DoxyCodeLine{03662                     arcSafeRelease( m\_substr );}
\DoxyCodeLine{03663                 \}}
\DoxyCodeLine{03664 }
\DoxyCodeLine{03665                 \textcolor{keywordtype}{bool} match( NSString* arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03666                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{03667                 \}}
\DoxyCodeLine{03668 }
\DoxyCodeLine{03669                 NSString* CATCH\_ARC\_STRONG m\_substr;}
\DoxyCodeLine{03670             \};}
\DoxyCodeLine{03671 }
\DoxyCodeLine{03672             \textcolor{keyword}{struct }Equals : StringHolder \{}
\DoxyCodeLine{03673                 Equals( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{03674 }
\DoxyCodeLine{03675                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03676                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{03677                             [str isEqualToString:m\_substr];}
\DoxyCodeLine{03678                 \}}
\DoxyCodeLine{03679 }
\DoxyCodeLine{03680                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03681                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"equals string: "} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{03682                 \}}
\DoxyCodeLine{03683             \};}
\DoxyCodeLine{03684 }
\DoxyCodeLine{03685             \textcolor{keyword}{struct }Contains : StringHolder \{}
\DoxyCodeLine{03686                 Contains( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{03687 }
\DoxyCodeLine{03688                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{03689                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{03690                             [str rangeOfString:m\_substr].location != NSNotFound;}
\DoxyCodeLine{03691                 \}}
\DoxyCodeLine{03692 }
\DoxyCodeLine{03693                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03694                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"contains string: "} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{03695                 \}}
\DoxyCodeLine{03696             \};}
\DoxyCodeLine{03697 }
\DoxyCodeLine{03698             \textcolor{keyword}{struct }StartsWith : StringHolder \{}
\DoxyCodeLine{03699                 StartsWith( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{03700 }
\DoxyCodeLine{03701                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03702                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{03703                             [str rangeOfString:m\_substr].location == 0;}
\DoxyCodeLine{03704                 \}}
\DoxyCodeLine{03705 }
\DoxyCodeLine{03706                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03707                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"starts with: "} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{03708                 \}}
\DoxyCodeLine{03709             \};}
\DoxyCodeLine{03710             \textcolor{keyword}{struct }EndsWith : StringHolder \{}
\DoxyCodeLine{03711                 EndsWith( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{03712 }
\DoxyCodeLine{03713                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03714                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{03715                             [str rangeOfString:m\_substr].location == [str length] - [m\_substr length];}
\DoxyCodeLine{03716                 \}}
\DoxyCodeLine{03717 }
\DoxyCodeLine{03718                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{03719                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"ends with: "} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{03720                 \}}
\DoxyCodeLine{03721             \};}
\DoxyCodeLine{03722 }
\DoxyCodeLine{03723         \} \textcolor{comment}{// namespace NSStringMatchers}}
\DoxyCodeLine{03724         \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{03725 }
\DoxyCodeLine{03726         \textcolor{keyword}{inline} Impl::NSStringMatchers::Equals}
\DoxyCodeLine{03727             Equals( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::Equals( substr ); \}}
\DoxyCodeLine{03728 }
\DoxyCodeLine{03729         \textcolor{keyword}{inline} Impl::NSStringMatchers::Contains}
\DoxyCodeLine{03730             Contains( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::Contains( substr ); \}}
\DoxyCodeLine{03731 }
\DoxyCodeLine{03732         \textcolor{keyword}{inline} Impl::NSStringMatchers::StartsWith}
\DoxyCodeLine{03733             StartsWith( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::StartsWith( substr ); \}}
\DoxyCodeLine{03734 }
\DoxyCodeLine{03735         \textcolor{keyword}{inline} Impl::NSStringMatchers::EndsWith}
\DoxyCodeLine{03736             EndsWith( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::EndsWith( substr ); \}}
\DoxyCodeLine{03737 }
\DoxyCodeLine{03738     \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{03739 }
\DoxyCodeLine{03740     \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{03741 }
\DoxyCodeLine{03742 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{03743 }
\DoxyCodeLine{03744 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{03745 }
\DoxyCodeLine{03747 \textcolor{preprocessor}{\#define OC\_MAKE\_UNIQUE\_NAME( root, uniqueSuffix ) root\#\#uniqueSuffix}}
\DoxyCodeLine{03748 \textcolor{preprocessor}{\#define OC\_TEST\_CASE2( name, desc, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{03749 \textcolor{preprocessor}{+(NSString*) OC\_MAKE\_UNIQUE\_NAME( Catch\_Name\_test\_, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{03750 \textcolor{preprocessor}{\{ \(\backslash\)}}
\DoxyCodeLine{03751 \textcolor{preprocessor}{return @ name; \(\backslash\)}}
\DoxyCodeLine{03752 \textcolor{preprocessor}{\} \(\backslash\)}}
\DoxyCodeLine{03753 \textcolor{preprocessor}{+(NSString*) OC\_MAKE\_UNIQUE\_NAME( Catch\_Description\_test\_, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{03754 \textcolor{preprocessor}{\{ \(\backslash\)}}
\DoxyCodeLine{03755 \textcolor{preprocessor}{return @ desc; \(\backslash\)}}
\DoxyCodeLine{03756 \textcolor{preprocessor}{\} \(\backslash\)}}
\DoxyCodeLine{03757 \textcolor{preprocessor}{-(void) OC\_MAKE\_UNIQUE\_NAME( Catch\_TestCase\_test\_, uniqueSuffix )}}
\DoxyCodeLine{03758 }
\DoxyCodeLine{03759 \textcolor{preprocessor}{\#define OC\_TEST\_CASE( name, desc ) OC\_TEST\_CASE2( name, desc, \_\_LINE\_\_ )}}
\DoxyCodeLine{03760 }
\DoxyCodeLine{03761 \textcolor{comment}{// end catch\_objc.hpp}}
\DoxyCodeLine{03762 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03763 }
\DoxyCodeLine{03764 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_EXTERNAL\_INTERFACES}}
\DoxyCodeLine{03765 \textcolor{comment}{// start catch\_external\_interfaces.h}}
\DoxyCodeLine{03766 }
\DoxyCodeLine{03767 \textcolor{comment}{// start catch\_reporter\_bases.hpp}}
\DoxyCodeLine{03768 }
\DoxyCodeLine{03769 \textcolor{comment}{// start catch\_interfaces\_reporter.h}}
\DoxyCodeLine{03770 }
\DoxyCodeLine{03771 \textcolor{comment}{// start catch\_config.hpp}}
\DoxyCodeLine{03772 }
\DoxyCodeLine{03773 \textcolor{comment}{// start catch\_test\_spec\_parser.h}}
\DoxyCodeLine{03774 }
\DoxyCodeLine{03775 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{03776 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{03777 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "-Wpadded"}}
\DoxyCodeLine{03778 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03779 }
\DoxyCodeLine{03780 \textcolor{comment}{// start catch\_test\_spec.h}}
\DoxyCodeLine{03781 }
\DoxyCodeLine{03782 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{03783 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{03784 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "-Wpadded"}}
\DoxyCodeLine{03785 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03786 }
\DoxyCodeLine{03787 \textcolor{comment}{// start catch\_wildcard\_pattern.h}}
\DoxyCodeLine{03788 }
\DoxyCodeLine{03789 \textcolor{keyword}{namespace }Catch}
\DoxyCodeLine{03790 \{}
\DoxyCodeLine{03791     \textcolor{keyword}{class }WildcardPattern \{}
\DoxyCodeLine{03792         \textcolor{keyword}{enum} WildcardPosition \{}
\DoxyCodeLine{03793             NoWildcard = 0,}
\DoxyCodeLine{03794             WildcardAtStart = 1,}
\DoxyCodeLine{03795             WildcardAtEnd = 2,}
\DoxyCodeLine{03796             WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd}
\DoxyCodeLine{03797         \};}
\DoxyCodeLine{03798 }
\DoxyCodeLine{03799     \textcolor{keyword}{public}:}
\DoxyCodeLine{03800 }
\DoxyCodeLine{03801         WildcardPattern( std::string \textcolor{keyword}{const}\& pattern, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{03802         \textcolor{keyword}{virtual} ~WildcardPattern() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{03803         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{03804 }
\DoxyCodeLine{03805     \textcolor{keyword}{private}:}
\DoxyCodeLine{03806         std::string adjustCase( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{03807         CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{03808         WildcardPosition m\_wildcard = NoWildcard;}
\DoxyCodeLine{03809         std::string m\_pattern;}
\DoxyCodeLine{03810     \};}
\DoxyCodeLine{03811 \}}
\DoxyCodeLine{03812 }
\DoxyCodeLine{03813 \textcolor{comment}{// end catch\_wildcard\_pattern.h}}
\DoxyCodeLine{03814 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{03815 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{03816 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{03817 }
\DoxyCodeLine{03818 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{03819 }
\DoxyCodeLine{03820     \textcolor{keyword}{class }TestSpec \{}
\DoxyCodeLine{03821         \textcolor{keyword}{struct }Pattern \{}
\DoxyCodeLine{03822             \textcolor{keyword}{virtual} ~Pattern();}
\DoxyCodeLine{03823             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{03824         \};}
\DoxyCodeLine{03825         \textcolor{keyword}{using} PatternPtr = std::shared\_ptr<Pattern>;}
\DoxyCodeLine{03826 }
\DoxyCodeLine{03827         \textcolor{keyword}{class }NamePattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{03828         \textcolor{keyword}{public}:}
\DoxyCodeLine{03829             NamePattern( std::string \textcolor{keyword}{const}\& name );}
\DoxyCodeLine{03830             \textcolor{keyword}{virtual} ~NamePattern();}
\DoxyCodeLine{03831             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{03832         \textcolor{keyword}{private}:}
\DoxyCodeLine{03833             WildcardPattern m\_wildcardPattern;}
\DoxyCodeLine{03834         \};}
\DoxyCodeLine{03835 }
\DoxyCodeLine{03836         \textcolor{keyword}{class }TagPattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{03837         \textcolor{keyword}{public}:}
\DoxyCodeLine{03838             TagPattern( std::string \textcolor{keyword}{const}\& tag );}
\DoxyCodeLine{03839             \textcolor{keyword}{virtual} ~TagPattern();}
\DoxyCodeLine{03840             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{03841         \textcolor{keyword}{private}:}
\DoxyCodeLine{03842             std::string m\_tag;}
\DoxyCodeLine{03843         \};}
\DoxyCodeLine{03844 }
\DoxyCodeLine{03845         \textcolor{keyword}{class }ExcludedPattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{03846         \textcolor{keyword}{public}:}
\DoxyCodeLine{03847             ExcludedPattern( PatternPtr \textcolor{keyword}{const}\& underlyingPattern );}
\DoxyCodeLine{03848             \textcolor{keyword}{virtual} ~ExcludedPattern();}
\DoxyCodeLine{03849             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{03850         \textcolor{keyword}{private}:}
\DoxyCodeLine{03851             PatternPtr m\_underlyingPattern;}
\DoxyCodeLine{03852         \};}
\DoxyCodeLine{03853 }
\DoxyCodeLine{03854         \textcolor{keyword}{struct }Filter \{}
\DoxyCodeLine{03855             std::vector<PatternPtr> m\_patterns;}
\DoxyCodeLine{03856 }
\DoxyCodeLine{03857             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const};}
\DoxyCodeLine{03858         \};}
\DoxyCodeLine{03859 }
\DoxyCodeLine{03860     \textcolor{keyword}{public}:}
\DoxyCodeLine{03861         \textcolor{keywordtype}{bool} hasFilters() \textcolor{keyword}{const};}
\DoxyCodeLine{03862         \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const};}
\DoxyCodeLine{03863 }
\DoxyCodeLine{03864     \textcolor{keyword}{private}:}
\DoxyCodeLine{03865         std::vector<Filter> m\_filters;}
\DoxyCodeLine{03866 }
\DoxyCodeLine{03867         \textcolor{keyword}{friend} \textcolor{keyword}{class }TestSpecParser;}
\DoxyCodeLine{03868     \};}
\DoxyCodeLine{03869 \}}
\DoxyCodeLine{03870 }
\DoxyCodeLine{03871 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{03872 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{03873 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03874 }
\DoxyCodeLine{03875 \textcolor{comment}{// end catch\_test\_spec.h}}
\DoxyCodeLine{03876 \textcolor{comment}{// start catch\_interfaces\_tag\_alias\_registry.h}}
\DoxyCodeLine{03877 }
\DoxyCodeLine{03878 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{03879 }
\DoxyCodeLine{03880 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{03881 }
\DoxyCodeLine{03882     \textcolor{keyword}{struct }TagAlias;}
\DoxyCodeLine{03883 }
\DoxyCodeLine{03884     \textcolor{keyword}{struct }ITagAliasRegistry \{}
\DoxyCodeLine{03885         \textcolor{keyword}{virtual} ~ITagAliasRegistry();}
\DoxyCodeLine{03886         \textcolor{comment}{// Nullptr if not present}}
\DoxyCodeLine{03887         \textcolor{keyword}{virtual} TagAlias \textcolor{keyword}{const}* find( std::string \textcolor{keyword}{const}\& alias ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{03888         \textcolor{keyword}{virtual} std::string expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{03889 }
\DoxyCodeLine{03890         \textcolor{keyword}{static} ITagAliasRegistry \textcolor{keyword}{const}\& get();}
\DoxyCodeLine{03891     \};}
\DoxyCodeLine{03892 }
\DoxyCodeLine{03893 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{03894 }
\DoxyCodeLine{03895 \textcolor{comment}{// end catch\_interfaces\_tag\_alias\_registry.h}}
\DoxyCodeLine{03896 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{03897 }
\DoxyCodeLine{03898     \textcolor{keyword}{class }TestSpecParser \{}
\DoxyCodeLine{03899         \textcolor{keyword}{enum} Mode\{ None, Name, QuotedName, Tag, EscapedName \};}
\DoxyCodeLine{03900         Mode m\_mode = None;}
\DoxyCodeLine{03901         \textcolor{keywordtype}{bool} m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{03902         std::size\_t m\_start = std::string::npos, m\_pos = 0;}
\DoxyCodeLine{03903         std::string m\_arg;}
\DoxyCodeLine{03904         std::vector<std::size\_t> m\_escapeChars;}
\DoxyCodeLine{03905         TestSpec::Filter m\_currentFilter;}
\DoxyCodeLine{03906         TestSpec m\_testSpec;}
\DoxyCodeLine{03907         ITagAliasRegistry \textcolor{keyword}{const}* m\_tagAliases = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{03908 }
\DoxyCodeLine{03909     \textcolor{keyword}{public}:}
\DoxyCodeLine{03910         TestSpecParser( ITagAliasRegistry \textcolor{keyword}{const}\& tagAliases );}
\DoxyCodeLine{03911 }
\DoxyCodeLine{03912         TestSpecParser\& parse( std::string \textcolor{keyword}{const}\& arg );}
\DoxyCodeLine{03913         TestSpec testSpec();}
\DoxyCodeLine{03914 }
\DoxyCodeLine{03915     \textcolor{keyword}{private}:}
\DoxyCodeLine{03916         \textcolor{keywordtype}{void} visitChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{03917         \textcolor{keywordtype}{void} startNewMode( Mode mode, std::size\_t start );}
\DoxyCodeLine{03918         \textcolor{keywordtype}{void} escape();}
\DoxyCodeLine{03919         std::string subString() \textcolor{keyword}{const};}
\DoxyCodeLine{03920 }
\DoxyCodeLine{03921         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{03922         \textcolor{keywordtype}{void} addPattern() \{}
\DoxyCodeLine{03923             std::string token = subString();}
\DoxyCodeLine{03924             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < m\_escapeChars.size(); ++i )}
\DoxyCodeLine{03925                 token = token.substr( 0, m\_escapeChars[i]-m\_start-i ) + token.substr( m\_escapeChars[i]-m\_start-i+1 );}
\DoxyCodeLine{03926             m\_escapeChars.clear();}
\DoxyCodeLine{03927             \textcolor{keywordflow}{if}( startsWith( token, \textcolor{stringliteral}{"exclude:"} ) ) \{}
\DoxyCodeLine{03928                 m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{03929                 token = token.substr( 8 );}
\DoxyCodeLine{03930             \}}
\DoxyCodeLine{03931             \textcolor{keywordflow}{if}( !token.empty() ) \{}
\DoxyCodeLine{03932                 TestSpec::PatternPtr pattern = std::make\_shared<T>( token );}
\DoxyCodeLine{03933                 \textcolor{keywordflow}{if}( m\_exclusion )}
\DoxyCodeLine{03934                     pattern = std::make\_shared<TestSpec::ExcludedPattern>( pattern );}
\DoxyCodeLine{03935                 m\_currentFilter.m\_patterns.push\_back( pattern );}
\DoxyCodeLine{03936             \}}
\DoxyCodeLine{03937             m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{03938             m\_mode = None;}
\DoxyCodeLine{03939         \}}
\DoxyCodeLine{03940 }
\DoxyCodeLine{03941         \textcolor{keywordtype}{void} addFilter();}
\DoxyCodeLine{03942     \};}
\DoxyCodeLine{03943     TestSpec parseTestSpec( std::string \textcolor{keyword}{const}\& arg );}
\DoxyCodeLine{03944 }
\DoxyCodeLine{03945 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{03946 }
\DoxyCodeLine{03947 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{03948 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{03949 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{03950 }
\DoxyCodeLine{03951 \textcolor{comment}{// end catch\_test\_spec\_parser.h}}
\DoxyCodeLine{03952 \textcolor{comment}{// start catch\_interfaces\_config.h}}
\DoxyCodeLine{03953 }
\DoxyCodeLine{03954 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{03955 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{03956 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{03957 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{03958 }
\DoxyCodeLine{03959 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{03960 }
\DoxyCodeLine{03961     \textcolor{keyword}{enum class} Verbosity \{}
\DoxyCodeLine{03962         Quiet = 0,}
\DoxyCodeLine{03963         Normal,}
\DoxyCodeLine{03964         High}
\DoxyCodeLine{03965     \};}
\DoxyCodeLine{03966 }
\DoxyCodeLine{03967     \textcolor{keyword}{struct }WarnAbout \{ \textcolor{keyword}{enum} What \{}
\DoxyCodeLine{03968         Nothing = 0x00,}
\DoxyCodeLine{03969         NoAssertions = 0x01,}
\DoxyCodeLine{03970         NoTests = 0x02}
\DoxyCodeLine{03971     \}; \};}
\DoxyCodeLine{03972 }
\DoxyCodeLine{03973     \textcolor{keyword}{struct }ShowDurations \{ \textcolor{keyword}{enum} OrNot \{}
\DoxyCodeLine{03974         DefaultForReporter,}
\DoxyCodeLine{03975         Always,}
\DoxyCodeLine{03976         Never}
\DoxyCodeLine{03977     \}; \};}
\DoxyCodeLine{03978     \textcolor{keyword}{struct }RunTests \{ \textcolor{keyword}{enum} InWhatOrder \{}
\DoxyCodeLine{03979         InDeclarationOrder,}
\DoxyCodeLine{03980         InLexicographicalOrder,}
\DoxyCodeLine{03981         InRandomOrder}
\DoxyCodeLine{03982     \}; \};}
\DoxyCodeLine{03983     \textcolor{keyword}{struct }UseColour \{ \textcolor{keyword}{enum} YesOrNo \{}
\DoxyCodeLine{03984         Auto,}
\DoxyCodeLine{03985         Yes,}
\DoxyCodeLine{03986         No}
\DoxyCodeLine{03987     \}; \};}
\DoxyCodeLine{03988     \textcolor{keyword}{struct }WaitForKeypress \{ \textcolor{keyword}{enum} When \{}
\DoxyCodeLine{03989         Never,}
\DoxyCodeLine{03990         BeforeStart = 1,}
\DoxyCodeLine{03991         BeforeExit = 2,}
\DoxyCodeLine{03992         BeforeStartAndExit = BeforeStart | BeforeExit}
\DoxyCodeLine{03993     \}; \};}
\DoxyCodeLine{03994 }
\DoxyCodeLine{03995     \textcolor{keyword}{class }TestSpec;}
\DoxyCodeLine{03996 }
\DoxyCodeLine{03997     \textcolor{keyword}{struct }IConfig : NonCopyable \{}
\DoxyCodeLine{03998 }
\DoxyCodeLine{03999         \textcolor{keyword}{virtual} ~IConfig();}
\DoxyCodeLine{04000 }
\DoxyCodeLine{04001         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} allowThrows() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04002         \textcolor{keyword}{virtual} std::ostream\& stream() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04003         \textcolor{keyword}{virtual} std::string name() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04004         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} includeSuccessfulResults() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04005         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} shouldDebugBreak() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04006         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} warnAboutMissingAssertions() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04007         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} warnAboutNoTests() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04008         \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} abortAfter() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04009         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} showInvisibles() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04010         \textcolor{keyword}{virtual} ShowDurations::OrNot showDurations() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04011         \textcolor{keyword}{virtual} TestSpec \textcolor{keyword}{const}\& testSpec() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04012         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasTestFilters() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04013         \textcolor{keyword}{virtual} RunTests::InWhatOrder runOrder() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04014         \textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04015         \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} benchmarkResolutionMultiple() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04016         \textcolor{keyword}{virtual} UseColour::YesOrNo useColour() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04017         \textcolor{keyword}{virtual} std::vector<std::string> \textcolor{keyword}{const}\& getSectionsToRun() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04018         \textcolor{keyword}{virtual} Verbosity verbosity() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04019     \};}
\DoxyCodeLine{04020 }
\DoxyCodeLine{04021     \textcolor{keyword}{using} IConfigPtr = std::shared\_ptr<IConfig const>;}
\DoxyCodeLine{04022 \}}
\DoxyCodeLine{04023 }
\DoxyCodeLine{04024 \textcolor{comment}{// end catch\_interfaces\_config.h}}
\DoxyCodeLine{04025 \textcolor{comment}{// Libstdc++ doesn't like incomplete classes for unique\_ptr}}
\DoxyCodeLine{04026 }
\DoxyCodeLine{04027 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{04028 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{04029 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{04030 }
\DoxyCodeLine{04031 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{04032 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{04033 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{04034 }
\DoxyCodeLine{04035 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{04036 }
\DoxyCodeLine{04037     \textcolor{keyword}{struct }IStream;}
\DoxyCodeLine{04038 }
\DoxyCodeLine{04039     \textcolor{keyword}{struct }ConfigData \{}
\DoxyCodeLine{04040         \textcolor{keywordtype}{bool} listTests = \textcolor{keyword}{false};}
\DoxyCodeLine{04041         \textcolor{keywordtype}{bool} listTags = \textcolor{keyword}{false};}
\DoxyCodeLine{04042         \textcolor{keywordtype}{bool} listReporters = \textcolor{keyword}{false};}
\DoxyCodeLine{04043         \textcolor{keywordtype}{bool} listTestNamesOnly = \textcolor{keyword}{false};}
\DoxyCodeLine{04044 }
\DoxyCodeLine{04045         \textcolor{keywordtype}{bool} showSuccessfulTests = \textcolor{keyword}{false};}
\DoxyCodeLine{04046         \textcolor{keywordtype}{bool} shouldDebugBreak = \textcolor{keyword}{false};}
\DoxyCodeLine{04047         \textcolor{keywordtype}{bool} noThrow = \textcolor{keyword}{false};}
\DoxyCodeLine{04048         \textcolor{keywordtype}{bool} showHelp = \textcolor{keyword}{false};}
\DoxyCodeLine{04049         \textcolor{keywordtype}{bool} showInvisibles = \textcolor{keyword}{false};}
\DoxyCodeLine{04050         \textcolor{keywordtype}{bool} filenamesAsTags = \textcolor{keyword}{false};}
\DoxyCodeLine{04051         \textcolor{keywordtype}{bool} libIdentify = \textcolor{keyword}{false};}
\DoxyCodeLine{04052 }
\DoxyCodeLine{04053         \textcolor{keywordtype}{int} abortAfter = -1;}
\DoxyCodeLine{04054         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed = 0;}
\DoxyCodeLine{04055         \textcolor{keywordtype}{int} benchmarkResolutionMultiple = 100;}
\DoxyCodeLine{04056 }
\DoxyCodeLine{04057         Verbosity verbosity = Verbosity::Normal;}
\DoxyCodeLine{04058         WarnAbout::What warnings = WarnAbout::Nothing;}
\DoxyCodeLine{04059         ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;}
\DoxyCodeLine{04060         RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{04061         UseColour::YesOrNo useColour = UseColour::Auto;}
\DoxyCodeLine{04062         WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;}
\DoxyCodeLine{04063 }
\DoxyCodeLine{04064         std::string outputFilename;}
\DoxyCodeLine{04065         std::string name;}
\DoxyCodeLine{04066         std::string processName;}
\DoxyCodeLine{04067 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_DEFAULT\_REPORTER}}
\DoxyCodeLine{04068 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_DEFAULT\_REPORTER "console"}}
\DoxyCodeLine{04069 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{04070         std::string reporterName = CATCH\_CONFIG\_DEFAULT\_REPORTER;}
\DoxyCodeLine{04071 \textcolor{preprocessor}{\#undef CATCH\_CONFIG\_DEFAULT\_REPORTER}}
\DoxyCodeLine{04072 }
\DoxyCodeLine{04073         std::vector<std::string> testsOrTags;}
\DoxyCodeLine{04074         std::vector<std::string> sectionsToRun;}
\DoxyCodeLine{04075     \};}
\DoxyCodeLine{04076 }
\DoxyCodeLine{04077     \textcolor{keyword}{class }Config : \textcolor{keyword}{public} IConfig \{}
\DoxyCodeLine{04078     \textcolor{keyword}{public}:}
\DoxyCodeLine{04079 }
\DoxyCodeLine{04080         Config() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04081         Config( ConfigData \textcolor{keyword}{const}\& data );}
\DoxyCodeLine{04082         \textcolor{keyword}{virtual} ~Config() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04083 }
\DoxyCodeLine{04084         std::string \textcolor{keyword}{const}\& getFilename() \textcolor{keyword}{const};}
\DoxyCodeLine{04085 }
\DoxyCodeLine{04086         \textcolor{keywordtype}{bool} listTests() \textcolor{keyword}{const};}
\DoxyCodeLine{04087         \textcolor{keywordtype}{bool} listTestNamesOnly() \textcolor{keyword}{const};}
\DoxyCodeLine{04088         \textcolor{keywordtype}{bool} listTags() \textcolor{keyword}{const};}
\DoxyCodeLine{04089         \textcolor{keywordtype}{bool} listReporters() \textcolor{keyword}{const};}
\DoxyCodeLine{04090 }
\DoxyCodeLine{04091         std::string getProcessName() \textcolor{keyword}{const};}
\DoxyCodeLine{04092         std::string \textcolor{keyword}{const}\& getReporterName() \textcolor{keyword}{const};}
\DoxyCodeLine{04093 }
\DoxyCodeLine{04094         std::vector<std::string> \textcolor{keyword}{const}\& getTestsOrTags() \textcolor{keyword}{const};}
\DoxyCodeLine{04095         std::vector<std::string> \textcolor{keyword}{const}\& getSectionsToRun() \textcolor{keyword}{const override};}
\DoxyCodeLine{04096 }
\DoxyCodeLine{04097         \textcolor{keyword}{virtual} TestSpec \textcolor{keyword}{const}\& testSpec() \textcolor{keyword}{const override};}
\DoxyCodeLine{04098         \textcolor{keywordtype}{bool} hasTestFilters() \textcolor{keyword}{const override};}
\DoxyCodeLine{04099 }
\DoxyCodeLine{04100         \textcolor{keywordtype}{bool} showHelp() \textcolor{keyword}{const};}
\DoxyCodeLine{04101 }
\DoxyCodeLine{04102         \textcolor{comment}{// IConfig interface}}
\DoxyCodeLine{04103         \textcolor{keywordtype}{bool} allowThrows() \textcolor{keyword}{const override};}
\DoxyCodeLine{04104         std::ostream\& stream() \textcolor{keyword}{const override};}
\DoxyCodeLine{04105         std::string name() \textcolor{keyword}{const override};}
\DoxyCodeLine{04106         \textcolor{keywordtype}{bool} includeSuccessfulResults() \textcolor{keyword}{const override};}
\DoxyCodeLine{04107         \textcolor{keywordtype}{bool} warnAboutMissingAssertions() \textcolor{keyword}{const override};}
\DoxyCodeLine{04108         \textcolor{keywordtype}{bool} warnAboutNoTests() \textcolor{keyword}{const override};}
\DoxyCodeLine{04109         ShowDurations::OrNot showDurations() \textcolor{keyword}{const override};}
\DoxyCodeLine{04110         RunTests::InWhatOrder runOrder() \textcolor{keyword}{const override};}
\DoxyCodeLine{04111         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \textcolor{keyword}{const override};}
\DoxyCodeLine{04112         \textcolor{keywordtype}{int} benchmarkResolutionMultiple() \textcolor{keyword}{const override};}
\DoxyCodeLine{04113         UseColour::YesOrNo useColour() \textcolor{keyword}{const override};}
\DoxyCodeLine{04114         \textcolor{keywordtype}{bool} shouldDebugBreak() \textcolor{keyword}{const override};}
\DoxyCodeLine{04115         \textcolor{keywordtype}{int} abortAfter() \textcolor{keyword}{const override};}
\DoxyCodeLine{04116         \textcolor{keywordtype}{bool} showInvisibles() \textcolor{keyword}{const override};}
\DoxyCodeLine{04117         Verbosity verbosity() \textcolor{keyword}{const override};}
\DoxyCodeLine{04118 }
\DoxyCodeLine{04119     \textcolor{keyword}{private}:}
\DoxyCodeLine{04120 }
\DoxyCodeLine{04121         IStream \textcolor{keyword}{const}* openStream();}
\DoxyCodeLine{04122         ConfigData m\_data;}
\DoxyCodeLine{04123 }
\DoxyCodeLine{04124         std::unique\_ptr<IStream const> m\_stream;}
\DoxyCodeLine{04125         TestSpec m\_testSpec;}
\DoxyCodeLine{04126         \textcolor{keywordtype}{bool} m\_hasTestFilters = \textcolor{keyword}{false};}
\DoxyCodeLine{04127     \};}
\DoxyCodeLine{04128 }
\DoxyCodeLine{04129 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{04130 }
\DoxyCodeLine{04131 \textcolor{comment}{// end catch\_config.hpp}}
\DoxyCodeLine{04132 \textcolor{comment}{// start catch\_assertionresult.h}}
\DoxyCodeLine{04133 }
\DoxyCodeLine{04134 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{04135 }
\DoxyCodeLine{04136 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{04137 }
\DoxyCodeLine{04138     \textcolor{keyword}{struct }AssertionResultData}
\DoxyCodeLine{04139     \{}
\DoxyCodeLine{04140         AssertionResultData() = \textcolor{keyword}{delete};}
\DoxyCodeLine{04141 }
\DoxyCodeLine{04142         AssertionResultData( ResultWas::OfType \_resultType, LazyExpression \textcolor{keyword}{const}\& \_lazyExpression );}
\DoxyCodeLine{04143 }
\DoxyCodeLine{04144         std::string message;}
\DoxyCodeLine{04145         \textcolor{keyword}{mutable} std::string reconstructedExpression;}
\DoxyCodeLine{04146         LazyExpression lazyExpression;}
\DoxyCodeLine{04147         ResultWas::OfType resultType;}
\DoxyCodeLine{04148 }
\DoxyCodeLine{04149         std::string reconstructExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{04150     \};}
\DoxyCodeLine{04151 }
\DoxyCodeLine{04152     \textcolor{keyword}{class }AssertionResult \{}
\DoxyCodeLine{04153     \textcolor{keyword}{public}:}
\DoxyCodeLine{04154         AssertionResult() = \textcolor{keyword}{delete};}
\DoxyCodeLine{04155         AssertionResult( AssertionInfo \textcolor{keyword}{const}\& info, AssertionResultData \textcolor{keyword}{const}\& data );}
\DoxyCodeLine{04156 }
\DoxyCodeLine{04157         \textcolor{keywordtype}{bool} isOk() \textcolor{keyword}{const};}
\DoxyCodeLine{04158         \textcolor{keywordtype}{bool} succeeded() \textcolor{keyword}{const};}
\DoxyCodeLine{04159         ResultWas::OfType getResultType() \textcolor{keyword}{const};}
\DoxyCodeLine{04160         \textcolor{keywordtype}{bool} hasExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{04161         \textcolor{keywordtype}{bool} hasMessage() \textcolor{keyword}{const};}
\DoxyCodeLine{04162         std::string getExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{04163         std::string getExpressionInMacro() \textcolor{keyword}{const};}
\DoxyCodeLine{04164         \textcolor{keywordtype}{bool} hasExpandedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{04165         std::string getExpandedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{04166         std::string getMessage() \textcolor{keyword}{const};}
\DoxyCodeLine{04167         SourceLineInfo getSourceInfo() \textcolor{keyword}{const};}
\DoxyCodeLine{04168         StringRef getTestMacroName() \textcolor{keyword}{const};}
\DoxyCodeLine{04169 }
\DoxyCodeLine{04170     \textcolor{comment}{//protected:}}
\DoxyCodeLine{04171         AssertionInfo m\_info;}
\DoxyCodeLine{04172         AssertionResultData m\_resultData;}
\DoxyCodeLine{04173     \};}
\DoxyCodeLine{04174 }
\DoxyCodeLine{04175 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{04176 }
\DoxyCodeLine{04177 \textcolor{comment}{// end catch\_assertionresult.h}}
\DoxyCodeLine{04178 \textcolor{comment}{// start catch\_option.hpp}}
\DoxyCodeLine{04179 }
\DoxyCodeLine{04180 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{04181 }
\DoxyCodeLine{04182     \textcolor{comment}{// An optional type}}
\DoxyCodeLine{04183     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{04184     \textcolor{keyword}{class }Option \{}
\DoxyCodeLine{04185     \textcolor{keyword}{public}:}
\DoxyCodeLine{04186         Option() : nullableValue( nullptr ) \{\}}
\DoxyCodeLine{04187         Option( T \textcolor{keyword}{const}\& \_value )}
\DoxyCodeLine{04188         : nullableValue( new( storage ) T( \_value ) )}
\DoxyCodeLine{04189         \{\}}
\DoxyCodeLine{04190         Option( Option \textcolor{keyword}{const}\& \_other )}
\DoxyCodeLine{04191         : nullableValue( \_other ? new( storage ) T( *\_other ) : nullptr )}
\DoxyCodeLine{04192         \{\}}
\DoxyCodeLine{04193 }
\DoxyCodeLine{04194         ~Option() \{}
\DoxyCodeLine{04195             reset();}
\DoxyCodeLine{04196         \}}
\DoxyCodeLine{04197 }
\DoxyCodeLine{04198         Option\& operator= ( Option \textcolor{keyword}{const}\& \_other ) \{}
\DoxyCodeLine{04199             \textcolor{keywordflow}{if}( \&\_other != \textcolor{keyword}{this} ) \{}
\DoxyCodeLine{04200                 reset();}
\DoxyCodeLine{04201                 \textcolor{keywordflow}{if}( \_other )}
\DoxyCodeLine{04202                     nullableValue = \textcolor{keyword}{new}( storage ) T( *\_other );}
\DoxyCodeLine{04203             \}}
\DoxyCodeLine{04204             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{04205         \}}
\DoxyCodeLine{04206         Option\& operator = ( T \textcolor{keyword}{const}\& \_value ) \{}
\DoxyCodeLine{04207             reset();}
\DoxyCodeLine{04208             nullableValue = \textcolor{keyword}{new}( storage ) T( \_value );}
\DoxyCodeLine{04209             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{04210         \}}
\DoxyCodeLine{04211 }
\DoxyCodeLine{04212         \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{04213             \textcolor{keywordflow}{if}( nullableValue )}
\DoxyCodeLine{04214                 nullableValue->~T();}
\DoxyCodeLine{04215             nullableValue = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{04216         \}}
\DoxyCodeLine{04217 }
\DoxyCodeLine{04218         T\& operator*() \{ \textcolor{keywordflow}{return} *nullableValue; \}}
\DoxyCodeLine{04219         T \textcolor{keyword}{const}\& operator*()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *nullableValue; \}}
\DoxyCodeLine{04220         T* operator->() \{ \textcolor{keywordflow}{return} nullableValue; \}}
\DoxyCodeLine{04221         \textcolor{keyword}{const} T* operator->()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue; \}}
\DoxyCodeLine{04222 }
\DoxyCodeLine{04223         T valueOr( T \textcolor{keyword}{const}\& defaultValue )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{04224             \textcolor{keywordflow}{return} nullableValue ? *nullableValue : defaultValue;}
\DoxyCodeLine{04225         \}}
\DoxyCodeLine{04226 }
\DoxyCodeLine{04227         \textcolor{keywordtype}{bool} some()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{04228         \textcolor{keywordtype}{bool} none()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue == \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{04229 }
\DoxyCodeLine{04230         \textcolor{keywordtype}{bool} operator !()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue == \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{04231         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{04232             \textcolor{keywordflow}{return} some();}
\DoxyCodeLine{04233         \}}
\DoxyCodeLine{04234 }
\DoxyCodeLine{04235     \textcolor{keyword}{private}:}
\DoxyCodeLine{04236         T *nullableValue;}
\DoxyCodeLine{04237         \textcolor{keyword}{alignas}(\textcolor{keyword}{alignof}(T)) \textcolor{keywordtype}{char} storage[sizeof(T)];}
\DoxyCodeLine{04238     \};}
\DoxyCodeLine{04239 }
\DoxyCodeLine{04240 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{04241 }
\DoxyCodeLine{04242 \textcolor{comment}{// end catch\_option.hpp}}
\DoxyCodeLine{04243 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{04244 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{04245 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{04246 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{04247 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{04248 }
\DoxyCodeLine{04249 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{04250 }
\DoxyCodeLine{04251     \textcolor{keyword}{struct }ReporterConfig \{}
\DoxyCodeLine{04252         \textcolor{keyword}{explicit} ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig );}
\DoxyCodeLine{04253 }
\DoxyCodeLine{04254         ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig, std::ostream\& \_stream );}
\DoxyCodeLine{04255 }
\DoxyCodeLine{04256         std::ostream\& stream() \textcolor{keyword}{const};}
\DoxyCodeLine{04257         IConfigPtr fullConfig() \textcolor{keyword}{const};}
\DoxyCodeLine{04258 }
\DoxyCodeLine{04259     \textcolor{keyword}{private}:}
\DoxyCodeLine{04260         std::ostream* m\_stream;}
\DoxyCodeLine{04261         IConfigPtr m\_fullConfig;}
\DoxyCodeLine{04262     \};}
\DoxyCodeLine{04263 }
\DoxyCodeLine{04264     \textcolor{keyword}{struct }ReporterPreferences \{}
\DoxyCodeLine{04265         \textcolor{keywordtype}{bool} shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{04266         \textcolor{keywordtype}{bool} shouldReportAllAssertions = \textcolor{keyword}{false};}
\DoxyCodeLine{04267     \};}
\DoxyCodeLine{04268 }
\DoxyCodeLine{04269     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{04270     \textcolor{keyword}{struct }LazyStat : Option<T> \{}
\DoxyCodeLine{04271         LazyStat\& operator=( T \textcolor{keyword}{const}\& \_value ) \{}
\DoxyCodeLine{04272             Option<T>::operator=( \_value );}
\DoxyCodeLine{04273             used = \textcolor{keyword}{false};}
\DoxyCodeLine{04274             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{04275         \}}
\DoxyCodeLine{04276         \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{04277             Option<T>::reset();}
\DoxyCodeLine{04278             used = \textcolor{keyword}{false};}
\DoxyCodeLine{04279         \}}
\DoxyCodeLine{04280         \textcolor{keywordtype}{bool} used = \textcolor{keyword}{false};}
\DoxyCodeLine{04281     \};}
\DoxyCodeLine{04282 }
\DoxyCodeLine{04283     \textcolor{keyword}{struct }TestRunInfo \{}
\DoxyCodeLine{04284         TestRunInfo( std::string \textcolor{keyword}{const}\& \_name );}
\DoxyCodeLine{04285         std::string name;}
\DoxyCodeLine{04286     \};}
\DoxyCodeLine{04287     \textcolor{keyword}{struct }GroupInfo \{}
\DoxyCodeLine{04288         GroupInfo(  std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{04289                     std::size\_t \_groupIndex,}
\DoxyCodeLine{04290                     std::size\_t \_groupsCount );}
\DoxyCodeLine{04291 }
\DoxyCodeLine{04292         std::string name;}
\DoxyCodeLine{04293         std::size\_t groupIndex;}
\DoxyCodeLine{04294         std::size\_t groupsCounts;}
\DoxyCodeLine{04295     \};}
\DoxyCodeLine{04296 }
\DoxyCodeLine{04297     \textcolor{keyword}{struct }AssertionStats \{}
\DoxyCodeLine{04298         AssertionStats( AssertionResult \textcolor{keyword}{const}\& \_assertionResult,}
\DoxyCodeLine{04299                         std::vector<MessageInfo> \textcolor{keyword}{const}\& \_infoMessages,}
\DoxyCodeLine{04300                         Totals \textcolor{keyword}{const}\& \_totals );}
\DoxyCodeLine{04301 }
\DoxyCodeLine{04302         AssertionStats( AssertionStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04303         AssertionStats( AssertionStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04304         AssertionStats\& operator = ( AssertionStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04305         AssertionStats\& operator = ( AssertionStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04306         \textcolor{keyword}{virtual} ~AssertionStats();}
\DoxyCodeLine{04307 }
\DoxyCodeLine{04308         AssertionResult assertionResult;}
\DoxyCodeLine{04309         std::vector<MessageInfo> infoMessages;}
\DoxyCodeLine{04310         Totals totals;}
\DoxyCodeLine{04311     \};}
\DoxyCodeLine{04312 }
\DoxyCodeLine{04313     \textcolor{keyword}{struct }SectionStats \{}
\DoxyCodeLine{04314         SectionStats(   SectionInfo \textcolor{keyword}{const}\& \_sectionInfo,}
\DoxyCodeLine{04315                         Counts \textcolor{keyword}{const}\& \_assertions,}
\DoxyCodeLine{04316                         \textcolor{keywordtype}{double} \_durationInSeconds,}
\DoxyCodeLine{04317                         \textcolor{keywordtype}{bool} \_missingAssertions );}
\DoxyCodeLine{04318         SectionStats( SectionStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04319         SectionStats( SectionStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04320         SectionStats\& operator = ( SectionStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04321         SectionStats\& operator = ( SectionStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04322         \textcolor{keyword}{virtual} ~SectionStats();}
\DoxyCodeLine{04323 }
\DoxyCodeLine{04324         SectionInfo sectionInfo;}
\DoxyCodeLine{04325         Counts assertions;}
\DoxyCodeLine{04326         \textcolor{keywordtype}{double} durationInSeconds;}
\DoxyCodeLine{04327         \textcolor{keywordtype}{bool} missingAssertions;}
\DoxyCodeLine{04328     \};}
\DoxyCodeLine{04329 }
\DoxyCodeLine{04330     \textcolor{keyword}{struct }TestCaseStats \{}
\DoxyCodeLine{04331         TestCaseStats(  TestCaseInfo \textcolor{keyword}{const}\& \_testInfo,}
\DoxyCodeLine{04332                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{04333                         std::string \textcolor{keyword}{const}\& \_stdOut,}
\DoxyCodeLine{04334                         std::string \textcolor{keyword}{const}\& \_stdErr,}
\DoxyCodeLine{04335                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{04336 }
\DoxyCodeLine{04337         TestCaseStats( TestCaseStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04338         TestCaseStats( TestCaseStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04339         TestCaseStats\& operator = ( TestCaseStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04340         TestCaseStats\& operator = ( TestCaseStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04341         \textcolor{keyword}{virtual} ~TestCaseStats();}
\DoxyCodeLine{04342 }
\DoxyCodeLine{04343         TestCaseInfo testInfo;}
\DoxyCodeLine{04344         Totals totals;}
\DoxyCodeLine{04345         std::string stdOut;}
\DoxyCodeLine{04346         std::string stdErr;}
\DoxyCodeLine{04347         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{04348     \};}
\DoxyCodeLine{04349 }
\DoxyCodeLine{04350     \textcolor{keyword}{struct }TestGroupStats \{}
\DoxyCodeLine{04351         TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo,}
\DoxyCodeLine{04352                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{04353                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{04354         TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo );}
\DoxyCodeLine{04355 }
\DoxyCodeLine{04356         TestGroupStats( TestGroupStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04357         TestGroupStats( TestGroupStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04358         TestGroupStats\& operator = ( TestGroupStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04359         TestGroupStats\& operator = ( TestGroupStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04360         \textcolor{keyword}{virtual} ~TestGroupStats();}
\DoxyCodeLine{04361 }
\DoxyCodeLine{04362         GroupInfo groupInfo;}
\DoxyCodeLine{04363         Totals totals;}
\DoxyCodeLine{04364         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{04365     \};}
\DoxyCodeLine{04366 }
\DoxyCodeLine{04367     \textcolor{keyword}{struct }TestRunStats \{}
\DoxyCodeLine{04368         TestRunStats(   TestRunInfo \textcolor{keyword}{const}\& \_runInfo,}
\DoxyCodeLine{04369                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{04370                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{04371 }
\DoxyCodeLine{04372         TestRunStats( TestRunStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04373         TestRunStats( TestRunStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04374         TestRunStats\& operator = ( TestRunStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04375         TestRunStats\& operator = ( TestRunStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04376         \textcolor{keyword}{virtual} ~TestRunStats();}
\DoxyCodeLine{04377 }
\DoxyCodeLine{04378         TestRunInfo runInfo;}
\DoxyCodeLine{04379         Totals totals;}
\DoxyCodeLine{04380         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{04381     \};}
\DoxyCodeLine{04382 }
\DoxyCodeLine{04383     \textcolor{keyword}{struct }BenchmarkInfo \{}
\DoxyCodeLine{04384         std::string name;}
\DoxyCodeLine{04385     \};}
\DoxyCodeLine{04386     \textcolor{keyword}{struct }BenchmarkStats \{}
\DoxyCodeLine{04387         BenchmarkInfo info;}
\DoxyCodeLine{04388         std::size\_t iterations;}
\DoxyCodeLine{04389         uint64\_t elapsedTimeInNanoseconds;}
\DoxyCodeLine{04390     \};}
\DoxyCodeLine{04391 }
\DoxyCodeLine{04392     \textcolor{keyword}{struct }IStreamingReporter \{}
\DoxyCodeLine{04393         \textcolor{keyword}{virtual} ~IStreamingReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04394 }
\DoxyCodeLine{04395         \textcolor{comment}{// Implementing class must also provide the following static methods:}}
\DoxyCodeLine{04396         \textcolor{comment}{// static std::string getDescription();}}
\DoxyCodeLine{04397         \textcolor{comment}{// static std::set<Verbosity> getSupportedVerbosities()}}
\DoxyCodeLine{04398 }
\DoxyCodeLine{04399         \textcolor{keyword}{virtual} ReporterPreferences getPreferences() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04400 }
\DoxyCodeLine{04401         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) = 0;}
\DoxyCodeLine{04402 }
\DoxyCodeLine{04403         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) = 0;}
\DoxyCodeLine{04404         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) = 0;}
\DoxyCodeLine{04405 }
\DoxyCodeLine{04406         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{04407         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) = 0;}
\DoxyCodeLine{04408 }
\DoxyCodeLine{04409         \textcolor{comment}{// *** experimental ***}}
\DoxyCodeLine{04410         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{04411 }
\DoxyCodeLine{04412         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) = 0;}
\DoxyCodeLine{04413 }
\DoxyCodeLine{04414         \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{04415         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) = 0;}
\DoxyCodeLine{04416 }
\DoxyCodeLine{04417         \textcolor{comment}{// *** experimental ***}}
\DoxyCodeLine{04418         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{04419 }
\DoxyCodeLine{04420         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) = 0;}
\DoxyCodeLine{04421         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) = 0;}
\DoxyCodeLine{04422         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) = 0;}
\DoxyCodeLine{04423         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) = 0;}
\DoxyCodeLine{04424 }
\DoxyCodeLine{04425         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{04426 }
\DoxyCodeLine{04427         \textcolor{comment}{// Default empty implementation provided}}
\DoxyCodeLine{04428         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} fatalErrorEncountered( StringRef name );}
\DoxyCodeLine{04429 }
\DoxyCodeLine{04430         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isMulti() \textcolor{keyword}{const};}
\DoxyCodeLine{04431     \};}
\DoxyCodeLine{04432     \textcolor{keyword}{using} IStreamingReporterPtr = std::unique\_ptr<IStreamingReporter>;}
\DoxyCodeLine{04433 }
\DoxyCodeLine{04434     \textcolor{keyword}{struct }IReporterFactory \{}
\DoxyCodeLine{04435         \textcolor{keyword}{virtual} ~IReporterFactory();}
\DoxyCodeLine{04436         \textcolor{keyword}{virtual} IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04437         \textcolor{keyword}{virtual} std::string getDescription() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04438     \};}
\DoxyCodeLine{04439     \textcolor{keyword}{using} IReporterFactoryPtr = std::shared\_ptr<IReporterFactory>;}
\DoxyCodeLine{04440 }
\DoxyCodeLine{04441     \textcolor{keyword}{struct }IReporterRegistry \{}
\DoxyCodeLine{04442         \textcolor{keyword}{using} FactoryMap = std::map<std::string, IReporterFactoryPtr>;}
\DoxyCodeLine{04443         \textcolor{keyword}{using} Listeners = std::vector<IReporterFactoryPtr>;}
\DoxyCodeLine{04444 }
\DoxyCodeLine{04445         \textcolor{keyword}{virtual} ~IReporterRegistry();}
\DoxyCodeLine{04446         \textcolor{keyword}{virtual} IStreamingReporterPtr create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04447         \textcolor{keyword}{virtual} FactoryMap \textcolor{keyword}{const}\& getFactories() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04448         \textcolor{keyword}{virtual} Listeners \textcolor{keyword}{const}\& getListeners() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{04449     \};}
\DoxyCodeLine{04450 }
\DoxyCodeLine{04451 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{04452 }
\DoxyCodeLine{04453 \textcolor{comment}{// end catch\_interfaces\_reporter.h}}
\DoxyCodeLine{04454 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{04455 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{04456 \textcolor{preprocessor}{\#include <cfloat>}}
\DoxyCodeLine{04457 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{04458 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{04459 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{04460 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{04461 }
\DoxyCodeLine{04462 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{04463     \textcolor{keywordtype}{void} prepareExpandedExpression(AssertionResult\& result);}
\DoxyCodeLine{04464 }
\DoxyCodeLine{04465     \textcolor{comment}{// Returns double formatted as \%.3f (format expected on output)}}
\DoxyCodeLine{04466     std::string getFormattedDuration( \textcolor{keywordtype}{double} duration );}
\DoxyCodeLine{04467 }
\DoxyCodeLine{04468     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{04469     \textcolor{keyword}{struct }StreamingReporterBase : IStreamingReporter \{}
\DoxyCodeLine{04470 }
\DoxyCodeLine{04471         StreamingReporterBase( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{04472         :   m\_config( \_config.fullConfig() ),}
\DoxyCodeLine{04473             stream( \_config.stream() )}
\DoxyCodeLine{04474         \{}
\DoxyCodeLine{04475             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{04476             \textcolor{keywordflow}{if}( !DerivedT::getSupportedVerbosities().count( m\_config->verbosity() ) )}
\DoxyCodeLine{04477                 CATCH\_ERROR( \textcolor{stringliteral}{"Verbosity level not supported by this reporter"} );}
\DoxyCodeLine{04478         \}}
\DoxyCodeLine{04479 }
\DoxyCodeLine{04480         ReporterPreferences getPreferences()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{04481             \textcolor{keywordflow}{return} m\_reporterPrefs;}
\DoxyCodeLine{04482         \}}
\DoxyCodeLine{04483 }
\DoxyCodeLine{04484         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities() \{}
\DoxyCodeLine{04485             \textcolor{keywordflow}{return} \{ Verbosity::Normal \};}
\DoxyCodeLine{04486         \}}
\DoxyCodeLine{04487 }
\DoxyCodeLine{04488         ~StreamingReporterBase() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04489 }
\DoxyCodeLine{04490         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{04491 }
\DoxyCodeLine{04492         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& \_testRunInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04493             currentTestRunInfo = \_testRunInfo;}
\DoxyCodeLine{04494         \}}
\DoxyCodeLine{04495         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& \_groupInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04496             currentGroupInfo = \_groupInfo;}
\DoxyCodeLine{04497         \}}
\DoxyCodeLine{04498 }
\DoxyCodeLine{04499         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& \_testInfo)\textcolor{keyword}{ override  }\{}
\DoxyCodeLine{04500             currentTestCaseInfo = \_testInfo;}
\DoxyCodeLine{04501         \}}
\DoxyCodeLine{04502         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04503             m\_sectionStack.push\_back(\_sectionInfo);}
\DoxyCodeLine{04504         \}}
\DoxyCodeLine{04505 }
\DoxyCodeLine{04506         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_sectionStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04507             m\_sectionStack.pop\_back();}
\DoxyCodeLine{04508         \}}
\DoxyCodeLine{04509         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testCaseStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04510             currentTestCaseInfo.reset();}
\DoxyCodeLine{04511         \}}
\DoxyCodeLine{04512         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testGroupStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04513             currentGroupInfo.reset();}
\DoxyCodeLine{04514         \}}
\DoxyCodeLine{04515         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testRunStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04516             currentTestCaseInfo.reset();}
\DoxyCodeLine{04517             currentGroupInfo.reset();}
\DoxyCodeLine{04518             currentTestRunInfo.reset();}
\DoxyCodeLine{04519         \}}
\DoxyCodeLine{04520 }
\DoxyCodeLine{04521         \textcolor{keywordtype}{void} skipTest(TestCaseInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04522             \textcolor{comment}{// Don't do anything with this by default.}}
\DoxyCodeLine{04523             \textcolor{comment}{// It can optionally be overridden in the derived class.}}
\DoxyCodeLine{04524         \}}
\DoxyCodeLine{04525 }
\DoxyCodeLine{04526         IConfigPtr m\_config;}
\DoxyCodeLine{04527         std::ostream\& stream;}
\DoxyCodeLine{04528 }
\DoxyCodeLine{04529         LazyStat<TestRunInfo> currentTestRunInfo;}
\DoxyCodeLine{04530         LazyStat<GroupInfo> currentGroupInfo;}
\DoxyCodeLine{04531         LazyStat<TestCaseInfo> currentTestCaseInfo;}
\DoxyCodeLine{04532 }
\DoxyCodeLine{04533         std::vector<SectionInfo> m\_sectionStack;}
\DoxyCodeLine{04534         ReporterPreferences m\_reporterPrefs;}
\DoxyCodeLine{04535     \};}
\DoxyCodeLine{04536 }
\DoxyCodeLine{04537     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{04538     \textcolor{keyword}{struct }CumulativeReporterBase : IStreamingReporter \{}
\DoxyCodeLine{04539         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ChildNodeT>}
\DoxyCodeLine{04540         \textcolor{keyword}{struct }Node \{}
\DoxyCodeLine{04541             \textcolor{keyword}{explicit} Node( T \textcolor{keyword}{const}\& \_value ) : value( \_value ) \{\}}
\DoxyCodeLine{04542             \textcolor{keyword}{virtual} ~Node() \{\}}
\DoxyCodeLine{04543 }
\DoxyCodeLine{04544             \textcolor{keyword}{using} ChildNodes = std::vector<std::shared\_ptr<ChildNodeT>>;}
\DoxyCodeLine{04545             T value;}
\DoxyCodeLine{04546             ChildNodes children;}
\DoxyCodeLine{04547         \};}
\DoxyCodeLine{04548         \textcolor{keyword}{struct }SectionNode \{}
\DoxyCodeLine{04549             \textcolor{keyword}{explicit} SectionNode(SectionStats \textcolor{keyword}{const}\& \_stats) : stats(\_stats) \{\}}
\DoxyCodeLine{04550             \textcolor{keyword}{virtual} ~SectionNode() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04551 }
\DoxyCodeLine{04552             \textcolor{keywordtype}{bool} operator == (SectionNode \textcolor{keyword}{const}\& other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{04553                 \textcolor{keywordflow}{return} stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;}
\DoxyCodeLine{04554             \}}
\DoxyCodeLine{04555             \textcolor{keywordtype}{bool} operator == (std::shared\_ptr<SectionNode> \textcolor{keyword}{const}\& other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{04556                 \textcolor{keywordflow}{return} operator==(*other);}
\DoxyCodeLine{04557             \}}
\DoxyCodeLine{04558 }
\DoxyCodeLine{04559             SectionStats stats;}
\DoxyCodeLine{04560             \textcolor{keyword}{using} ChildSections = std::vector<std::shared\_ptr<SectionNode>>;}
\DoxyCodeLine{04561             \textcolor{keyword}{using} Assertions = std::vector<AssertionStats>;}
\DoxyCodeLine{04562             ChildSections childSections;}
\DoxyCodeLine{04563             Assertions assertions;}
\DoxyCodeLine{04564             std::string stdOut;}
\DoxyCodeLine{04565             std::string stdErr;}
\DoxyCodeLine{04566         \};}
\DoxyCodeLine{04567 }
\DoxyCodeLine{04568         \textcolor{keyword}{struct }BySectionInfo \{}
\DoxyCodeLine{04569             BySectionInfo( SectionInfo \textcolor{keyword}{const}\& other ) : m\_other( other ) \{\}}
\DoxyCodeLine{04570             BySectionInfo( BySectionInfo \textcolor{keyword}{const}\& other ) : m\_other( other.m\_other ) \{\}}
\DoxyCodeLine{04571             \textcolor{keywordtype}{bool} operator() (std::shared\_ptr<SectionNode> \textcolor{keyword}{const}\& node)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{04572                 \textcolor{keywordflow}{return} ((node->stats.sectionInfo.name == m\_other.name) \&\&}
\DoxyCodeLine{04573                         (node->stats.sectionInfo.lineInfo == m\_other.lineInfo));}
\DoxyCodeLine{04574             \}}
\DoxyCodeLine{04575             \textcolor{keywordtype}{void} operator=(BySectionInfo \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{04576 }
\DoxyCodeLine{04577         \textcolor{keyword}{private}:}
\DoxyCodeLine{04578             SectionInfo \textcolor{keyword}{const}\& m\_other;}
\DoxyCodeLine{04579         \};}
\DoxyCodeLine{04580 }
\DoxyCodeLine{04581         \textcolor{keyword}{using} TestCaseNode = Node<TestCaseStats, SectionNode>;}
\DoxyCodeLine{04582         \textcolor{keyword}{using} TestGroupNode = Node<TestGroupStats, TestCaseNode>;}
\DoxyCodeLine{04583         \textcolor{keyword}{using} TestRunNode = Node<TestRunStats, TestGroupNode>;}
\DoxyCodeLine{04584 }
\DoxyCodeLine{04585         CumulativeReporterBase( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{04586         :   m\_config( \_config.fullConfig() ),}
\DoxyCodeLine{04587             stream( \_config.stream() )}
\DoxyCodeLine{04588         \{}
\DoxyCodeLine{04589             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{04590             \textcolor{keywordflow}{if}( !DerivedT::getSupportedVerbosities().count( m\_config->verbosity() ) )}
\DoxyCodeLine{04591                 CATCH\_ERROR( \textcolor{stringliteral}{"Verbosity level not supported by this reporter"} );}
\DoxyCodeLine{04592         \}}
\DoxyCodeLine{04593         ~CumulativeReporterBase() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{04594 }
\DoxyCodeLine{04595         ReporterPreferences getPreferences()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{04596             \textcolor{keywordflow}{return} m\_reporterPrefs;}
\DoxyCodeLine{04597         \}}
\DoxyCodeLine{04598 }
\DoxyCodeLine{04599         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities() \{}
\DoxyCodeLine{04600             \textcolor{keywordflow}{return} \{ Verbosity::Normal \};}
\DoxyCodeLine{04601         \}}
\DoxyCodeLine{04602 }
\DoxyCodeLine{04603         \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{04604         \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{04605 }
\DoxyCodeLine{04606         \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{04607 }
\DoxyCodeLine{04608         \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04609             SectionStats incompleteStats( sectionInfo, Counts(), 0, \textcolor{keyword}{false} );}
\DoxyCodeLine{04610             std::shared\_ptr<SectionNode> node;}
\DoxyCodeLine{04611             \textcolor{keywordflow}{if}( m\_sectionStack.empty() ) \{}
\DoxyCodeLine{04612                 \textcolor{keywordflow}{if}( !m\_rootSection )}
\DoxyCodeLine{04613                     m\_rootSection = std::make\_shared<SectionNode>( incompleteStats );}
\DoxyCodeLine{04614                 node = m\_rootSection;}
\DoxyCodeLine{04615             \}}
\DoxyCodeLine{04616             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{04617                 SectionNode\& parentNode = *m\_sectionStack.back();}
\DoxyCodeLine{04618                 \textcolor{keyword}{auto} it =}
\DoxyCodeLine{04619                     std::find\_if(   parentNode.childSections.begin(),}
\DoxyCodeLine{04620                                     parentNode.childSections.end(),}
\DoxyCodeLine{04621                                     BySectionInfo( sectionInfo ) );}
\DoxyCodeLine{04622                 \textcolor{keywordflow}{if}( it == parentNode.childSections.end() ) \{}
\DoxyCodeLine{04623                     node = std::make\_shared<SectionNode>( incompleteStats );}
\DoxyCodeLine{04624                     parentNode.childSections.push\_back( node );}
\DoxyCodeLine{04625                 \}}
\DoxyCodeLine{04626                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{04627                     node = *it;}
\DoxyCodeLine{04628             \}}
\DoxyCodeLine{04629             m\_sectionStack.push\_back( node );}
\DoxyCodeLine{04630             m\_deepestSection = std::move(node);}
\DoxyCodeLine{04631         \}}
\DoxyCodeLine{04632 }
\DoxyCodeLine{04633         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{04634 }
\DoxyCodeLine{04635         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04636             assert(!m\_sectionStack.empty());}
\DoxyCodeLine{04637             \textcolor{comment}{// AssertionResult holds a pointer to a temporary DecomposedExpression,}}
\DoxyCodeLine{04638             \textcolor{comment}{// which getExpandedExpression() calls to build the expression string.}}
\DoxyCodeLine{04639             \textcolor{comment}{// Our section stack copy of the assertionResult will likely outlive the}}
\DoxyCodeLine{04640             \textcolor{comment}{// temporary, so it must be expanded or discarded now to avoid calling}}
\DoxyCodeLine{04641             \textcolor{comment}{// a destroyed object later.}}
\DoxyCodeLine{04642             prepareExpandedExpression(const\_cast<AssertionResult\&>( assertionStats.assertionResult ) );}
\DoxyCodeLine{04643             SectionNode\& sectionNode = *m\_sectionStack.back();}
\DoxyCodeLine{04644             sectionNode.assertions.push\_back(assertionStats);}
\DoxyCodeLine{04645             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{04646         \}}
\DoxyCodeLine{04647         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& sectionStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04648             assert(!m\_sectionStack.empty());}
\DoxyCodeLine{04649             SectionNode\& node = *m\_sectionStack.back();}
\DoxyCodeLine{04650             node.stats = sectionStats;}
\DoxyCodeLine{04651             m\_sectionStack.pop\_back();}
\DoxyCodeLine{04652         \}}
\DoxyCodeLine{04653         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04654             \textcolor{keyword}{auto} node = std::make\_shared<TestCaseNode>(testCaseStats);}
\DoxyCodeLine{04655             assert(m\_sectionStack.size() == 0);}
\DoxyCodeLine{04656             node->children.push\_back(m\_rootSection);}
\DoxyCodeLine{04657             m\_testCases.push\_back(node);}
\DoxyCodeLine{04658             m\_rootSection.reset();}
\DoxyCodeLine{04659 }
\DoxyCodeLine{04660             assert(m\_deepestSection);}
\DoxyCodeLine{04661             m\_deepestSection->stdOut = testCaseStats.stdOut;}
\DoxyCodeLine{04662             m\_deepestSection->stdErr = testCaseStats.stdErr;}
\DoxyCodeLine{04663         \}}
\DoxyCodeLine{04664         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04665             \textcolor{keyword}{auto} node = std::make\_shared<TestGroupNode>(testGroupStats);}
\DoxyCodeLine{04666             node->children.swap(m\_testCases);}
\DoxyCodeLine{04667             m\_testGroups.push\_back(node);}
\DoxyCodeLine{04668         \}}
\DoxyCodeLine{04669         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& testRunStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{04670             \textcolor{keyword}{auto} node = std::make\_shared<TestRunNode>(testRunStats);}
\DoxyCodeLine{04671             node->children.swap(m\_testGroups);}
\DoxyCodeLine{04672             m\_testRuns.push\_back(node);}
\DoxyCodeLine{04673             testRunEndedCumulative();}
\DoxyCodeLine{04674         \}}
\DoxyCodeLine{04675         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEndedCumulative() = 0;}
\DoxyCodeLine{04676 }
\DoxyCodeLine{04677         \textcolor{keywordtype}{void} skipTest(TestCaseInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{04678 }
\DoxyCodeLine{04679         IConfigPtr m\_config;}
\DoxyCodeLine{04680         std::ostream\& stream;}
\DoxyCodeLine{04681         std::vector<AssertionStats> m\_assertions;}
\DoxyCodeLine{04682         std::vector<std::vector<std::shared\_ptr<SectionNode>>> m\_sections;}
\DoxyCodeLine{04683         std::vector<std::shared\_ptr<TestCaseNode>> m\_testCases;}
\DoxyCodeLine{04684         std::vector<std::shared\_ptr<TestGroupNode>> m\_testGroups;}
\DoxyCodeLine{04685 }
\DoxyCodeLine{04686         std::vector<std::shared\_ptr<TestRunNode>> m\_testRuns;}
\DoxyCodeLine{04687 }
\DoxyCodeLine{04688         std::shared\_ptr<SectionNode> m\_rootSection;}
\DoxyCodeLine{04689         std::shared\_ptr<SectionNode> m\_deepestSection;}
\DoxyCodeLine{04690         std::vector<std::shared\_ptr<SectionNode>> m\_sectionStack;}
\DoxyCodeLine{04691         ReporterPreferences m\_reporterPrefs;}
\DoxyCodeLine{04692     \};}
\DoxyCodeLine{04693 }
\DoxyCodeLine{04694     \textcolor{keyword}{template}<\textcolor{keywordtype}{char} C>}
\DoxyCodeLine{04695     \textcolor{keywordtype}{char} \textcolor{keyword}{const}* getLineOfChars() \{}
\DoxyCodeLine{04696         \textcolor{keyword}{static} \textcolor{keywordtype}{char} line[CATCH\_CONFIG\_CONSOLE\_WIDTH] = \{0\};}
\DoxyCodeLine{04697         \textcolor{keywordflow}{if}( !*line ) \{}
\DoxyCodeLine{04698             std::memset( line, C, CATCH\_CONFIG\_CONSOLE\_WIDTH-1 );}
\DoxyCodeLine{04699             line[CATCH\_CONFIG\_CONSOLE\_WIDTH-1] = 0;}
\DoxyCodeLine{04700         \}}
\DoxyCodeLine{04701         \textcolor{keywordflow}{return} line;}
\DoxyCodeLine{04702     \}}
\DoxyCodeLine{04703 }
\DoxyCodeLine{04704     \textcolor{keyword}{struct }TestEventListenerBase : StreamingReporterBase<TestEventListenerBase> \{}
\DoxyCodeLine{04705         TestEventListenerBase( ReporterConfig \textcolor{keyword}{const}\& \_config );}
\DoxyCodeLine{04706 }
\DoxyCodeLine{04707         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities();}
\DoxyCodeLine{04708 }
\DoxyCodeLine{04709         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{04710         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{04711     \};}
\DoxyCodeLine{04712 }
\DoxyCodeLine{04713 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{04714 }
\DoxyCodeLine{04715 \textcolor{comment}{// end catch\_reporter\_bases.hpp}}
\DoxyCodeLine{04716 \textcolor{comment}{// start catch\_console\_colour.h}}
\DoxyCodeLine{04717 }
\DoxyCodeLine{04718 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{04719 }
\DoxyCodeLine{04720     \textcolor{keyword}{struct }Colour \{}
\DoxyCodeLine{04721         \textcolor{keyword}{enum} Code \{}
\DoxyCodeLine{04722             None = 0,}
\DoxyCodeLine{04723 }
\DoxyCodeLine{04724             White,}
\DoxyCodeLine{04725             Red,}
\DoxyCodeLine{04726             Green,}
\DoxyCodeLine{04727             Blue,}
\DoxyCodeLine{04728             Cyan,}
\DoxyCodeLine{04729             Yellow,}
\DoxyCodeLine{04730             Grey,}
\DoxyCodeLine{04731 }
\DoxyCodeLine{04732             Bright = 0x10,}
\DoxyCodeLine{04733 }
\DoxyCodeLine{04734             BrightRed = Bright | Red,}
\DoxyCodeLine{04735             BrightGreen = Bright | Green,}
\DoxyCodeLine{04736             LightGrey = Bright | Grey,}
\DoxyCodeLine{04737             BrightWhite = Bright | White,}
\DoxyCodeLine{04738             BrightYellow = Bright | Yellow,}
\DoxyCodeLine{04739 }
\DoxyCodeLine{04740             \textcolor{comment}{// By intention}}
\DoxyCodeLine{04741             FileName = LightGrey,}
\DoxyCodeLine{04742             Warning = BrightYellow,}
\DoxyCodeLine{04743             ResultError = BrightRed,}
\DoxyCodeLine{04744             ResultSuccess = BrightGreen,}
\DoxyCodeLine{04745             ResultExpectedFailure = Warning,}
\DoxyCodeLine{04746 }
\DoxyCodeLine{04747             Error = BrightRed,}
\DoxyCodeLine{04748             Success = Green,}
\DoxyCodeLine{04749 }
\DoxyCodeLine{04750             OriginalExpression = Cyan,}
\DoxyCodeLine{04751             ReconstructedExpression = BrightYellow,}
\DoxyCodeLine{04752 }
\DoxyCodeLine{04753             SecondaryText = LightGrey,}
\DoxyCodeLine{04754             Headers = White}
\DoxyCodeLine{04755         \};}
\DoxyCodeLine{04756 }
\DoxyCodeLine{04757         \textcolor{comment}{// Use constructed object for RAII guard}}
\DoxyCodeLine{04758         Colour( Code \_colourCode );}
\DoxyCodeLine{04759         Colour( Colour\&\& other ) noexcept;}
\DoxyCodeLine{04760         Colour\& operator=( Colour\&\& other ) noexcept;}
\DoxyCodeLine{04761         ~Colour();}
\DoxyCodeLine{04762 }
\DoxyCodeLine{04763         \textcolor{comment}{// Use static method for one-shot changes}}
\DoxyCodeLine{04764         \textcolor{keyword}{static} \textcolor{keywordtype}{void} use( Code \_colourCode );}
\DoxyCodeLine{04765 }
\DoxyCodeLine{04766     \textcolor{keyword}{private}:}
\DoxyCodeLine{04767         \textcolor{keywordtype}{bool} m\_moved = \textcolor{keyword}{false};}
\DoxyCodeLine{04768     \};}
\DoxyCodeLine{04769 }
\DoxyCodeLine{04770     std::ostream\& operator << ( std::ostream\& os, Colour \textcolor{keyword}{const}\& );}
\DoxyCodeLine{04771 }
\DoxyCodeLine{04772 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{04773 }
\DoxyCodeLine{04774 \textcolor{comment}{// end catch\_console\_colour.h}}
\DoxyCodeLine{04775 \textcolor{comment}{// start catch\_reporter\_registrars.hpp}}
\DoxyCodeLine{04776 }
\DoxyCodeLine{04777 }
\DoxyCodeLine{04778 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{04779 }
\DoxyCodeLine{04780     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{04781     \textcolor{keyword}{class }ReporterRegistrar \{}
\DoxyCodeLine{04782 }
\DoxyCodeLine{04783         \textcolor{keyword}{class }ReporterFactory : \textcolor{keyword}{public} IReporterFactory \{}
\DoxyCodeLine{04784 }
\DoxyCodeLine{04785             \textcolor{keyword}{virtual} IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{04786                 \textcolor{keywordflow}{return} std::unique\_ptr<T>( \textcolor{keyword}{new} T( config ) );}
\DoxyCodeLine{04787             \}}
\DoxyCodeLine{04788 }
\DoxyCodeLine{04789             \textcolor{keyword}{virtual} std::string getDescription()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{04790                 \textcolor{keywordflow}{return} T::getDescription();}
\DoxyCodeLine{04791             \}}
\DoxyCodeLine{04792         \};}
\DoxyCodeLine{04793 }
\DoxyCodeLine{04794     \textcolor{keyword}{public}:}
\DoxyCodeLine{04795 }
\DoxyCodeLine{04796         \textcolor{keyword}{explicit} ReporterRegistrar( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{04797             getMutableRegistryHub().registerReporter( name, std::make\_shared<ReporterFactory>() );}
\DoxyCodeLine{04798         \}}
\DoxyCodeLine{04799     \};}
\DoxyCodeLine{04800 }
\DoxyCodeLine{04801     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{04802     \textcolor{keyword}{class }ListenerRegistrar \{}
\DoxyCodeLine{04803 }
\DoxyCodeLine{04804         \textcolor{keyword}{class }ListenerFactory : \textcolor{keyword}{public} IReporterFactory \{}
\DoxyCodeLine{04805 }
\DoxyCodeLine{04806             \textcolor{keyword}{virtual} IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{04807                 \textcolor{keywordflow}{return} std::unique\_ptr<T>( \textcolor{keyword}{new} T( config ) );}
\DoxyCodeLine{04808             \}}
\DoxyCodeLine{04809             \textcolor{keyword}{virtual} std::string getDescription()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{04810                 \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{04811             \}}
\DoxyCodeLine{04812         \};}
\DoxyCodeLine{04813 }
\DoxyCodeLine{04814     \textcolor{keyword}{public}:}
\DoxyCodeLine{04815 }
\DoxyCodeLine{04816         ListenerRegistrar() \{}
\DoxyCodeLine{04817             getMutableRegistryHub().registerListener( std::make\_shared<ListenerFactory>() );}
\DoxyCodeLine{04818         \}}
\DoxyCodeLine{04819     \};}
\DoxyCodeLine{04820 \}}
\DoxyCodeLine{04821 }
\DoxyCodeLine{04822 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{04823 }
\DoxyCodeLine{04824 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_REPORTER( name, reporterType ) \(\backslash\)}}
\DoxyCodeLine{04825 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS          \(\backslash\)}}
\DoxyCodeLine{04826 \textcolor{preprocessor}{    namespace\{ Catch::ReporterRegistrar<reporterType> catch\_internal\_RegistrarFor\#\#reporterType( name ); \} \(\backslash\)}}
\DoxyCodeLine{04827 \textcolor{preprocessor}{    CATCH\_INTERNAL\_UNSUPPRESS\_GLOBALS\_WARNINGS}}
\DoxyCodeLine{04828 }
\DoxyCodeLine{04829 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_LISTENER( listenerType ) \(\backslash\)}}
\DoxyCodeLine{04830 \textcolor{preprocessor}{     CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS   \(\backslash\)}}
\DoxyCodeLine{04831 \textcolor{preprocessor}{     namespace\{ Catch::ListenerRegistrar<listenerType> catch\_internal\_RegistrarFor\#\#listenerType; \} \(\backslash\)}}
\DoxyCodeLine{04832 \textcolor{preprocessor}{     CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS}}
\DoxyCodeLine{04833 \textcolor{preprocessor}{\#else // CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{04834 }
\DoxyCodeLine{04835 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_REPORTER(name, reporterType)}}
\DoxyCodeLine{04836 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_LISTENER(listenerType)}}
\DoxyCodeLine{04837 }
\DoxyCodeLine{04838 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{04839 }
\DoxyCodeLine{04840 \textcolor{comment}{// end catch\_reporter\_registrars.hpp}}
\DoxyCodeLine{04841 \textcolor{comment}{// Allow users to base their work off existing reporters}}
\DoxyCodeLine{04842 \textcolor{comment}{// start catch\_reporter\_compact.h}}
\DoxyCodeLine{04843 }
\DoxyCodeLine{04844 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{04845 }
\DoxyCodeLine{04846     \textcolor{keyword}{struct }CompactReporter : StreamingReporterBase<CompactReporter> \{}
\DoxyCodeLine{04847 }
\DoxyCodeLine{04848         \textcolor{keyword}{using} StreamingReporterBase::StreamingReporterBase;}
\DoxyCodeLine{04849 }
\DoxyCodeLine{04850         ~CompactReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{04851 }
\DoxyCodeLine{04852         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{04853 }
\DoxyCodeLine{04854         ReporterPreferences getPreferences() \textcolor{keyword}{const override};}
\DoxyCodeLine{04855 }
\DoxyCodeLine{04856         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \textcolor{keyword}{override};}
\DoxyCodeLine{04857 }
\DoxyCodeLine{04858         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{04859 }
\DoxyCodeLine{04860         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{04861 }
\DoxyCodeLine{04862         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{04863 }
\DoxyCodeLine{04864         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{04865 }
\DoxyCodeLine{04866     \};}
\DoxyCodeLine{04867 }
\DoxyCodeLine{04868 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{04869 }
\DoxyCodeLine{04870 \textcolor{comment}{// end catch\_reporter\_compact.h}}
\DoxyCodeLine{04871 \textcolor{comment}{// start catch\_reporter\_console.h}}
\DoxyCodeLine{04872 }
\DoxyCodeLine{04873 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{04874 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{04875 \textcolor{preprocessor}{\#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{04876                               \textcolor{comment}{// Note that 4062 (not all labels are handled}}
\DoxyCodeLine{04877                               \textcolor{comment}{// and default is missing) is enabled}}
\DoxyCodeLine{04878 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{04879 }
\DoxyCodeLine{04880 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{04881     \textcolor{comment}{// Fwd decls}}
\DoxyCodeLine{04882     \textcolor{keyword}{struct }SummaryColumn;}
\DoxyCodeLine{04883     \textcolor{keyword}{class }TablePrinter;}
\DoxyCodeLine{04884 }
\DoxyCodeLine{04885     \textcolor{keyword}{struct }ConsoleReporter : StreamingReporterBase<ConsoleReporter> \{}
\DoxyCodeLine{04886         std::unique\_ptr<TablePrinter> m\_tablePrinter;}
\DoxyCodeLine{04887 }
\DoxyCodeLine{04888         ConsoleReporter(ReporterConfig \textcolor{keyword}{const}\& config);}
\DoxyCodeLine{04889         ~ConsoleReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{04890         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{04891 }
\DoxyCodeLine{04892         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \textcolor{keyword}{override};}
\DoxyCodeLine{04893 }
\DoxyCodeLine{04894         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{04895 }
\DoxyCodeLine{04896         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{04897 }
\DoxyCodeLine{04898         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{04899         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{04900 }
\DoxyCodeLine{04901         \textcolor{keywordtype}{void} benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const}\& info) \textcolor{keyword}{override};}
\DoxyCodeLine{04902         \textcolor{keywordtype}{void} benchmarkEnded(BenchmarkStats \textcolor{keyword}{const}\& stats) \textcolor{keyword}{override};}
\DoxyCodeLine{04903 }
\DoxyCodeLine{04904         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \_testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{04905         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \_testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{04906         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{04907 }
\DoxyCodeLine{04908     \textcolor{keyword}{private}:}
\DoxyCodeLine{04909 }
\DoxyCodeLine{04910         \textcolor{keywordtype}{void} lazyPrint();}
\DoxyCodeLine{04911 }
\DoxyCodeLine{04912         \textcolor{keywordtype}{void} lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{04913         \textcolor{keywordtype}{void} lazyPrintRunInfo();}
\DoxyCodeLine{04914         \textcolor{keywordtype}{void} lazyPrintGroupInfo();}
\DoxyCodeLine{04915         \textcolor{keywordtype}{void} printTestCaseAndSectionHeader();}
\DoxyCodeLine{04916 }
\DoxyCodeLine{04917         \textcolor{keywordtype}{void} printClosedHeader(std::string \textcolor{keyword}{const}\& \_name);}
\DoxyCodeLine{04918         \textcolor{keywordtype}{void} printOpenHeader(std::string \textcolor{keyword}{const}\& \_name);}
\DoxyCodeLine{04919 }
\DoxyCodeLine{04920         \textcolor{comment}{// if string has a : in first line will set indent to follow it on}}
\DoxyCodeLine{04921         \textcolor{comment}{// subsequent lines}}
\DoxyCodeLine{04922         \textcolor{keywordtype}{void} printHeaderString(std::string \textcolor{keyword}{const}\& \_string, std::size\_t indent = 0);}
\DoxyCodeLine{04923 }
\DoxyCodeLine{04924         \textcolor{keywordtype}{void} printTotals(Totals \textcolor{keyword}{const}\& totals);}
\DoxyCodeLine{04925         \textcolor{keywordtype}{void} printSummaryRow(std::string \textcolor{keyword}{const}\& label, std::vector<SummaryColumn> \textcolor{keyword}{const}\& cols, std::size\_t row);}
\DoxyCodeLine{04926 }
\DoxyCodeLine{04927         \textcolor{keywordtype}{void} printTotalsDivider(Totals \textcolor{keyword}{const}\& totals);}
\DoxyCodeLine{04928         \textcolor{keywordtype}{void} printSummaryDivider();}
\DoxyCodeLine{04929 }
\DoxyCodeLine{04930     \textcolor{keyword}{private}:}
\DoxyCodeLine{04931         \textcolor{keywordtype}{bool} m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{04932     \};}
\DoxyCodeLine{04933 }
\DoxyCodeLine{04934 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{04935 }
\DoxyCodeLine{04936 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{04937 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{04938 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{04939 }
\DoxyCodeLine{04940 \textcolor{comment}{// end catch\_reporter\_console.h}}
\DoxyCodeLine{04941 \textcolor{comment}{// start catch\_reporter\_junit.h}}
\DoxyCodeLine{04942 }
\DoxyCodeLine{04943 \textcolor{comment}{// start catch\_xmlwriter.h}}
\DoxyCodeLine{04944 }
\DoxyCodeLine{04945 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{04946 }
\DoxyCodeLine{04947 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{04948 }
\DoxyCodeLine{04949     \textcolor{keyword}{class }XmlEncode \{}
\DoxyCodeLine{04950     \textcolor{keyword}{public}:}
\DoxyCodeLine{04951         \textcolor{keyword}{enum} ForWhat \{ ForTextNodes, ForAttributes \};}
\DoxyCodeLine{04952 }
\DoxyCodeLine{04953         XmlEncode( std::string \textcolor{keyword}{const}\& str, ForWhat forWhat = ForTextNodes );}
\DoxyCodeLine{04954 }
\DoxyCodeLine{04955         \textcolor{keywordtype}{void} encodeTo( std::ostream\& os ) \textcolor{keyword}{const};}
\DoxyCodeLine{04956 }
\DoxyCodeLine{04957         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, XmlEncode \textcolor{keyword}{const}\& xmlEncode );}
\DoxyCodeLine{04958 }
\DoxyCodeLine{04959     \textcolor{keyword}{private}:}
\DoxyCodeLine{04960         std::string m\_str;}
\DoxyCodeLine{04961         ForWhat m\_forWhat;}
\DoxyCodeLine{04962     \};}
\DoxyCodeLine{04963 }
\DoxyCodeLine{04964     \textcolor{keyword}{class }XmlWriter \{}
\DoxyCodeLine{04965     \textcolor{keyword}{public}:}
\DoxyCodeLine{04966 }
\DoxyCodeLine{04967         \textcolor{keyword}{class }ScopedElement \{}
\DoxyCodeLine{04968         \textcolor{keyword}{public}:}
\DoxyCodeLine{04969             ScopedElement( XmlWriter* writer );}
\DoxyCodeLine{04970 }
\DoxyCodeLine{04971             ScopedElement( ScopedElement\&\& other ) noexcept;}
\DoxyCodeLine{04972             ScopedElement\& operator=( ScopedElement\&\& other ) noexcept;}
\DoxyCodeLine{04973 }
\DoxyCodeLine{04974             ~ScopedElement();}
\DoxyCodeLine{04975 }
\DoxyCodeLine{04976             ScopedElement\& writeText( std::string \textcolor{keyword}{const}\& text, \textcolor{keywordtype}{bool} indent = \textcolor{keyword}{true} );}
\DoxyCodeLine{04977 }
\DoxyCodeLine{04978             \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{04979             ScopedElement\& writeAttribute( std::string \textcolor{keyword}{const}\& name, T \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{04980                 m\_writer->writeAttribute( name, attribute );}
\DoxyCodeLine{04981                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{04982             \}}
\DoxyCodeLine{04983 }
\DoxyCodeLine{04984         \textcolor{keyword}{private}:}
\DoxyCodeLine{04985             \textcolor{keyword}{mutable} XmlWriter* m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{04986         \};}
\DoxyCodeLine{04987 }
\DoxyCodeLine{04988         XmlWriter( std::ostream\& os = Catch::cout() );}
\DoxyCodeLine{04989         ~XmlWriter();}
\DoxyCodeLine{04990 }
\DoxyCodeLine{04991         XmlWriter( XmlWriter \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{04992         XmlWriter\& operator=( XmlWriter \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{04993 }
\DoxyCodeLine{04994         XmlWriter\& startElement( std::string \textcolor{keyword}{const}\& name );}
\DoxyCodeLine{04995 }
\DoxyCodeLine{04996         ScopedElement scopedElement( std::string \textcolor{keyword}{const}\& name );}
\DoxyCodeLine{04997 }
\DoxyCodeLine{04998         XmlWriter\& endElement();}
\DoxyCodeLine{04999 }
\DoxyCodeLine{05000         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& attribute );}
\DoxyCodeLine{05001 }
\DoxyCodeLine{05002         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, \textcolor{keywordtype}{bool} attribute );}
\DoxyCodeLine{05003 }
\DoxyCodeLine{05004         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{05005         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, T \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{05006             ReusableStringStream rss;}
\DoxyCodeLine{05007             rss << attribute;}
\DoxyCodeLine{05008             \textcolor{keywordflow}{return} writeAttribute( name, rss.str() );}
\DoxyCodeLine{05009         \}}
\DoxyCodeLine{05010 }
\DoxyCodeLine{05011         XmlWriter\& writeText( std::string \textcolor{keyword}{const}\& text, \textcolor{keywordtype}{bool} indent = \textcolor{keyword}{true} );}
\DoxyCodeLine{05012 }
\DoxyCodeLine{05013         XmlWriter\& writeComment( std::string \textcolor{keyword}{const}\& text );}
\DoxyCodeLine{05014 }
\DoxyCodeLine{05015         \textcolor{keywordtype}{void} writeStylesheetRef( std::string \textcolor{keyword}{const}\& url );}
\DoxyCodeLine{05016 }
\DoxyCodeLine{05017         XmlWriter\& writeBlankLine();}
\DoxyCodeLine{05018 }
\DoxyCodeLine{05019         \textcolor{keywordtype}{void} ensureTagClosed();}
\DoxyCodeLine{05020 }
\DoxyCodeLine{05021     \textcolor{keyword}{private}:}
\DoxyCodeLine{05022 }
\DoxyCodeLine{05023         \textcolor{keywordtype}{void} writeDeclaration();}
\DoxyCodeLine{05024 }
\DoxyCodeLine{05025         \textcolor{keywordtype}{void} newlineIfNecessary();}
\DoxyCodeLine{05026 }
\DoxyCodeLine{05027         \textcolor{keywordtype}{bool} m\_tagIsOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{05028         \textcolor{keywordtype}{bool} m\_needsNewline = \textcolor{keyword}{false};}
\DoxyCodeLine{05029         std::vector<std::string> m\_tags;}
\DoxyCodeLine{05030         std::string m\_indent;}
\DoxyCodeLine{05031         std::ostream\& m\_os;}
\DoxyCodeLine{05032     \};}
\DoxyCodeLine{05033 }
\DoxyCodeLine{05034 \}}
\DoxyCodeLine{05035 }
\DoxyCodeLine{05036 \textcolor{comment}{// end catch\_xmlwriter.h}}
\DoxyCodeLine{05037 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05038 }
\DoxyCodeLine{05039     \textcolor{keyword}{class }JunitReporter : \textcolor{keyword}{public} CumulativeReporterBase<JunitReporter> \{}
\DoxyCodeLine{05040     \textcolor{keyword}{public}:}
\DoxyCodeLine{05041         JunitReporter(ReporterConfig \textcolor{keyword}{const}\& \_config);}
\DoxyCodeLine{05042 }
\DoxyCodeLine{05043         ~JunitReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{05044 }
\DoxyCodeLine{05045         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{05046 }
\DoxyCodeLine{05047         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& \textcolor{comment}{/*spec*/}) \textcolor{keyword}{override};}
\DoxyCodeLine{05048 }
\DoxyCodeLine{05049         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& runInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{05050 }
\DoxyCodeLine{05051         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& groupInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{05052 }
\DoxyCodeLine{05053         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{05054         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{05055 }
\DoxyCodeLine{05056         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{05057 }
\DoxyCodeLine{05058         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{05059 }
\DoxyCodeLine{05060         \textcolor{keywordtype}{void} testRunEndedCumulative() \textcolor{keyword}{override};}
\DoxyCodeLine{05061 }
\DoxyCodeLine{05062         \textcolor{keywordtype}{void} writeGroup(TestGroupNode \textcolor{keyword}{const}\& groupNode, \textcolor{keywordtype}{double} suiteTime);}
\DoxyCodeLine{05063 }
\DoxyCodeLine{05064         \textcolor{keywordtype}{void} writeTestCase(TestCaseNode \textcolor{keyword}{const}\& testCaseNode);}
\DoxyCodeLine{05065 }
\DoxyCodeLine{05066         \textcolor{keywordtype}{void} writeSection(std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{05067                           std::string \textcolor{keyword}{const}\& rootName,}
\DoxyCodeLine{05068                           SectionNode \textcolor{keyword}{const}\& sectionNode);}
\DoxyCodeLine{05069 }
\DoxyCodeLine{05070         \textcolor{keywordtype}{void} writeAssertions(SectionNode \textcolor{keyword}{const}\& sectionNode);}
\DoxyCodeLine{05071         \textcolor{keywordtype}{void} writeAssertion(AssertionStats \textcolor{keyword}{const}\& stats);}
\DoxyCodeLine{05072 }
\DoxyCodeLine{05073         XmlWriter xml;}
\DoxyCodeLine{05074         Timer suiteTimer;}
\DoxyCodeLine{05075         std::string stdOutForSuite;}
\DoxyCodeLine{05076         std::string stdErrForSuite;}
\DoxyCodeLine{05077         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} unexpectedExceptions = 0;}
\DoxyCodeLine{05078         \textcolor{keywordtype}{bool} m\_okToFail = \textcolor{keyword}{false};}
\DoxyCodeLine{05079     \};}
\DoxyCodeLine{05080 }
\DoxyCodeLine{05081 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{05082 }
\DoxyCodeLine{05083 \textcolor{comment}{// end catch\_reporter\_junit.h}}
\DoxyCodeLine{05084 \textcolor{comment}{// start catch\_reporter\_xml.h}}
\DoxyCodeLine{05085 }
\DoxyCodeLine{05086 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05087     \textcolor{keyword}{class }XmlReporter : \textcolor{keyword}{public} StreamingReporterBase<XmlReporter> \{}
\DoxyCodeLine{05088     \textcolor{keyword}{public}:}
\DoxyCodeLine{05089         XmlReporter(ReporterConfig \textcolor{keyword}{const}\& \_config);}
\DoxyCodeLine{05090 }
\DoxyCodeLine{05091         ~XmlReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{05092 }
\DoxyCodeLine{05093         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{05094 }
\DoxyCodeLine{05095         \textcolor{keyword}{virtual} std::string getStylesheetRef() \textcolor{keyword}{const};}
\DoxyCodeLine{05096 }
\DoxyCodeLine{05097         \textcolor{keywordtype}{void} writeSourceInfo(SourceLineInfo \textcolor{keyword}{const}\& sourceInfo);}
\DoxyCodeLine{05098 }
\DoxyCodeLine{05099     \textcolor{keyword}{public}: \textcolor{comment}{// StreamingReporterBase}}
\DoxyCodeLine{05100 }
\DoxyCodeLine{05101         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& s) \textcolor{keyword}{override};}
\DoxyCodeLine{05102 }
\DoxyCodeLine{05103         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& testInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{05104 }
\DoxyCodeLine{05105         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& groupInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{05106 }
\DoxyCodeLine{05107         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& testInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{05108 }
\DoxyCodeLine{05109         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& sectionInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{05110 }
\DoxyCodeLine{05111         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{05112 }
\DoxyCodeLine{05113         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{05114 }
\DoxyCodeLine{05115         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{05116 }
\DoxyCodeLine{05117         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{05118 }
\DoxyCodeLine{05119         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{05120 }
\DoxyCodeLine{05121         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{05122 }
\DoxyCodeLine{05123     \textcolor{keyword}{private}:}
\DoxyCodeLine{05124         Timer m\_testCaseTimer;}
\DoxyCodeLine{05125         XmlWriter m\_xml;}
\DoxyCodeLine{05126         \textcolor{keywordtype}{int} m\_sectionDepth = 0;}
\DoxyCodeLine{05127     \};}
\DoxyCodeLine{05128 }
\DoxyCodeLine{05129 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{05130 }
\DoxyCodeLine{05131 \textcolor{comment}{// end catch\_reporter\_xml.h}}
\DoxyCodeLine{05132 }
\DoxyCodeLine{05133 \textcolor{comment}{// end catch\_external\_interfaces.h}}
\DoxyCodeLine{05134 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05135 }
\DoxyCodeLine{05136 \textcolor{preprocessor}{\#endif // ! CATCH\_CONFIG\_IMPL\_ONLY}}
\DoxyCodeLine{05137 }
\DoxyCodeLine{05138 \textcolor{preprocessor}{\#ifdef CATCH\_IMPL}}
\DoxyCodeLine{05139 \textcolor{comment}{// start catch\_impl.hpp}}
\DoxyCodeLine{05140 }
\DoxyCodeLine{05141 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{05142 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{05143 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "-Wweak-vtables"}}
\DoxyCodeLine{05144 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05145 }
\DoxyCodeLine{05146 \textcolor{comment}{// Keep these here for external reporters}}
\DoxyCodeLine{05147 \textcolor{comment}{// start catch\_test\_case\_tracker.h}}
\DoxyCodeLine{05148 }
\DoxyCodeLine{05149 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{05150 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{05151 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{05152 }
\DoxyCodeLine{05153 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05154 \textcolor{keyword}{namespace }TestCaseTracking \{}
\DoxyCodeLine{05155 }
\DoxyCodeLine{05156     \textcolor{keyword}{struct }NameAndLocation \{}
\DoxyCodeLine{05157         std::string name;}
\DoxyCodeLine{05158         SourceLineInfo location;}
\DoxyCodeLine{05159 }
\DoxyCodeLine{05160         NameAndLocation( std::string \textcolor{keyword}{const}\& \_name, SourceLineInfo \textcolor{keyword}{const}\& \_location );}
\DoxyCodeLine{05161     \};}
\DoxyCodeLine{05162 }
\DoxyCodeLine{05163     \textcolor{keyword}{struct }ITracker;}
\DoxyCodeLine{05164 }
\DoxyCodeLine{05165     \textcolor{keyword}{using} ITrackerPtr = std::shared\_ptr<ITracker>;}
\DoxyCodeLine{05166 }
\DoxyCodeLine{05167     \textcolor{keyword}{struct }ITracker \{}
\DoxyCodeLine{05168         \textcolor{keyword}{virtual} ~ITracker();}
\DoxyCodeLine{05169 }
\DoxyCodeLine{05170         \textcolor{comment}{// static queries}}
\DoxyCodeLine{05171         \textcolor{keyword}{virtual} NameAndLocation \textcolor{keyword}{const}\& nameAndLocation() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{05172 }
\DoxyCodeLine{05173         \textcolor{comment}{// dynamic queries}}
\DoxyCodeLine{05174         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const} = 0; \textcolor{comment}{// Successfully completed or failed}}
\DoxyCodeLine{05175         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSuccessfullyCompleted() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{05176         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isOpen() \textcolor{keyword}{const} = 0; \textcolor{comment}{// Started but not complete}}
\DoxyCodeLine{05177         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasChildren() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{05178 }
\DoxyCodeLine{05179         \textcolor{keyword}{virtual} ITracker\& parent() = 0;}
\DoxyCodeLine{05180 }
\DoxyCodeLine{05181         \textcolor{comment}{// actions}}
\DoxyCodeLine{05182         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} close() = 0; \textcolor{comment}{// Successfully complete}}
\DoxyCodeLine{05183         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} fail() = 0;}
\DoxyCodeLine{05184         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} markAsNeedingAnotherRun() = 0;}
\DoxyCodeLine{05185 }
\DoxyCodeLine{05186         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) = 0;}
\DoxyCodeLine{05187         \textcolor{keyword}{virtual} ITrackerPtr findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) = 0;}
\DoxyCodeLine{05188         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} openChild() = 0;}
\DoxyCodeLine{05189 }
\DoxyCodeLine{05190         \textcolor{comment}{// Debug/ checking}}
\DoxyCodeLine{05191         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{05192         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isIndexTracker() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{05193     \};}
\DoxyCodeLine{05194 }
\DoxyCodeLine{05195     \textcolor{keyword}{class }TrackerContext \{}
\DoxyCodeLine{05196 }
\DoxyCodeLine{05197         \textcolor{keyword}{enum} RunState \{}
\DoxyCodeLine{05198             NotStarted,}
\DoxyCodeLine{05199             Executing,}
\DoxyCodeLine{05200             CompletedCycle}
\DoxyCodeLine{05201         \};}
\DoxyCodeLine{05202 }
\DoxyCodeLine{05203         ITrackerPtr m\_rootTracker;}
\DoxyCodeLine{05204         ITracker* m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{05205         RunState m\_runState = NotStarted;}
\DoxyCodeLine{05206 }
\DoxyCodeLine{05207     \textcolor{keyword}{public}:}
\DoxyCodeLine{05208 }
\DoxyCodeLine{05209         \textcolor{keyword}{static} TrackerContext\& instance();}
\DoxyCodeLine{05210 }
\DoxyCodeLine{05211         ITracker\& startRun();}
\DoxyCodeLine{05212         \textcolor{keywordtype}{void} endRun();}
\DoxyCodeLine{05213 }
\DoxyCodeLine{05214         \textcolor{keywordtype}{void} startCycle();}
\DoxyCodeLine{05215         \textcolor{keywordtype}{void} completeCycle();}
\DoxyCodeLine{05216 }
\DoxyCodeLine{05217         \textcolor{keywordtype}{bool} completedCycle() \textcolor{keyword}{const};}
\DoxyCodeLine{05218         ITracker\& currentTracker();}
\DoxyCodeLine{05219         \textcolor{keywordtype}{void} setCurrentTracker( ITracker* tracker );}
\DoxyCodeLine{05220     \};}
\DoxyCodeLine{05221 }
\DoxyCodeLine{05222     \textcolor{keyword}{class }TrackerBase : \textcolor{keyword}{public} ITracker \{}
\DoxyCodeLine{05223     \textcolor{keyword}{protected}:}
\DoxyCodeLine{05224         \textcolor{keyword}{enum} CycleState \{}
\DoxyCodeLine{05225             NotStarted,}
\DoxyCodeLine{05226             Executing,}
\DoxyCodeLine{05227             ExecutingChildren,}
\DoxyCodeLine{05228             NeedsAnotherRun,}
\DoxyCodeLine{05229             CompletedSuccessfully,}
\DoxyCodeLine{05230             Failed}
\DoxyCodeLine{05231         \};}
\DoxyCodeLine{05232 }
\DoxyCodeLine{05233         \textcolor{keyword}{using} Children = std::vector<ITrackerPtr>;}
\DoxyCodeLine{05234         NameAndLocation m\_nameAndLocation;}
\DoxyCodeLine{05235         TrackerContext\& m\_ctx;}
\DoxyCodeLine{05236         ITracker* m\_parent;}
\DoxyCodeLine{05237         Children m\_children;}
\DoxyCodeLine{05238         CycleState m\_runState = NotStarted;}
\DoxyCodeLine{05239 }
\DoxyCodeLine{05240     \textcolor{keyword}{public}:}
\DoxyCodeLine{05241         TrackerBase( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent );}
\DoxyCodeLine{05242 }
\DoxyCodeLine{05243         NameAndLocation \textcolor{keyword}{const}\& nameAndLocation() \textcolor{keyword}{const override};}
\DoxyCodeLine{05244         \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const override};}
\DoxyCodeLine{05245         \textcolor{keywordtype}{bool} isSuccessfullyCompleted() \textcolor{keyword}{const override};}
\DoxyCodeLine{05246         \textcolor{keywordtype}{bool} isOpen() \textcolor{keyword}{const override};}
\DoxyCodeLine{05247         \textcolor{keywordtype}{bool} hasChildren() \textcolor{keyword}{const override};}
\DoxyCodeLine{05248 }
\DoxyCodeLine{05249         \textcolor{keywordtype}{void} addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) \textcolor{keyword}{override};}
\DoxyCodeLine{05250 }
\DoxyCodeLine{05251         ITrackerPtr findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \textcolor{keyword}{override};}
\DoxyCodeLine{05252         ITracker\& parent() \textcolor{keyword}{override};}
\DoxyCodeLine{05253 }
\DoxyCodeLine{05254         \textcolor{keywordtype}{void} openChild() \textcolor{keyword}{override};}
\DoxyCodeLine{05255 }
\DoxyCodeLine{05256         \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{05257         \textcolor{keywordtype}{bool} isIndexTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{05258 }
\DoxyCodeLine{05259         \textcolor{keywordtype}{void} open();}
\DoxyCodeLine{05260 }
\DoxyCodeLine{05261         \textcolor{keywordtype}{void} close() \textcolor{keyword}{override};}
\DoxyCodeLine{05262         \textcolor{keywordtype}{void} fail() \textcolor{keyword}{override};}
\DoxyCodeLine{05263         \textcolor{keywordtype}{void} markAsNeedingAnotherRun() \textcolor{keyword}{override};}
\DoxyCodeLine{05264 }
\DoxyCodeLine{05265     \textcolor{keyword}{private}:}
\DoxyCodeLine{05266         \textcolor{keywordtype}{void} moveToParent();}
\DoxyCodeLine{05267         \textcolor{keywordtype}{void} moveToThis();}
\DoxyCodeLine{05268     \};}
\DoxyCodeLine{05269 }
\DoxyCodeLine{05270     \textcolor{keyword}{class }SectionTracker : \textcolor{keyword}{public} TrackerBase \{}
\DoxyCodeLine{05271         std::vector<std::string> m\_filters;}
\DoxyCodeLine{05272     \textcolor{keyword}{public}:}
\DoxyCodeLine{05273         SectionTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent );}
\DoxyCodeLine{05274 }
\DoxyCodeLine{05275         \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{05276 }
\DoxyCodeLine{05277         \textcolor{keyword}{static} SectionTracker\& acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation );}
\DoxyCodeLine{05278 }
\DoxyCodeLine{05279         \textcolor{keywordtype}{void} tryOpen();}
\DoxyCodeLine{05280 }
\DoxyCodeLine{05281         \textcolor{keywordtype}{void} addInitialFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters );}
\DoxyCodeLine{05282         \textcolor{keywordtype}{void} addNextFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters );}
\DoxyCodeLine{05283     \};}
\DoxyCodeLine{05284 }
\DoxyCodeLine{05285     \textcolor{keyword}{class }IndexTracker : \textcolor{keyword}{public} TrackerBase \{}
\DoxyCodeLine{05286         \textcolor{keywordtype}{int} m\_size;}
\DoxyCodeLine{05287         \textcolor{keywordtype}{int} m\_index = -1;}
\DoxyCodeLine{05288     \textcolor{keyword}{public}:}
\DoxyCodeLine{05289         IndexTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent, \textcolor{keywordtype}{int} size );}
\DoxyCodeLine{05290 }
\DoxyCodeLine{05291         \textcolor{keywordtype}{bool} isIndexTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{05292         \textcolor{keywordtype}{void} close() \textcolor{keyword}{override};}
\DoxyCodeLine{05293 }
\DoxyCodeLine{05294         \textcolor{keyword}{static} IndexTracker\& acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, \textcolor{keywordtype}{int} size );}
\DoxyCodeLine{05295 }
\DoxyCodeLine{05296         \textcolor{keywordtype}{int} index() \textcolor{keyword}{const};}
\DoxyCodeLine{05297 }
\DoxyCodeLine{05298         \textcolor{keywordtype}{void} moveNext();}
\DoxyCodeLine{05299     \};}
\DoxyCodeLine{05300 }
\DoxyCodeLine{05301 \} \textcolor{comment}{// namespace TestCaseTracking}}
\DoxyCodeLine{05302 }
\DoxyCodeLine{05303 \textcolor{keyword}{using} TestCaseTracking::ITracker;}
\DoxyCodeLine{05304 \textcolor{keyword}{using} TestCaseTracking::TrackerContext;}
\DoxyCodeLine{05305 \textcolor{keyword}{using} TestCaseTracking::SectionTracker;}
\DoxyCodeLine{05306 \textcolor{keyword}{using} TestCaseTracking::IndexTracker;}
\DoxyCodeLine{05307 }
\DoxyCodeLine{05308 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{05309 }
\DoxyCodeLine{05310 \textcolor{comment}{// end catch\_test\_case\_tracker.h}}
\DoxyCodeLine{05311 }
\DoxyCodeLine{05312 \textcolor{comment}{// start catch\_leak\_detector.h}}
\DoxyCodeLine{05313 }
\DoxyCodeLine{05314 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05315 }
\DoxyCodeLine{05316     \textcolor{keyword}{struct }LeakDetector \{}
\DoxyCodeLine{05317         LeakDetector();}
\DoxyCodeLine{05318         ~LeakDetector();}
\DoxyCodeLine{05319     \};}
\DoxyCodeLine{05320 }
\DoxyCodeLine{05321 \}}
\DoxyCodeLine{05322 \textcolor{comment}{// end catch\_leak\_detector.h}}
\DoxyCodeLine{05323 \textcolor{comment}{// Cpp files will be included in the single-header file here}}
\DoxyCodeLine{05324 \textcolor{comment}{// start catch\_approx.cpp}}
\DoxyCodeLine{05325 }
\DoxyCodeLine{05326 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{05327 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{05328 }
\DoxyCodeLine{05329 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{05330 }
\DoxyCodeLine{05331 \textcolor{comment}{// Performs equivalent check of std::fabs(lhs - rhs) <= margin}}
\DoxyCodeLine{05332 \textcolor{comment}{// But without the subtraction to allow for INFINITY in comparison}}
\DoxyCodeLine{05333 \textcolor{keywordtype}{bool} marginComparison(\textcolor{keywordtype}{double} lhs, \textcolor{keywordtype}{double} rhs, \textcolor{keywordtype}{double} margin) \{}
\DoxyCodeLine{05334     \textcolor{keywordflow}{return} (lhs + margin >= rhs) \&\& (rhs + margin >= lhs);}
\DoxyCodeLine{05335 \}}
\DoxyCodeLine{05336 }
\DoxyCodeLine{05337 \}}
\DoxyCodeLine{05338 }
\DoxyCodeLine{05339 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05340 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{05341 }
\DoxyCodeLine{05342     Approx::Approx ( \textcolor{keywordtype}{double} value )}
\DoxyCodeLine{05343     :   m\_epsilon( std::numeric\_limits<float>::epsilon()*100 ),}
\DoxyCodeLine{05344         m\_margin( 0.0 ),}
\DoxyCodeLine{05345         m\_scale( 0.0 ),}
\DoxyCodeLine{05346         m\_value( value )}
\DoxyCodeLine{05347     \{\}}
\DoxyCodeLine{05348 }
\DoxyCodeLine{05349     \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} Approx::custom() \{}
\DoxyCodeLine{05350         \textcolor{keywordflow}{return} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}}( 0 );}
\DoxyCodeLine{05351     \}}
\DoxyCodeLine{05352 }
\DoxyCodeLine{05353     \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Approx}} Approx::operator-()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05354         \textcolor{keyword}{auto} temp(*\textcolor{keyword}{this});}
\DoxyCodeLine{05355         temp.m\_value = -temp.m\_value;}
\DoxyCodeLine{05356         \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{05357     \}}
\DoxyCodeLine{05358 }
\DoxyCodeLine{05359     std::string Approx::toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05360         ReusableStringStream rss;}
\DoxyCodeLine{05361         rss << \textcolor{stringliteral}{"Approx( "} << ::Catch::Detail::stringify( m\_value ) << \textcolor{stringliteral}{" )"};}
\DoxyCodeLine{05362         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{05363     \}}
\DoxyCodeLine{05364 }
\DoxyCodeLine{05365     \textcolor{keywordtype}{bool} Approx::equalityComparisonImpl(\textcolor{keyword}{const} \textcolor{keywordtype}{double} other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05366         \textcolor{comment}{// First try with fixed margin, then compute margin based on epsilon, scale and Approx's value}}
\DoxyCodeLine{05367         \textcolor{comment}{// Thanks to Richard Harris for his help refining the scaled margin value}}
\DoxyCodeLine{05368         \textcolor{keywordflow}{return} marginComparison(m\_value, other, m\_margin) || marginComparison(m\_value, other, m\_epsilon * (m\_scale + std::fabs(m\_value)));}
\DoxyCodeLine{05369     \}}
\DoxyCodeLine{05370 }
\DoxyCodeLine{05371     \textcolor{keywordtype}{void} Approx::setMargin(\textcolor{keywordtype}{double} margin) \{}
\DoxyCodeLine{05372         CATCH\_ENFORCE(margin >= 0,}
\DoxyCodeLine{05373             \textcolor{stringliteral}{"Invalid Approx::margin: "} << margin << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{05374             << \textcolor{stringliteral}{" Approx::Margin has to be non-negative."});}
\DoxyCodeLine{05375         m\_margin = margin;}
\DoxyCodeLine{05376     \}}
\DoxyCodeLine{05377 }
\DoxyCodeLine{05378     \textcolor{keywordtype}{void} Approx::setEpsilon(\textcolor{keywordtype}{double} epsilon) \{}
\DoxyCodeLine{05379         CATCH\_ENFORCE(epsilon >= 0 \&\& epsilon <= 1.0,}
\DoxyCodeLine{05380             \textcolor{stringliteral}{"Invalid Approx::epsilon: "} << epsilon << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{05381             << \textcolor{stringliteral}{" Approx::epsilon has to be in [0, 1]"});}
\DoxyCodeLine{05382         m\_epsilon = epsilon;}
\DoxyCodeLine{05383     \}}
\DoxyCodeLine{05384 }
\DoxyCodeLine{05385 \} \textcolor{comment}{// end namespace Detail}}
\DoxyCodeLine{05386 }
\DoxyCodeLine{05387 \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{05388     Detail::Approx \textcolor{keyword}{operator} \textcolor{stringliteral}{""} \_a(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val) \{}
\DoxyCodeLine{05389         \textcolor{keywordflow}{return} Detail::Approx(val);}
\DoxyCodeLine{05390     \}}
\DoxyCodeLine{05391     Detail::Approx \textcolor{keyword}{operator} \textcolor{stringliteral}{""} \_a(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) \{}
\DoxyCodeLine{05392         \textcolor{keywordflow}{return} Detail::Approx(val);}
\DoxyCodeLine{05393     \}}
\DoxyCodeLine{05394 \} \textcolor{comment}{// end namespace literals}}
\DoxyCodeLine{05395 }
\DoxyCodeLine{05396 std::string StringMaker<Catch::Detail::Approx>::convert(\mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Catch::Detail::Approx}} \textcolor{keyword}{const}\& value) \{}
\DoxyCodeLine{05397     \textcolor{keywordflow}{return} value.toString();}
\DoxyCodeLine{05398 \}}
\DoxyCodeLine{05399 }
\DoxyCodeLine{05400 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{05401 \textcolor{comment}{// end catch\_approx.cpp}}
\DoxyCodeLine{05402 \textcolor{comment}{// start catch\_assertionhandler.cpp}}
\DoxyCodeLine{05403 }
\DoxyCodeLine{05404 \textcolor{comment}{// start catch\_context.h}}
\DoxyCodeLine{05405 }
\DoxyCodeLine{05406 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{05407 }
\DoxyCodeLine{05408 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05409 }
\DoxyCodeLine{05410     \textcolor{keyword}{struct }IResultCapture;}
\DoxyCodeLine{05411     \textcolor{keyword}{struct }IRunner;}
\DoxyCodeLine{05412     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{05413     \textcolor{keyword}{struct }IMutableContext;}
\DoxyCodeLine{05414 }
\DoxyCodeLine{05415     \textcolor{keyword}{using} IConfigPtr = std::shared\_ptr<IConfig const>;}
\DoxyCodeLine{05416 }
\DoxyCodeLine{05417     \textcolor{keyword}{struct }IContext}
\DoxyCodeLine{05418     \{}
\DoxyCodeLine{05419         \textcolor{keyword}{virtual} ~IContext();}
\DoxyCodeLine{05420 }
\DoxyCodeLine{05421         \textcolor{keyword}{virtual} IResultCapture* getResultCapture() = 0;}
\DoxyCodeLine{05422         \textcolor{keyword}{virtual} IRunner* getRunner() = 0;}
\DoxyCodeLine{05423         \textcolor{keyword}{virtual} IConfigPtr \textcolor{keyword}{const}\& getConfig() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{05424     \};}
\DoxyCodeLine{05425 }
\DoxyCodeLine{05426     \textcolor{keyword}{struct }IMutableContext : IContext}
\DoxyCodeLine{05427     \{}
\DoxyCodeLine{05428         \textcolor{keyword}{virtual} ~IMutableContext();}
\DoxyCodeLine{05429         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setResultCapture( IResultCapture* resultCapture ) = 0;}
\DoxyCodeLine{05430         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setRunner( IRunner* runner ) = 0;}
\DoxyCodeLine{05431         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setConfig( IConfigPtr \textcolor{keyword}{const}\& config ) = 0;}
\DoxyCodeLine{05432 }
\DoxyCodeLine{05433     \textcolor{keyword}{private}:}
\DoxyCodeLine{05434         \textcolor{keyword}{static} IMutableContext *currentContext;}
\DoxyCodeLine{05435         \textcolor{keyword}{friend} IMutableContext\& getCurrentMutableContext();}
\DoxyCodeLine{05436         \textcolor{keyword}{friend} \textcolor{keywordtype}{void} cleanUpContext();}
\DoxyCodeLine{05437         \textcolor{keyword}{static} \textcolor{keywordtype}{void} createContext();}
\DoxyCodeLine{05438     \};}
\DoxyCodeLine{05439 }
\DoxyCodeLine{05440     \textcolor{keyword}{inline} IMutableContext\& getCurrentMutableContext()}
\DoxyCodeLine{05441     \{}
\DoxyCodeLine{05442         \textcolor{keywordflow}{if}( !IMutableContext::currentContext )}
\DoxyCodeLine{05443             IMutableContext::createContext();}
\DoxyCodeLine{05444         \textcolor{keywordflow}{return} *IMutableContext::currentContext;}
\DoxyCodeLine{05445     \}}
\DoxyCodeLine{05446 }
\DoxyCodeLine{05447     \textcolor{keyword}{inline} IContext\& getCurrentContext()}
\DoxyCodeLine{05448     \{}
\DoxyCodeLine{05449         \textcolor{keywordflow}{return} getCurrentMutableContext();}
\DoxyCodeLine{05450     \}}
\DoxyCodeLine{05451 }
\DoxyCodeLine{05452     \textcolor{keywordtype}{void} cleanUpContext();}
\DoxyCodeLine{05453 \}}
\DoxyCodeLine{05454 }
\DoxyCodeLine{05455 \textcolor{comment}{// end catch\_context.h}}
\DoxyCodeLine{05456 \textcolor{comment}{// start catch\_debugger.h}}
\DoxyCodeLine{05457 }
\DoxyCodeLine{05458 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05459     \textcolor{keywordtype}{bool} isDebuggerActive();}
\DoxyCodeLine{05460 \}}
\DoxyCodeLine{05461 }
\DoxyCodeLine{05462 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{05463 }
\DoxyCodeLine{05464 \textcolor{preprocessor}{    \#define CATCH\_TRAP() \_\_asm\_\_("int \$3\(\backslash\)n" : : ) }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{05465 }
\DoxyCodeLine{05466 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_LINUX)}}
\DoxyCodeLine{05467     \textcolor{comment}{// If we can use inline assembler, do it because this allows us to break}}
\DoxyCodeLine{05468     \textcolor{comment}{// directly at the location of the failing check instead of breaking inside}}
\DoxyCodeLine{05469     \textcolor{comment}{// raise() called from it, i.e. one stack frame below.}}
\DoxyCodeLine{05470 \textcolor{preprocessor}{    \#if defined(\_\_GNUC\_\_) \&\& (defined(\_\_i386) || defined(\_\_x86\_64))}}
\DoxyCodeLine{05471 \textcolor{preprocessor}{        \#define CATCH\_TRAP() asm volatile ("int \$3") }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{05472 \textcolor{preprocessor}{    \#else // Fall back to the generic way.}}
\DoxyCodeLine{05473 \textcolor{preprocessor}{        \#include <signal.h>}}
\DoxyCodeLine{05474 }
\DoxyCodeLine{05475 \textcolor{preprocessor}{        \#define CATCH\_TRAP() raise(SIGTRAP)}}
\DoxyCodeLine{05476 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{05477 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{05478 \textcolor{preprocessor}{    \#define CATCH\_TRAP() \_\_debugbreak()}}
\DoxyCodeLine{05479 \textcolor{preprocessor}{\#elif defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{05480     \textcolor{keyword}{extern} \textcolor{stringliteral}{"C"} \_\_declspec(dllimport) \textcolor{keywordtype}{void} \_\_stdcall DebugBreak();}
\DoxyCodeLine{05481 \textcolor{preprocessor}{    \#define CATCH\_TRAP() DebugBreak()}}
\DoxyCodeLine{05482 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05483 }
\DoxyCodeLine{05484 \textcolor{preprocessor}{\#ifdef CATCH\_TRAP}}
\DoxyCodeLine{05485 \textcolor{preprocessor}{    \#define CATCH\_BREAK\_INTO\_DEBUGGER() if( Catch::isDebuggerActive() ) \{ CATCH\_TRAP(); \}}}
\DoxyCodeLine{05486 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{05487     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05488         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} doNothing() \{\}}
\DoxyCodeLine{05489     \}}
\DoxyCodeLine{05490 \textcolor{preprocessor}{    \#define CATCH\_BREAK\_INTO\_DEBUGGER() Catch::doNothing()}}
\DoxyCodeLine{05491 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05492 }
\DoxyCodeLine{05493 \textcolor{comment}{// end catch\_debugger.h}}
\DoxyCodeLine{05494 \textcolor{comment}{// start catch\_run\_context.h}}
\DoxyCodeLine{05495 }
\DoxyCodeLine{05496 \textcolor{comment}{// start catch\_fatal\_condition.h}}
\DoxyCodeLine{05497 }
\DoxyCodeLine{05498 \textcolor{comment}{// start catch\_windows\_h\_proxy.h}}
\DoxyCodeLine{05499 }
\DoxyCodeLine{05500 }
\DoxyCodeLine{05501 \textcolor{preprocessor}{\#if defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{05502 }
\DoxyCodeLine{05503 \textcolor{preprocessor}{\#if !defined(NOMINMAX) \&\& !defined(CATCH\_CONFIG\_NO\_NOMINMAX)}}
\DoxyCodeLine{05504 \textcolor{preprocessor}{\#  define CATCH\_DEFINED\_NOMINMAX}}
\DoxyCodeLine{05505 \textcolor{preprocessor}{\#  define NOMINMAX}}
\DoxyCodeLine{05506 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05507 \textcolor{preprocessor}{\#if !defined(WIN32\_LEAN\_AND\_MEAN) \&\& !defined(CATCH\_CONFIG\_NO\_WIN32\_LEAN\_AND\_MEAN)}}
\DoxyCodeLine{05508 \textcolor{preprocessor}{\#  define CATCH\_DEFINED\_WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{05509 \textcolor{preprocessor}{\#  define WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{05510 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05511 }
\DoxyCodeLine{05512 \textcolor{preprocessor}{\#ifdef \_\_AFXDLL}}
\DoxyCodeLine{05513 \textcolor{preprocessor}{\#include <AfxWin.h>}}
\DoxyCodeLine{05514 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{05515 \textcolor{preprocessor}{\#include <windows.h>}}
\DoxyCodeLine{05516 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05517 }
\DoxyCodeLine{05518 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINED\_NOMINMAX}}
\DoxyCodeLine{05519 \textcolor{preprocessor}{\#  undef NOMINMAX}}
\DoxyCodeLine{05520 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05521 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINED\_WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{05522 \textcolor{preprocessor}{\#  undef WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{05523 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05524 }
\DoxyCodeLine{05525 \textcolor{preprocessor}{\#endif // defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{05526 }
\DoxyCodeLine{05527 \textcolor{comment}{// end catch\_windows\_h\_proxy.h}}
\DoxyCodeLine{05528 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH )}}
\DoxyCodeLine{05529 }
\DoxyCodeLine{05530 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05531 }
\DoxyCodeLine{05532     \textcolor{keyword}{struct }FatalConditionHandler \{}
\DoxyCodeLine{05533 }
\DoxyCodeLine{05534         \textcolor{keyword}{static} LONG CALLBACK handleVectoredException(PEXCEPTION\_POINTERS ExceptionInfo);}
\DoxyCodeLine{05535         FatalConditionHandler();}
\DoxyCodeLine{05536         \textcolor{keyword}{static} \textcolor{keywordtype}{void} reset();}
\DoxyCodeLine{05537         ~FatalConditionHandler();}
\DoxyCodeLine{05538 }
\DoxyCodeLine{05539     \textcolor{keyword}{private}:}
\DoxyCodeLine{05540         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} isSet;}
\DoxyCodeLine{05541         \textcolor{keyword}{static} ULONG guaranteeSize;}
\DoxyCodeLine{05542         \textcolor{keyword}{static} PVOID exceptionHandlerHandle;}
\DoxyCodeLine{05543     \};}
\DoxyCodeLine{05544 }
\DoxyCodeLine{05545 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{05546 }
\DoxyCodeLine{05547 \textcolor{preprocessor}{\#elif defined ( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{05548 }
\DoxyCodeLine{05549 \textcolor{preprocessor}{\#include <signal.h>}}
\DoxyCodeLine{05550 }
\DoxyCodeLine{05551 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05552 }
\DoxyCodeLine{05553     \textcolor{keyword}{struct }FatalConditionHandler \{}
\DoxyCodeLine{05554 }
\DoxyCodeLine{05555         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} isSet;}
\DoxyCodeLine{05556         \textcolor{keyword}{static} \textcolor{keyword}{struct }sigaction oldSigActions[];}
\DoxyCodeLine{05557         \textcolor{keyword}{static} stack\_t oldSigStack;}
\DoxyCodeLine{05558         \textcolor{keyword}{static} \textcolor{keywordtype}{char} altStackMem[];}
\DoxyCodeLine{05559 }
\DoxyCodeLine{05560         \textcolor{keyword}{static} \textcolor{keywordtype}{void} handleSignal( \textcolor{keywordtype}{int} sig );}
\DoxyCodeLine{05561 }
\DoxyCodeLine{05562         FatalConditionHandler();}
\DoxyCodeLine{05563         ~FatalConditionHandler();}
\DoxyCodeLine{05564         \textcolor{keyword}{static} \textcolor{keywordtype}{void} reset();}
\DoxyCodeLine{05565     \};}
\DoxyCodeLine{05566 }
\DoxyCodeLine{05567 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{05568 }
\DoxyCodeLine{05569 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{05570 }
\DoxyCodeLine{05571 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05572     \textcolor{keyword}{struct }FatalConditionHandler \{}
\DoxyCodeLine{05573         \textcolor{keywordtype}{void} reset();}
\DoxyCodeLine{05574     \};}
\DoxyCodeLine{05575 \}}
\DoxyCodeLine{05576 }
\DoxyCodeLine{05577 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05578 }
\DoxyCodeLine{05579 \textcolor{comment}{// end catch\_fatal\_condition.h}}
\DoxyCodeLine{05580 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{05581 }
\DoxyCodeLine{05582 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05583 }
\DoxyCodeLine{05584     \textcolor{keyword}{struct }IMutableContext;}
\DoxyCodeLine{05585 }
\DoxyCodeLine{05587 }
\DoxyCodeLine{05588     \textcolor{keyword}{class }RunContext : \textcolor{keyword}{public} IResultCapture, \textcolor{keyword}{public} IRunner \{}
\DoxyCodeLine{05589 }
\DoxyCodeLine{05590     \textcolor{keyword}{public}:}
\DoxyCodeLine{05591         RunContext( RunContext \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{05592         RunContext\& operator =( RunContext \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{05593 }
\DoxyCodeLine{05594         \textcolor{keyword}{explicit} RunContext( IConfigPtr \textcolor{keyword}{const}\& \_config, IStreamingReporterPtr\&\& reporter );}
\DoxyCodeLine{05595 }
\DoxyCodeLine{05596         ~RunContext() \textcolor{keyword}{override};}
\DoxyCodeLine{05597 }
\DoxyCodeLine{05598         \textcolor{keywordtype}{void} testGroupStarting( std::string \textcolor{keyword}{const}\& testSpec, std::size\_t groupIndex, std::size\_t groupsCount );}
\DoxyCodeLine{05599         \textcolor{keywordtype}{void} testGroupEnded( std::string \textcolor{keyword}{const}\& testSpec, Totals \textcolor{keyword}{const}\& totals, std::size\_t groupIndex, std::size\_t groupsCount );}
\DoxyCodeLine{05600 }
\DoxyCodeLine{05601         Totals runTest(TestCase \textcolor{keyword}{const}\& testCase);}
\DoxyCodeLine{05602 }
\DoxyCodeLine{05603         IConfigPtr config() \textcolor{keyword}{const};}
\DoxyCodeLine{05604         IStreamingReporter\& reporter() \textcolor{keyword}{const};}
\DoxyCodeLine{05605 }
\DoxyCodeLine{05606     \textcolor{keyword}{public}: \textcolor{comment}{// IResultCapture}}
\DoxyCodeLine{05607 }
\DoxyCodeLine{05608         \textcolor{comment}{// Assertion handlers}}
\DoxyCodeLine{05609         \textcolor{keywordtype}{void} handleExpr}
\DoxyCodeLine{05610                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{05611                     ITransientExpression \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{05612                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{05613         \textcolor{keywordtype}{void} handleMessage}
\DoxyCodeLine{05614                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{05615                     ResultWas::OfType resultType,}
\DoxyCodeLine{05616                     StringRef \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{05617                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{05618         \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown}
\DoxyCodeLine{05619                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{05620                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{05621         \textcolor{keywordtype}{void} handleUnexpectedInflightException}
\DoxyCodeLine{05622                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{05623                     std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{05624                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{05625         \textcolor{keywordtype}{void} handleIncomplete}
\DoxyCodeLine{05626                 (   AssertionInfo \textcolor{keyword}{const}\& info ) \textcolor{keyword}{override};}
\DoxyCodeLine{05627         \textcolor{keywordtype}{void} handleNonExpr}
\DoxyCodeLine{05628                 (   AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{05629                     ResultWas::OfType resultType,}
\DoxyCodeLine{05630                     AssertionReaction \&reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{05631 }
\DoxyCodeLine{05632         \textcolor{keywordtype}{bool} sectionStarted( SectionInfo \textcolor{keyword}{const}\& sectionInfo, Counts\& assertions ) \textcolor{keyword}{override};}
\DoxyCodeLine{05633 }
\DoxyCodeLine{05634         \textcolor{keywordtype}{void} sectionEnded( SectionEndInfo \textcolor{keyword}{const}\& endInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{05635         \textcolor{keywordtype}{void} sectionEndedEarly( SectionEndInfo \textcolor{keyword}{const}\& endInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{05636 }
\DoxyCodeLine{05637         \textcolor{keyword}{auto} acquireGeneratorTracker( SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -> IGeneratorTracker\& \textcolor{keyword}{override};}
\DoxyCodeLine{05638 }
\DoxyCodeLine{05639         \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) \textcolor{keyword}{override};}
\DoxyCodeLine{05640         \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats \textcolor{keyword}{const}\& stats ) \textcolor{keyword}{override};}
\DoxyCodeLine{05641 }
\DoxyCodeLine{05642         \textcolor{keywordtype}{void} pushScopedMessage( MessageInfo \textcolor{keyword}{const}\& message ) \textcolor{keyword}{override};}
\DoxyCodeLine{05643         \textcolor{keywordtype}{void} popScopedMessage( MessageInfo \textcolor{keyword}{const}\& message ) \textcolor{keyword}{override};}
\DoxyCodeLine{05644 }
\DoxyCodeLine{05645         std::string getCurrentTestName() \textcolor{keyword}{const override};}
\DoxyCodeLine{05646 }
\DoxyCodeLine{05647         \textcolor{keyword}{const} AssertionResult* getLastResult() \textcolor{keyword}{const override};}
\DoxyCodeLine{05648 }
\DoxyCodeLine{05649         \textcolor{keywordtype}{void} exceptionEarlyReported() \textcolor{keyword}{override};}
\DoxyCodeLine{05650 }
\DoxyCodeLine{05651         \textcolor{keywordtype}{void} handleFatalErrorCondition( StringRef message ) \textcolor{keyword}{override};}
\DoxyCodeLine{05652 }
\DoxyCodeLine{05653         \textcolor{keywordtype}{bool} lastAssertionPassed() \textcolor{keyword}{override};}
\DoxyCodeLine{05654 }
\DoxyCodeLine{05655         \textcolor{keywordtype}{void} assertionPassed() \textcolor{keyword}{override};}
\DoxyCodeLine{05656 }
\DoxyCodeLine{05657     \textcolor{keyword}{public}:}
\DoxyCodeLine{05658         \textcolor{comment}{// !TBD We need to do this another way!}}
\DoxyCodeLine{05659         \textcolor{keywordtype}{bool} aborting() const final;}
\DoxyCodeLine{05660 }
\DoxyCodeLine{05661     private:}
\DoxyCodeLine{05662 }
\DoxyCodeLine{05663         \textcolor{keywordtype}{void} runCurrentTest( std::\textcolor{keywordtype}{string}\& redirectedCout, std::\textcolor{keywordtype}{string}\& redirectedCerr );}
\DoxyCodeLine{05664         \textcolor{keywordtype}{void} invokeActiveTestCase();}
\DoxyCodeLine{05665 }
\DoxyCodeLine{05666         \textcolor{keywordtype}{void} resetAssertionInfo();}
\DoxyCodeLine{05667         \textcolor{keywordtype}{bool} testForMissingAssertions( Counts\& assertions );}
\DoxyCodeLine{05668 }
\DoxyCodeLine{05669         \textcolor{keywordtype}{void} assertionEnded( AssertionResult const\& result );}
\DoxyCodeLine{05670         \textcolor{keywordtype}{void} reportExpr}
\DoxyCodeLine{05671                 (   AssertionInfo const \&info,}
\DoxyCodeLine{05672                     ResultWas::OfType resultType,}
\DoxyCodeLine{05673                     ITransientExpression const *expr,}
\DoxyCodeLine{05674                     \textcolor{keywordtype}{bool} negated );}
\DoxyCodeLine{05675 }
\DoxyCodeLine{05676         \textcolor{keywordtype}{void} populateReaction( AssertionReaction\& reaction );}
\DoxyCodeLine{05677 }
\DoxyCodeLine{05678     private:}
\DoxyCodeLine{05679 }
\DoxyCodeLine{05680         \textcolor{keywordtype}{void} handleUnfinishedSections();}
\DoxyCodeLine{05681 }
\DoxyCodeLine{05682         TestRunInfo m\_runInfo;}
\DoxyCodeLine{05683         IMutableContext\& m\_context;}
\DoxyCodeLine{05684         TestCase const* m\_activeTestCase = \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{05685         ITracker* m\_testCaseTracker;}
\DoxyCodeLine{05686         Option<AssertionResult> m\_lastResult;}
\DoxyCodeLine{05687 }
\DoxyCodeLine{05688         IConfigPtr m\_config;}
\DoxyCodeLine{05689         Totals m\_totals;}
\DoxyCodeLine{05690         IStreamingReporterPtr m\_reporter;}
\DoxyCodeLine{05691         std::vector<MessageInfo> m\_messages;}
\DoxyCodeLine{05692         AssertionInfo m\_lastAssertionInfo;}
\DoxyCodeLine{05693         std::vector<SectionEndInfo> m\_unfinishedSections;}
\DoxyCodeLine{05694         std::vector<ITracker*> m\_activeSections;}
\DoxyCodeLine{05695         TrackerContext m\_trackerContext;}
\DoxyCodeLine{05696         \textcolor{keywordtype}{bool} m\_lastAssertionPassed = false;}
\DoxyCodeLine{05697         \textcolor{keywordtype}{bool} m\_shouldReportUnexpected = true;}
\DoxyCodeLine{05698         \textcolor{keywordtype}{bool} m\_includeSuccessfulResults;}
\DoxyCodeLine{05699     \};}
\DoxyCodeLine{05700 }
\DoxyCodeLine{05701 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{05702 }
\DoxyCodeLine{05703 \textcolor{comment}{// end catch\_run\_context.h}}
\DoxyCodeLine{05704 namespace Catch \{}
\DoxyCodeLine{05705 }
\DoxyCodeLine{05706     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{05707         \textcolor{keyword}{auto} operator <<( std::ostream\& os, ITransientExpression \textcolor{keyword}{const}\& expr ) -> std::ostream\& \{}
\DoxyCodeLine{05708             expr.streamReconstructedExpression( os );}
\DoxyCodeLine{05709             \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{05710         \}}
\DoxyCodeLine{05711     \}}
\DoxyCodeLine{05712 }
\DoxyCodeLine{05713     LazyExpression::LazyExpression( \textcolor{keywordtype}{bool} isNegated )}
\DoxyCodeLine{05714     :   m\_isNegated( isNegated )}
\DoxyCodeLine{05715     \{\}}
\DoxyCodeLine{05716 }
\DoxyCodeLine{05717     LazyExpression::LazyExpression( LazyExpression \textcolor{keyword}{const}\& other ) : m\_isNegated( other.m\_isNegated ) \{\}}
\DoxyCodeLine{05718 }
\DoxyCodeLine{05719     LazyExpression::operator bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05720         \textcolor{keywordflow}{return} m\_transientExpression != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{05721     \}}
\DoxyCodeLine{05722 }
\DoxyCodeLine{05723     \textcolor{keyword}{auto} operator << ( std::ostream\& os, LazyExpression \textcolor{keyword}{const}\& lazyExpr ) -> std::ostream\& \{}
\DoxyCodeLine{05724         \textcolor{keywordflow}{if}( lazyExpr.m\_isNegated )}
\DoxyCodeLine{05725             os << \textcolor{stringliteral}{"!"};}
\DoxyCodeLine{05726 }
\DoxyCodeLine{05727         \textcolor{keywordflow}{if}( lazyExpr ) \{}
\DoxyCodeLine{05728             \textcolor{keywordflow}{if}( lazyExpr.m\_isNegated \&\& lazyExpr.m\_transientExpression->isBinaryExpression() )}
\DoxyCodeLine{05729                 os << \textcolor{stringliteral}{"("} << *lazyExpr.m\_transientExpression << \textcolor{stringliteral}{")"};}
\DoxyCodeLine{05730             \textcolor{keywordflow}{else}}
\DoxyCodeLine{05731                 os << *lazyExpr.m\_transientExpression;}
\DoxyCodeLine{05732         \}}
\DoxyCodeLine{05733         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{05734             os << \textcolor{stringliteral}{"\{** error - unchecked empty expression requested **\}"};}
\DoxyCodeLine{05735         \}}
\DoxyCodeLine{05736         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{05737     \}}
\DoxyCodeLine{05738 }
\DoxyCodeLine{05739     AssertionHandler::AssertionHandler}
\DoxyCodeLine{05740         (   StringRef \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{05741             SourceLineInfo \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{05742             StringRef capturedExpression,}
\DoxyCodeLine{05743             ResultDisposition::Flags resultDisposition )}
\DoxyCodeLine{05744     :   m\_assertionInfo\{ macroName, lineInfo, capturedExpression, resultDisposition \},}
\DoxyCodeLine{05745         m\_resultCapture( getResultCapture() )}
\DoxyCodeLine{05746     \{\}}
\DoxyCodeLine{05747 }
\DoxyCodeLine{05748     \textcolor{keywordtype}{void} AssertionHandler::handleExpr( ITransientExpression \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{05749         m\_resultCapture.handleExpr( m\_assertionInfo, expr, m\_reaction );}
\DoxyCodeLine{05750     \}}
\DoxyCodeLine{05751     \textcolor{keywordtype}{void} AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef \textcolor{keyword}{const}\& message) \{}
\DoxyCodeLine{05752         m\_resultCapture.handleMessage( m\_assertionInfo, resultType, message, m\_reaction );}
\DoxyCodeLine{05753     \}}
\DoxyCodeLine{05754 }
\DoxyCodeLine{05755     \textcolor{keyword}{auto} AssertionHandler::allowThrows() const -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{05756         \textcolor{keywordflow}{return} getCurrentContext().getConfig()->allowThrows();}
\DoxyCodeLine{05757     \}}
\DoxyCodeLine{05758 }
\DoxyCodeLine{05759     \textcolor{keywordtype}{void} AssertionHandler::complete() \{}
\DoxyCodeLine{05760         setCompleted();}
\DoxyCodeLine{05761         \textcolor{keywordflow}{if}( m\_reaction.shouldDebugBreak ) \{}
\DoxyCodeLine{05762 }
\DoxyCodeLine{05763             \textcolor{comment}{// If you find your debugger stopping you here then go one level up on the}}
\DoxyCodeLine{05764             \textcolor{comment}{// call-stack for the code that caused it (typically a failed assertion)}}
\DoxyCodeLine{05765 }
\DoxyCodeLine{05766             \textcolor{comment}{// (To go back to the test and change execution, jump over the throw, next)}}
\DoxyCodeLine{05767             CATCH\_BREAK\_INTO\_DEBUGGER();}
\DoxyCodeLine{05768         \}}
\DoxyCodeLine{05769         \textcolor{keywordflow}{if} (m\_reaction.shouldThrow) \{}
\DoxyCodeLine{05770 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{05771             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structCatch_1_1TestFailureException}{Catch::TestFailureException}}();}
\DoxyCodeLine{05772 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{05773             CATCH\_ERROR( \textcolor{stringliteral}{"Test failure requires aborting test!"} );}
\DoxyCodeLine{05774 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05775         \}}
\DoxyCodeLine{05776     \}}
\DoxyCodeLine{05777     \textcolor{keywordtype}{void} AssertionHandler::setCompleted() \{}
\DoxyCodeLine{05778         m\_completed = \textcolor{keyword}{true};}
\DoxyCodeLine{05779     \}}
\DoxyCodeLine{05780 }
\DoxyCodeLine{05781     \textcolor{keywordtype}{void} AssertionHandler::handleUnexpectedInflightException() \{}
\DoxyCodeLine{05782         m\_resultCapture.handleUnexpectedInflightException( m\_assertionInfo, Catch::translateActiveException(), m\_reaction );}
\DoxyCodeLine{05783     \}}
\DoxyCodeLine{05784 }
\DoxyCodeLine{05785     \textcolor{keywordtype}{void} AssertionHandler::handleExceptionThrownAsExpected() \{}
\DoxyCodeLine{05786         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{05787     \}}
\DoxyCodeLine{05788     \textcolor{keywordtype}{void} AssertionHandler::handleExceptionNotThrownAsExpected() \{}
\DoxyCodeLine{05789         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{05790     \}}
\DoxyCodeLine{05791 }
\DoxyCodeLine{05792     \textcolor{keywordtype}{void} AssertionHandler::handleUnexpectedExceptionNotThrown() \{}
\DoxyCodeLine{05793         m\_resultCapture.handleUnexpectedExceptionNotThrown( m\_assertionInfo, m\_reaction );}
\DoxyCodeLine{05794     \}}
\DoxyCodeLine{05795 }
\DoxyCodeLine{05796     \textcolor{keywordtype}{void} AssertionHandler::handleThrowingCallSkipped() \{}
\DoxyCodeLine{05797         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{05798     \}}
\DoxyCodeLine{05799 }
\DoxyCodeLine{05800     \textcolor{comment}{// This is the overload that takes a string and infers the Equals matcher from it}}
\DoxyCodeLine{05801     \textcolor{comment}{// The more general overload, that takes any string matcher, is in catch\_capture\_matchers.cpp}}
\DoxyCodeLine{05802     \textcolor{keywordtype}{void} handleExceptionMatchExpr( AssertionHandler\& handler, std::string \textcolor{keyword}{const}\& str, StringRef \textcolor{keyword}{const}\& matcherString  ) \{}
\DoxyCodeLine{05803         handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );}
\DoxyCodeLine{05804     \}}
\DoxyCodeLine{05805 }
\DoxyCodeLine{05806 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{05807 \textcolor{comment}{// end catch\_assertionhandler.cpp}}
\DoxyCodeLine{05808 \textcolor{comment}{// start catch\_assertionresult.cpp}}
\DoxyCodeLine{05809 }
\DoxyCodeLine{05810 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05811     AssertionResultData::AssertionResultData(ResultWas::OfType \_resultType, LazyExpression \textcolor{keyword}{const} \& \_lazyExpression):}
\DoxyCodeLine{05812         lazyExpression(\_lazyExpression),}
\DoxyCodeLine{05813         resultType(\_resultType) \{\}}
\DoxyCodeLine{05814 }
\DoxyCodeLine{05815     std::string AssertionResultData::reconstructExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05816 }
\DoxyCodeLine{05817         \textcolor{keywordflow}{if}( reconstructedExpression.empty() ) \{}
\DoxyCodeLine{05818             \textcolor{keywordflow}{if}( lazyExpression ) \{}
\DoxyCodeLine{05819                 ReusableStringStream rss;}
\DoxyCodeLine{05820                 rss << lazyExpression;}
\DoxyCodeLine{05821                 reconstructedExpression = rss.str();}
\DoxyCodeLine{05822             \}}
\DoxyCodeLine{05823         \}}
\DoxyCodeLine{05824         \textcolor{keywordflow}{return} reconstructedExpression;}
\DoxyCodeLine{05825     \}}
\DoxyCodeLine{05826 }
\DoxyCodeLine{05827     AssertionResult::AssertionResult( AssertionInfo \textcolor{keyword}{const}\& info, AssertionResultData \textcolor{keyword}{const}\& data )}
\DoxyCodeLine{05828     :   m\_info( info ),}
\DoxyCodeLine{05829         m\_resultData( data )}
\DoxyCodeLine{05830     \{\}}
\DoxyCodeLine{05831 }
\DoxyCodeLine{05832     \textcolor{comment}{// Result was a success}}
\DoxyCodeLine{05833     \textcolor{keywordtype}{bool} AssertionResult::succeeded()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05834         \textcolor{keywordflow}{return} Catch::isOk( m\_resultData.resultType );}
\DoxyCodeLine{05835     \}}
\DoxyCodeLine{05836 }
\DoxyCodeLine{05837     \textcolor{comment}{// Result was a success, or failure is suppressed}}
\DoxyCodeLine{05838     \textcolor{keywordtype}{bool} AssertionResult::isOk()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05839         \textcolor{keywordflow}{return} Catch::isOk( m\_resultData.resultType ) || shouldSuppressFailure( m\_info.resultDisposition );}
\DoxyCodeLine{05840     \}}
\DoxyCodeLine{05841 }
\DoxyCodeLine{05842     ResultWas::OfType AssertionResult::getResultType()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05843         \textcolor{keywordflow}{return} m\_resultData.resultType;}
\DoxyCodeLine{05844     \}}
\DoxyCodeLine{05845 }
\DoxyCodeLine{05846     \textcolor{keywordtype}{bool} AssertionResult::hasExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05847         \textcolor{keywordflow}{return} m\_info.capturedExpression[0] != 0;}
\DoxyCodeLine{05848     \}}
\DoxyCodeLine{05849 }
\DoxyCodeLine{05850     \textcolor{keywordtype}{bool} AssertionResult::hasMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05851         \textcolor{keywordflow}{return} !m\_resultData.message.empty();}
\DoxyCodeLine{05852     \}}
\DoxyCodeLine{05853 }
\DoxyCodeLine{05854     std::string AssertionResult::getExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05855         \textcolor{keywordflow}{if}( isFalseTest( m\_info.resultDisposition ) )}
\DoxyCodeLine{05856             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"!("} + m\_info.capturedExpression + ")";}
\DoxyCodeLine{05857         \textcolor{keywordflow}{else}}
\DoxyCodeLine{05858             \textcolor{keywordflow}{return} m\_info.capturedExpression;}
\DoxyCodeLine{05859     \}}
\DoxyCodeLine{05860 }
\DoxyCodeLine{05861     std::string AssertionResult::getExpressionInMacro()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05862         std::string expr;}
\DoxyCodeLine{05863         \textcolor{keywordflow}{if}( m\_info.macroName[0] == 0 )}
\DoxyCodeLine{05864             expr = m\_info.capturedExpression;}
\DoxyCodeLine{05865         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{05866             expr.reserve( m\_info.macroName.size() + m\_info.capturedExpression.size() + 4 );}
\DoxyCodeLine{05867             expr += m\_info.macroName;}
\DoxyCodeLine{05868             expr += "( ";}
\DoxyCodeLine{05869             expr += m\_info.capturedExpression;}
\DoxyCodeLine{05870             expr += " )";}
\DoxyCodeLine{05871         \}}
\DoxyCodeLine{05872         \textcolor{keywordflow}{return} expr;}
\DoxyCodeLine{05873     \}}
\DoxyCodeLine{05874 }
\DoxyCodeLine{05875     \textcolor{keywordtype}{bool} AssertionResult::hasExpandedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05876         \textcolor{keywordflow}{return} hasExpression() \&\& getExpandedExpression() != getExpression();}
\DoxyCodeLine{05877     \}}
\DoxyCodeLine{05878 }
\DoxyCodeLine{05879     std::string AssertionResult::getExpandedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05880         std::string expr = m\_resultData.reconstructExpression();}
\DoxyCodeLine{05881         \textcolor{keywordflow}{return} expr.empty()}
\DoxyCodeLine{05882                 ? getExpression()}
\DoxyCodeLine{05883                 : expr;}
\DoxyCodeLine{05884     \}}
\DoxyCodeLine{05885 }
\DoxyCodeLine{05886     std::string AssertionResult::getMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05887         \textcolor{keywordflow}{return} m\_resultData.message;}
\DoxyCodeLine{05888     \}}
\DoxyCodeLine{05889     SourceLineInfo AssertionResult::getSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05890         \textcolor{keywordflow}{return} m\_info.lineInfo;}
\DoxyCodeLine{05891     \}}
\DoxyCodeLine{05892 }
\DoxyCodeLine{05893     StringRef AssertionResult::getTestMacroName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{05894         \textcolor{keywordflow}{return} m\_info.macroName;}
\DoxyCodeLine{05895     \}}
\DoxyCodeLine{05896 }
\DoxyCodeLine{05897 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{05898 \textcolor{comment}{// end catch\_assertionresult.cpp}}
\DoxyCodeLine{05899 \textcolor{comment}{// start catch\_benchmark.cpp}}
\DoxyCodeLine{05900 }
\DoxyCodeLine{05901 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05902 }
\DoxyCodeLine{05903     \textcolor{keyword}{auto} BenchmarkLooper::getResolution() -> uint64\_t \{}
\DoxyCodeLine{05904         \textcolor{keywordflow}{return} getEstimatedClockResolution() * getCurrentContext().getConfig()->benchmarkResolutionMultiple();}
\DoxyCodeLine{05905     \}}
\DoxyCodeLine{05906 }
\DoxyCodeLine{05907     \textcolor{keywordtype}{void} BenchmarkLooper::reportStart() \{}
\DoxyCodeLine{05908         getResultCapture().benchmarkStarting( \{ m\_name \} );}
\DoxyCodeLine{05909     \}}
\DoxyCodeLine{05910     \textcolor{keyword}{auto} BenchmarkLooper::needsMoreIterations() -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{05911         \textcolor{keyword}{auto} elapsed = m\_timer.getElapsedNanoseconds();}
\DoxyCodeLine{05912 }
\DoxyCodeLine{05913         \textcolor{comment}{// Exponentially increasing iterations until we're confident in our timer resolution}}
\DoxyCodeLine{05914         \textcolor{keywordflow}{if}( elapsed < m\_resolution ) \{}
\DoxyCodeLine{05915             m\_iterationsToRun *= 10;}
\DoxyCodeLine{05916             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{05917         \}}
\DoxyCodeLine{05918 }
\DoxyCodeLine{05919         getResultCapture().benchmarkEnded( \{ \{ m\_name \}, m\_count, elapsed \} );}
\DoxyCodeLine{05920         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{05921     \}}
\DoxyCodeLine{05922 }
\DoxyCodeLine{05923 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{05924 \textcolor{comment}{// end catch\_benchmark.cpp}}
\DoxyCodeLine{05925 \textcolor{comment}{// start catch\_capture\_matchers.cpp}}
\DoxyCodeLine{05926 }
\DoxyCodeLine{05927 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{05928 }
\DoxyCodeLine{05929     \textcolor{keyword}{using} StringMatcher = Matchers::Impl::MatcherBase<std::string>;}
\DoxyCodeLine{05930 }
\DoxyCodeLine{05931     \textcolor{comment}{// This is the general overload that takes a any string matcher}}
\DoxyCodeLine{05932     \textcolor{comment}{// There is another overload, in catch\_assertionhandler.h/.cpp, that only takes a string and infers}}
\DoxyCodeLine{05933     \textcolor{comment}{// the Equals matcher (so the header does not mention matchers)}}
\DoxyCodeLine{05934     \textcolor{keywordtype}{void} handleExceptionMatchExpr( AssertionHandler\& handler, StringMatcher \textcolor{keyword}{const}\& matcher, StringRef \textcolor{keyword}{const}\& matcherString  ) \{}
\DoxyCodeLine{05935         std::string exceptionMessage = Catch::translateActiveException();}
\DoxyCodeLine{05936         MatchExpr<std::string, StringMatcher const\&> expr( exceptionMessage, matcher, matcherString );}
\DoxyCodeLine{05937         handler.handleExpr( expr );}
\DoxyCodeLine{05938     \}}
\DoxyCodeLine{05939 }
\DoxyCodeLine{05940 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{05941 \textcolor{comment}{// end catch\_capture\_matchers.cpp}}
\DoxyCodeLine{05942 \textcolor{comment}{// start catch\_commandline.cpp}}
\DoxyCodeLine{05943 }
\DoxyCodeLine{05944 \textcolor{comment}{// start catch\_commandline.h}}
\DoxyCodeLine{05945 }
\DoxyCodeLine{05946 \textcolor{comment}{// start catch\_clara.h}}
\DoxyCodeLine{05947 }
\DoxyCodeLine{05948 \textcolor{comment}{// Use Catch's value for console width (store Clara's off to the side, if present)}}
\DoxyCodeLine{05949 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{05950 \textcolor{preprocessor}{\#define CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{05951 \textcolor{preprocessor}{\#undef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{05952 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05953 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_CONFIG\_CONSOLE\_WIDTH-1}}
\DoxyCodeLine{05954 }
\DoxyCodeLine{05955 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{05956 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{05957 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "-Wweak-vtables"}}
\DoxyCodeLine{05958 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "-Wexit-time-destructors"}}
\DoxyCodeLine{05959 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "-Wshadow"}}
\DoxyCodeLine{05960 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05961 }
\DoxyCodeLine{05962 \textcolor{comment}{// start clara.hpp}}
\DoxyCodeLine{05963 \textcolor{comment}{// Copyright 2017 Two Blue Cubes Ltd. All rights reserved.}}
\DoxyCodeLine{05964 \textcolor{comment}{//}}
\DoxyCodeLine{05965 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{05966 \textcolor{comment}{// file LICENSE\_1\_0.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{05967 \textcolor{comment}{//}}
\DoxyCodeLine{05968 \textcolor{comment}{// See https://github.com/philsquared/Clara for more details}}
\DoxyCodeLine{05969 }
\DoxyCodeLine{05970 \textcolor{comment}{// Clara v1.1.5}}
\DoxyCodeLine{05971 }
\DoxyCodeLine{05972 }
\DoxyCodeLine{05973 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{05974 \textcolor{preprocessor}{\#define CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{05975 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05976 }
\DoxyCodeLine{05977 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{05978 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{05979 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05980 }
\DoxyCodeLine{05981 \textcolor{preprocessor}{\#ifndef CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{05982 \textcolor{preprocessor}{\#ifdef \_\_has\_include}}
\DoxyCodeLine{05983 \textcolor{preprocessor}{\#if \_\_has\_include(<optional>) \&\& \_\_cplusplus >= 201703L}}
\DoxyCodeLine{05984 \textcolor{preprocessor}{\#include <optional>}}
\DoxyCodeLine{05985 \textcolor{preprocessor}{\#define CLARA\_CONFIG\_OPTIONAL\_TYPE std::optional}}
\DoxyCodeLine{05986 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05987 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05988 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{05989 }
\DoxyCodeLine{05990 \textcolor{comment}{// ----------- \#included from clara\_textflow.hpp -----------}}
\DoxyCodeLine{05991 }
\DoxyCodeLine{05992 \textcolor{comment}{// TextFlowCpp}}
\DoxyCodeLine{05993 \textcolor{comment}{//}}
\DoxyCodeLine{05994 \textcolor{comment}{// A single-header library for wrapping and laying out basic text, by Phil Nash}}
\DoxyCodeLine{05995 \textcolor{comment}{//}}
\DoxyCodeLine{05996 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{05997 \textcolor{comment}{// file LICENSE.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{05998 \textcolor{comment}{//}}
\DoxyCodeLine{05999 \textcolor{comment}{// This project is hosted at https://github.com/philsquared/textflowcpp}}
\DoxyCodeLine{06000 }
\DoxyCodeLine{06001 }
\DoxyCodeLine{06002 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{06003 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{06004 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{06005 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{06006 }
\DoxyCodeLine{06007 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{06008 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{06009 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{06010 }
\DoxyCodeLine{06011 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{06012 \textcolor{keyword}{namespace }clara \{}
\DoxyCodeLine{06013 \textcolor{keyword}{namespace }TextFlow \{}
\DoxyCodeLine{06014 }
\DoxyCodeLine{06015 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isWhitespace(\textcolor{keywordtype}{char} c) -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{06016     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{" \(\backslash\)t\(\backslash\)n\(\backslash\)r"};}
\DoxyCodeLine{06017     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{06018 \}}
\DoxyCodeLine{06019 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isBreakableBefore(\textcolor{keywordtype}{char} c) -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{06020     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{"[(\{<|"};}
\DoxyCodeLine{06021     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{06022 \}}
\DoxyCodeLine{06023 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isBreakableAfter(\textcolor{keywordtype}{char} c) -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{06024     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{"])\}>.,:;*+-=\&/\(\backslash\)\(\backslash\)"};}
\DoxyCodeLine{06025     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{06026 \}}
\DoxyCodeLine{06027 }
\DoxyCodeLine{06028 \textcolor{keyword}{class }Columns;}
\DoxyCodeLine{06029 }
\DoxyCodeLine{06030 \textcolor{keyword}{class }Column \{}
\DoxyCodeLine{06031     std::vector<std::string> m\_strings;}
\DoxyCodeLine{06032     \textcolor{keywordtype}{size\_t} m\_width = CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH;}
\DoxyCodeLine{06033     \textcolor{keywordtype}{size\_t} m\_indent = 0;}
\DoxyCodeLine{06034     \textcolor{keywordtype}{size\_t} m\_initialIndent = std::string::npos;}
\DoxyCodeLine{06035 }
\DoxyCodeLine{06036 \textcolor{keyword}{public}:}
\DoxyCodeLine{06037     \textcolor{keyword}{class }iterator \{}
\DoxyCodeLine{06038         \textcolor{keyword}{friend} Column;}
\DoxyCodeLine{06039 }
\DoxyCodeLine{06040         Column \textcolor{keyword}{const}\& m\_column;}
\DoxyCodeLine{06041         \textcolor{keywordtype}{size\_t} m\_stringIndex = 0;}
\DoxyCodeLine{06042         \textcolor{keywordtype}{size\_t} m\_pos = 0;}
\DoxyCodeLine{06043 }
\DoxyCodeLine{06044         \textcolor{keywordtype}{size\_t} m\_len = 0;}
\DoxyCodeLine{06045         \textcolor{keywordtype}{size\_t} m\_end = 0;}
\DoxyCodeLine{06046         \textcolor{keywordtype}{bool} m\_suffix = \textcolor{keyword}{false};}
\DoxyCodeLine{06047 }
\DoxyCodeLine{06048         iterator(Column \textcolor{keyword}{const}\& column, \textcolor{keywordtype}{size\_t} stringIndex)}
\DoxyCodeLine{06049             : m\_column(column),}
\DoxyCodeLine{06050             m\_stringIndex(stringIndex) \{\}}
\DoxyCodeLine{06051 }
\DoxyCodeLine{06052         \textcolor{keyword}{auto} line() const -> std::\textcolor{keywordtype}{string} const\& \{ \textcolor{keywordflow}{return} m\_column.m\_strings[m\_stringIndex]; \}}
\DoxyCodeLine{06053 }
\DoxyCodeLine{06054         \textcolor{keyword}{auto} isBoundary(\textcolor{keywordtype}{size\_t} at) \textcolor{keyword}{const} -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{06055             assert(at > 0);}
\DoxyCodeLine{06056             assert(at <= line().size());}
\DoxyCodeLine{06057 }
\DoxyCodeLine{06058             \textcolor{keywordflow}{return} at == line().size() ||}
\DoxyCodeLine{06059                 (isWhitespace(line()[at]) \&\& !isWhitespace(line()[at - 1])) ||}
\DoxyCodeLine{06060                 isBreakableBefore(line()[at]) ||}
\DoxyCodeLine{06061                 isBreakableAfter(line()[at - 1]);}
\DoxyCodeLine{06062         \}}
\DoxyCodeLine{06063 }
\DoxyCodeLine{06064         \textcolor{keywordtype}{void} calcLength() \{}
\DoxyCodeLine{06065             assert(m\_stringIndex < m\_column.m\_strings.size());}
\DoxyCodeLine{06066 }
\DoxyCodeLine{06067             m\_suffix = \textcolor{keyword}{false};}
\DoxyCodeLine{06068             \textcolor{keyword}{auto} width = m\_column.m\_width - indent();}
\DoxyCodeLine{06069             m\_end = m\_pos;}
\DoxyCodeLine{06070             \textcolor{keywordflow}{while} (m\_end < line().size() \&\& line()[m\_end] != \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{06071                 ++m\_end;}
\DoxyCodeLine{06072 }
\DoxyCodeLine{06073             \textcolor{keywordflow}{if} (m\_end < m\_pos + width) \{}
\DoxyCodeLine{06074                 m\_len = m\_end - m\_pos;}
\DoxyCodeLine{06075             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{06076                 \textcolor{keywordtype}{size\_t} len = width;}
\DoxyCodeLine{06077                 \textcolor{keywordflow}{while} (len > 0 \&\& !isBoundary(m\_pos + len))}
\DoxyCodeLine{06078                     --len;}
\DoxyCodeLine{06079                 \textcolor{keywordflow}{while} (len > 0 \&\& isWhitespace(line()[m\_pos + len - 1]))}
\DoxyCodeLine{06080                     --len;}
\DoxyCodeLine{06081 }
\DoxyCodeLine{06082                 \textcolor{keywordflow}{if} (len > 0) \{}
\DoxyCodeLine{06083                     m\_len = len;}
\DoxyCodeLine{06084                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{06085                     m\_suffix = \textcolor{keyword}{true};}
\DoxyCodeLine{06086                     m\_len = width - 1;}
\DoxyCodeLine{06087                 \}}
\DoxyCodeLine{06088             \}}
\DoxyCodeLine{06089         \}}
\DoxyCodeLine{06090 }
\DoxyCodeLine{06091         \textcolor{keyword}{auto} indent() const -> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{06092             \textcolor{keyword}{auto} initial = m\_pos == 0 \&\& m\_stringIndex == 0 ? m\_column.m\_initialIndent : std::string::npos;}
\DoxyCodeLine{06093             \textcolor{keywordflow}{return} initial == std::string::npos ? m\_column.m\_indent : initial;}
\DoxyCodeLine{06094         \}}
\DoxyCodeLine{06095 }
\DoxyCodeLine{06096         \textcolor{keyword}{auto} addIndentAndSuffix(std::string \textcolor{keyword}{const} \&plain) \textcolor{keyword}{const} -> std::string \{}
\DoxyCodeLine{06097             \textcolor{keywordflow}{return} std::string(indent(), \textcolor{charliteral}{' '}) + (m\_suffix ? plain + "-" : plain);}
\DoxyCodeLine{06098         \}}
\DoxyCodeLine{06099 }
\DoxyCodeLine{06100     \textcolor{keyword}{public}:}
\DoxyCodeLine{06101         \textcolor{keyword}{using} difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{06102         \textcolor{keyword}{using} value\_type = std::string;}
\DoxyCodeLine{06103         \textcolor{keyword}{using} pointer = value\_type * ;}
\DoxyCodeLine{06104         \textcolor{keyword}{using} reference = value\_type \& ;}
\DoxyCodeLine{06105         \textcolor{keyword}{using} iterator\_category = std::forward\_iterator\_tag;}
\DoxyCodeLine{06106 }
\DoxyCodeLine{06107         \textcolor{keyword}{explicit} iterator(Column \textcolor{keyword}{const}\& column) : m\_column(column) \{}
\DoxyCodeLine{06108             assert(m\_column.m\_width > m\_column.m\_indent);}
\DoxyCodeLine{06109             assert(m\_column.m\_initialIndent == std::string::npos || m\_column.m\_width > m\_column.m\_initialIndent);}
\DoxyCodeLine{06110             calcLength();}
\DoxyCodeLine{06111             \textcolor{keywordflow}{if} (m\_len == 0)}
\DoxyCodeLine{06112                 m\_stringIndex++; \textcolor{comment}{// Empty string}}
\DoxyCodeLine{06113         \}}
\DoxyCodeLine{06114 }
\DoxyCodeLine{06115         \textcolor{keyword}{auto} operator *() const -> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{06116             assert(m\_stringIndex < m\_column.m\_strings.size());}
\DoxyCodeLine{06117             assert(m\_pos <= m\_end);}
\DoxyCodeLine{06118             \textcolor{keywordflow}{return} addIndentAndSuffix(line().substr(m\_pos, m\_len));}
\DoxyCodeLine{06119         \}}
\DoxyCodeLine{06120 }
\DoxyCodeLine{06121         \textcolor{keyword}{auto} operator ++() -> iterator\& \{}
\DoxyCodeLine{06122             m\_pos += m\_len;}
\DoxyCodeLine{06123             \textcolor{keywordflow}{if} (m\_pos < line().size() \&\& line()[m\_pos] == \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{06124                 m\_pos += 1;}
\DoxyCodeLine{06125             \textcolor{keywordflow}{else}}
\DoxyCodeLine{06126                 \textcolor{keywordflow}{while} (m\_pos < line().size() \&\& isWhitespace(line()[m\_pos]))}
\DoxyCodeLine{06127                     ++m\_pos;}
\DoxyCodeLine{06128 }
\DoxyCodeLine{06129             \textcolor{keywordflow}{if} (m\_pos == line().size()) \{}
\DoxyCodeLine{06130                 m\_pos = 0;}
\DoxyCodeLine{06131                 ++m\_stringIndex;}
\DoxyCodeLine{06132             \}}
\DoxyCodeLine{06133             \textcolor{keywordflow}{if} (m\_stringIndex < m\_column.m\_strings.size())}
\DoxyCodeLine{06134                 calcLength();}
\DoxyCodeLine{06135             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{06136         \}}
\DoxyCodeLine{06137         \textcolor{keyword}{auto} operator ++(\textcolor{keywordtype}{int}) -> iterator \{}
\DoxyCodeLine{06138             iterator prev(*\textcolor{keyword}{this});}
\DoxyCodeLine{06139             operator++();}
\DoxyCodeLine{06140             \textcolor{keywordflow}{return} prev;}
\DoxyCodeLine{06141         \}}
\DoxyCodeLine{06142 }
\DoxyCodeLine{06143         \textcolor{keyword}{auto} operator ==(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{06144             \textcolor{keywordflow}{return}}
\DoxyCodeLine{06145                 m\_pos == other.m\_pos \&\&}
\DoxyCodeLine{06146                 m\_stringIndex == other.m\_stringIndex \&\&}
\DoxyCodeLine{06147                 \&m\_column == \&other.m\_column;}
\DoxyCodeLine{06148         \}}
\DoxyCodeLine{06149         \textcolor{keyword}{auto} operator !=(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{06150             \textcolor{keywordflow}{return} !operator==(other);}
\DoxyCodeLine{06151         \}}
\DoxyCodeLine{06152     \};}
\DoxyCodeLine{06153     \textcolor{keyword}{using} const\_iterator = iterator;}
\DoxyCodeLine{06154 }
\DoxyCodeLine{06155     \textcolor{keyword}{explicit} Column(std::string \textcolor{keyword}{const}\& text) \{ m\_strings.push\_back(text); \}}
\DoxyCodeLine{06156 }
\DoxyCodeLine{06157     \textcolor{keyword}{auto} width(\textcolor{keywordtype}{size\_t} newWidth) -> Column\& \{}
\DoxyCodeLine{06158         assert(newWidth > 0);}
\DoxyCodeLine{06159         m\_width = newWidth;}
\DoxyCodeLine{06160         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{06161     \}}
\DoxyCodeLine{06162     \textcolor{keyword}{auto} indent(\textcolor{keywordtype}{size\_t} newIndent) -> Column\& \{}
\DoxyCodeLine{06163         m\_indent = newIndent;}
\DoxyCodeLine{06164         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{06165     \}}
\DoxyCodeLine{06166     \textcolor{keyword}{auto} initialIndent(\textcolor{keywordtype}{size\_t} newIndent) -> Column\& \{}
\DoxyCodeLine{06167         m\_initialIndent = newIndent;}
\DoxyCodeLine{06168         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{06169     \}}
\DoxyCodeLine{06170 }
\DoxyCodeLine{06171     \textcolor{keyword}{auto} width() const -> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} m\_width; \}}
\DoxyCodeLine{06172     \textcolor{keyword}{auto} begin() const -> iterator \{ \textcolor{keywordflow}{return} iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{06173     \textcolor{keyword}{auto} end() const -> iterator \{ \textcolor{keywordflow}{return} \{ *\textcolor{keyword}{this}, m\_strings.size() \}; \}}
\DoxyCodeLine{06174 }
\DoxyCodeLine{06175     \textcolor{keyword}{inline} \textcolor{keyword}{friend} std::ostream\& operator << (std::ostream\& os, Column \textcolor{keyword}{const}\& col) \{}
\DoxyCodeLine{06176         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{06177         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : col) \{}
\DoxyCodeLine{06178             \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{06179                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{06180             \textcolor{keywordflow}{else}}
\DoxyCodeLine{06181                 os << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{06182             os << line;}
\DoxyCodeLine{06183         \}}
\DoxyCodeLine{06184         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{06185     \}}
\DoxyCodeLine{06186 }
\DoxyCodeLine{06187     \textcolor{keyword}{auto} operator + (Column \textcolor{keyword}{const}\& other)->Columns;}
\DoxyCodeLine{06188 }
\DoxyCodeLine{06189     \textcolor{keyword}{auto} toString() const -> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{06190         std::ostringstream oss;}
\DoxyCodeLine{06191         oss << *\textcolor{keyword}{this};}
\DoxyCodeLine{06192         \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{06193     \}}
\DoxyCodeLine{06194 \};}
\DoxyCodeLine{06195 }
\DoxyCodeLine{06196 \textcolor{keyword}{class }Spacer : \textcolor{keyword}{public} Column \{}
\DoxyCodeLine{06197 }
\DoxyCodeLine{06198 \textcolor{keyword}{public}:}
\DoxyCodeLine{06199     \textcolor{keyword}{explicit} Spacer(\textcolor{keywordtype}{size\_t} spaceWidth) : Column(\textcolor{stringliteral}{""}) \{}
\DoxyCodeLine{06200         width(spaceWidth);}
\DoxyCodeLine{06201     \}}
\DoxyCodeLine{06202 \};}
\DoxyCodeLine{06203 }
\DoxyCodeLine{06204 \textcolor{keyword}{class }Columns \{}
\DoxyCodeLine{06205     std::vector<Column> m\_columns;}
\DoxyCodeLine{06206 }
\DoxyCodeLine{06207 \textcolor{keyword}{public}:}
\DoxyCodeLine{06208 }
\DoxyCodeLine{06209     \textcolor{keyword}{class }iterator \{}
\DoxyCodeLine{06210         \textcolor{keyword}{friend} Columns;}
\DoxyCodeLine{06211         \textcolor{keyword}{struct }EndTag \{\};}
\DoxyCodeLine{06212 }
\DoxyCodeLine{06213         std::vector<Column> \textcolor{keyword}{const}\& m\_columns;}
\DoxyCodeLine{06214         std::vector<Column::iterator> m\_iterators;}
\DoxyCodeLine{06215         \textcolor{keywordtype}{size\_t} m\_activeIterators;}
\DoxyCodeLine{06216 }
\DoxyCodeLine{06217         iterator(Columns \textcolor{keyword}{const}\& columns, EndTag)}
\DoxyCodeLine{06218             : m\_columns(columns.m\_columns),}
\DoxyCodeLine{06219             m\_activeIterators(0) \{}
\DoxyCodeLine{06220             m\_iterators.reserve(m\_columns.size());}
\DoxyCodeLine{06221 }
\DoxyCodeLine{06222             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& col : m\_columns)}
\DoxyCodeLine{06223                 m\_iterators.push\_back(col.end());}
\DoxyCodeLine{06224         \}}
\DoxyCodeLine{06225 }
\DoxyCodeLine{06226     \textcolor{keyword}{public}:}
\DoxyCodeLine{06227         \textcolor{keyword}{using} difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{06228         \textcolor{keyword}{using} value\_type = std::string;}
\DoxyCodeLine{06229         \textcolor{keyword}{using} pointer = value\_type * ;}
\DoxyCodeLine{06230         \textcolor{keyword}{using} reference = value\_type \& ;}
\DoxyCodeLine{06231         \textcolor{keyword}{using} iterator\_category = std::forward\_iterator\_tag;}
\DoxyCodeLine{06232 }
\DoxyCodeLine{06233         \textcolor{keyword}{explicit} iterator(Columns \textcolor{keyword}{const}\& columns)}
\DoxyCodeLine{06234             : m\_columns(columns.m\_columns),}
\DoxyCodeLine{06235             m\_activeIterators(m\_columns.size()) \{}
\DoxyCodeLine{06236             m\_iterators.reserve(m\_columns.size());}
\DoxyCodeLine{06237 }
\DoxyCodeLine{06238             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& col : m\_columns)}
\DoxyCodeLine{06239                 m\_iterators.push\_back(col.begin());}
\DoxyCodeLine{06240         \}}
\DoxyCodeLine{06241 }
\DoxyCodeLine{06242         \textcolor{keyword}{auto} operator ==(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{06243             \textcolor{keywordflow}{return} m\_iterators == other.m\_iterators;}
\DoxyCodeLine{06244         \}}
\DoxyCodeLine{06245         \textcolor{keyword}{auto} operator !=(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{06246             \textcolor{keywordflow}{return} m\_iterators != other.m\_iterators;}
\DoxyCodeLine{06247         \}}
\DoxyCodeLine{06248         \textcolor{keyword}{auto} operator *() const -> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{06249             std::string row, padding;}
\DoxyCodeLine{06250 }
\DoxyCodeLine{06251             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < m\_columns.size(); ++i) \{}
\DoxyCodeLine{06252                 \textcolor{keyword}{auto} width = m\_columns[i].width();}
\DoxyCodeLine{06253                 \textcolor{keywordflow}{if} (m\_iterators[i] != m\_columns[i].end()) \{}
\DoxyCodeLine{06254                     std::string col = *m\_iterators[i];}
\DoxyCodeLine{06255                     row += padding + col;}
\DoxyCodeLine{06256                     \textcolor{keywordflow}{if} (col.size() < width)}
\DoxyCodeLine{06257                         padding = std::string(width - col.size(), \textcolor{charliteral}{' '});}
\DoxyCodeLine{06258                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{06259                         padding = \textcolor{stringliteral}{""};}
\DoxyCodeLine{06260                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{06261                     padding += std::string(width, ' ');}
\DoxyCodeLine{06262                 \}}
\DoxyCodeLine{06263             \}}
\DoxyCodeLine{06264             \textcolor{keywordflow}{return} row;}
\DoxyCodeLine{06265         \}}
\DoxyCodeLine{06266         \textcolor{keyword}{auto} operator ++() -> iterator\& \{}
\DoxyCodeLine{06267             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < m\_columns.size(); ++i) \{}
\DoxyCodeLine{06268                 \textcolor{keywordflow}{if} (m\_iterators[i] != m\_columns[i].end())}
\DoxyCodeLine{06269                     ++m\_iterators[i];}
\DoxyCodeLine{06270             \}}
\DoxyCodeLine{06271             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{06272         \}}
\DoxyCodeLine{06273         \textcolor{keyword}{auto} operator ++(\textcolor{keywordtype}{int}) -> iterator \{}
\DoxyCodeLine{06274             iterator prev(*\textcolor{keyword}{this});}
\DoxyCodeLine{06275             operator++();}
\DoxyCodeLine{06276             \textcolor{keywordflow}{return} prev;}
\DoxyCodeLine{06277         \}}
\DoxyCodeLine{06278     \};}
\DoxyCodeLine{06279     \textcolor{keyword}{using} const\_iterator = iterator;}
\DoxyCodeLine{06280 }
\DoxyCodeLine{06281     \textcolor{keyword}{auto} begin() const -> iterator \{ \textcolor{keywordflow}{return} iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{06282     \textcolor{keyword}{auto} end() const -> iterator \{ \textcolor{keywordflow}{return} \{ *\textcolor{keyword}{this}, iterator::EndTag() \}; \}}
\DoxyCodeLine{06283 }
\DoxyCodeLine{06284     \textcolor{keyword}{auto} operator += (Column \textcolor{keyword}{const}\& col) -> Columns\& \{}
\DoxyCodeLine{06285         m\_columns.push\_back(col);}
\DoxyCodeLine{06286         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{06287     \}}
\DoxyCodeLine{06288     \textcolor{keyword}{auto} operator + (Column \textcolor{keyword}{const}\& col) -> Columns \{}
\DoxyCodeLine{06289         Columns combined = *\textcolor{keyword}{this};}
\DoxyCodeLine{06290         combined += col;}
\DoxyCodeLine{06291         \textcolor{keywordflow}{return} combined;}
\DoxyCodeLine{06292     \}}
\DoxyCodeLine{06293 }
\DoxyCodeLine{06294     \textcolor{keyword}{inline} \textcolor{keyword}{friend} std::ostream\& operator << (std::ostream\& os, Columns \textcolor{keyword}{const}\& cols) \{}
\DoxyCodeLine{06295 }
\DoxyCodeLine{06296         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{06297         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : cols) \{}
\DoxyCodeLine{06298             \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{06299                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{06300             \textcolor{keywordflow}{else}}
\DoxyCodeLine{06301                 os << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{06302             os << line;}
\DoxyCodeLine{06303         \}}
\DoxyCodeLine{06304         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{06305     \}}
\DoxyCodeLine{06306 }
\DoxyCodeLine{06307     \textcolor{keyword}{auto} toString() const -> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{06308         std::ostringstream oss;}
\DoxyCodeLine{06309         oss << *\textcolor{keyword}{this};}
\DoxyCodeLine{06310         \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{06311     \}}
\DoxyCodeLine{06312 \};}
\DoxyCodeLine{06313 }
\DoxyCodeLine{06314 \textcolor{keyword}{inline} \textcolor{keyword}{auto} Column::operator + (Column \textcolor{keyword}{const}\& other) -> Columns \{}
\DoxyCodeLine{06315     Columns cols;}
\DoxyCodeLine{06316     cols += *this;}
\DoxyCodeLine{06317     cols += other;}
\DoxyCodeLine{06318     \textcolor{keywordflow}{return} cols;}
\DoxyCodeLine{06319 \}}
\DoxyCodeLine{06320 \}}
\DoxyCodeLine{06321 }
\DoxyCodeLine{06322 \}}
\DoxyCodeLine{06323 \}}
\DoxyCodeLine{06324 }
\DoxyCodeLine{06325 \textcolor{comment}{// ----------- end of \#include from clara\_textflow.hpp -----------}}
\DoxyCodeLine{06326 \textcolor{comment}{// ........... back in clara.hpp}}
\DoxyCodeLine{06327 }
\DoxyCodeLine{06328 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{06329 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{06330 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{06331 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{06332 }
\DoxyCodeLine{06333 \textcolor{preprocessor}{\#if !defined(CATCH\_PLATFORM\_WINDOWS) \&\& ( defined(WIN32) || defined(\_\_WIN32\_\_) || defined(\_WIN32) || defined(\_MSC\_VER) )}}
\DoxyCodeLine{06334 \textcolor{preprocessor}{\#define CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{06335 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{06336 }
\DoxyCodeLine{06337 \textcolor{keyword}{namespace }Catch \{ \textcolor{keyword}{namespace }clara \{}
\DoxyCodeLine{06338 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{06339 }
\DoxyCodeLine{06340     \textcolor{comment}{// Traits for extracting arg and return type of lambdas (for single argument lambdas)}}
\DoxyCodeLine{06341     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{06342     \textcolor{keyword}{struct }UnaryLambdaTraits : UnaryLambdaTraits<decltype( \&L::operator() )> \{\};}
\DoxyCodeLine{06343 }
\DoxyCodeLine{06344     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ClassT, \textcolor{keyword}{typename} ReturnT, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{06345     \textcolor{keyword}{struct }UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> \{}
\DoxyCodeLine{06346         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isValid = \textcolor{keyword}{false};}
\DoxyCodeLine{06347     \};}
\DoxyCodeLine{06348 }
\DoxyCodeLine{06349     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ClassT, \textcolor{keyword}{typename} ReturnT, \textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{06350     \textcolor{keyword}{struct }UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> \{}
\DoxyCodeLine{06351         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isValid = \textcolor{keyword}{true};}
\DoxyCodeLine{06352         \textcolor{keyword}{using} ArgType = \textcolor{keyword}{typename} std::remove\_const<typename std::remove\_reference<ArgT>::type>::type;}
\DoxyCodeLine{06353         \textcolor{keyword}{using} ReturnType = ReturnT;}
\DoxyCodeLine{06354     \};}
\DoxyCodeLine{06355 }
\DoxyCodeLine{06356     \textcolor{keyword}{class }TokenStream;}
\DoxyCodeLine{06357 }
\DoxyCodeLine{06358     \textcolor{comment}{// Transport for raw args (copied from main args, or supplied via init list for testing)}}
\DoxyCodeLine{06359     \textcolor{keyword}{class }Args \{}
\DoxyCodeLine{06360         \textcolor{keyword}{friend} TokenStream;}
\DoxyCodeLine{06361         std::string m\_exeName;}
\DoxyCodeLine{06362         std::vector<std::string> m\_args;}
\DoxyCodeLine{06363 }
\DoxyCodeLine{06364     \textcolor{keyword}{public}:}
\DoxyCodeLine{06365         Args( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \textcolor{keyword}{const}* argv )}
\DoxyCodeLine{06366             : m\_exeName(argv[0]),}
\DoxyCodeLine{06367               m\_args(argv + 1, argv + argc) \{\}}
\DoxyCodeLine{06368 }
\DoxyCodeLine{06369         Args( std::initializer\_list<std::string> args )}
\DoxyCodeLine{06370         :   m\_exeName( *args.begin() ),}
\DoxyCodeLine{06371             m\_args( args.begin()+1, args.end() )}
\DoxyCodeLine{06372         \{\}}
\DoxyCodeLine{06373 }
\DoxyCodeLine{06374         \textcolor{keyword}{auto} exeName() const -> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{06375             \textcolor{keywordflow}{return} m\_exeName;}
\DoxyCodeLine{06376         \}}
\DoxyCodeLine{06377     \};}
\DoxyCodeLine{06378 }
\DoxyCodeLine{06379     \textcolor{comment}{// Wraps a token coming from a token stream. These may not directly correspond to strings as a single string}}
\DoxyCodeLine{06380     \textcolor{comment}{// may encode an option + its argument if the : or = form is used}}
\DoxyCodeLine{06381     \textcolor{keyword}{enum class} TokenType \{}
\DoxyCodeLine{06382         Option, Argument}
\DoxyCodeLine{06383     \};}
\DoxyCodeLine{06384     \textcolor{keyword}{struct }Token \{}
\DoxyCodeLine{06385         TokenType type;}
\DoxyCodeLine{06386         std::string token;}
\DoxyCodeLine{06387     \};}
\DoxyCodeLine{06388 }
\DoxyCodeLine{06389     \textcolor{keyword}{inline} \textcolor{keyword}{auto} isOptPrefix( \textcolor{keywordtype}{char} c ) -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{06390         \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'-'}}
\DoxyCodeLine{06391 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{06392             || c == \textcolor{charliteral}{'/'}}
\DoxyCodeLine{06393 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{06394         ;}
\DoxyCodeLine{06395     \}}
\DoxyCodeLine{06396 }
\DoxyCodeLine{06397     \textcolor{comment}{// Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled}}
\DoxyCodeLine{06398     \textcolor{keyword}{class }TokenStream \{}
\DoxyCodeLine{06399         \textcolor{keyword}{using} Iterator = std::vector<std::string>::const\_iterator;}
\DoxyCodeLine{06400         Iterator it;}
\DoxyCodeLine{06401         Iterator itEnd;}
\DoxyCodeLine{06402         std::vector<Token> m\_tokenBuffer;}
\DoxyCodeLine{06403 }
\DoxyCodeLine{06404         \textcolor{keywordtype}{void} loadBuffer() \{}
\DoxyCodeLine{06405             m\_tokenBuffer.resize( 0 );}
\DoxyCodeLine{06406 }
\DoxyCodeLine{06407             \textcolor{comment}{// Skip any empty strings}}
\DoxyCodeLine{06408             \textcolor{keywordflow}{while}( it != itEnd \&\& it->empty() )}
\DoxyCodeLine{06409                 ++it;}
\DoxyCodeLine{06410 }
\DoxyCodeLine{06411             \textcolor{keywordflow}{if}( it != itEnd ) \{}
\DoxyCodeLine{06412                 \textcolor{keyword}{auto} \textcolor{keyword}{const} \&next = *it;}
\DoxyCodeLine{06413                 \textcolor{keywordflow}{if}( isOptPrefix( next[0] ) ) \{}
\DoxyCodeLine{06414                     \textcolor{keyword}{auto} delimiterPos = next.find\_first\_of( \textcolor{stringliteral}{" :="} );}
\DoxyCodeLine{06415                     \textcolor{keywordflow}{if}( delimiterPos != std::string::npos ) \{}
\DoxyCodeLine{06416                         m\_tokenBuffer.push\_back( \{ TokenType::Option, next.substr( 0, delimiterPos ) \} );}
\DoxyCodeLine{06417                         m\_tokenBuffer.push\_back( \{ TokenType::Argument, next.substr( delimiterPos + 1 ) \} );}
\DoxyCodeLine{06418                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{06419                         \textcolor{keywordflow}{if}( next[1] != \textcolor{charliteral}{'-'} \&\& next.size() > 2 ) \{}
\DoxyCodeLine{06420                             std::string opt = \textcolor{stringliteral}{"- "};}
\DoxyCodeLine{06421                             \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 1; i < next.size(); ++i ) \{}
\DoxyCodeLine{06422                                 opt[1] = next[i];}
\DoxyCodeLine{06423                                 m\_tokenBuffer.push\_back( \{ TokenType::Option, opt \} );}
\DoxyCodeLine{06424                             \}}
\DoxyCodeLine{06425                         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{06426                             m\_tokenBuffer.push\_back( \{ TokenType::Option, next \} );}
\DoxyCodeLine{06427                         \}}
\DoxyCodeLine{06428                     \}}
\DoxyCodeLine{06429                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{06430                     m\_tokenBuffer.push\_back( \{ TokenType::Argument, next \} );}
\DoxyCodeLine{06431                 \}}
\DoxyCodeLine{06432             \}}
\DoxyCodeLine{06433         \}}
\DoxyCodeLine{06434 }
\DoxyCodeLine{06435     \textcolor{keyword}{public}:}
\DoxyCodeLine{06436         \textcolor{keyword}{explicit} TokenStream( Args \textcolor{keyword}{const} \&args ) : TokenStream( args.m\_args.begin(), args.m\_args.end() ) \{\}}
\DoxyCodeLine{06437 }
\DoxyCodeLine{06438         TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) \{}
\DoxyCodeLine{06439             loadBuffer();}
\DoxyCodeLine{06440         \}}
\DoxyCodeLine{06441 }
\DoxyCodeLine{06442         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{06443             \textcolor{keywordflow}{return} !m\_tokenBuffer.empty() || it != itEnd;}
\DoxyCodeLine{06444         \}}
\DoxyCodeLine{06445 }
\DoxyCodeLine{06446         \textcolor{keyword}{auto} count() const -> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} m\_tokenBuffer.size() + (itEnd - it); \}}
\DoxyCodeLine{06447 }
\DoxyCodeLine{06448         \textcolor{keyword}{auto} operator*() const -> Token \{}
\DoxyCodeLine{06449             assert( !m\_tokenBuffer.empty() );}
\DoxyCodeLine{06450             \textcolor{keywordflow}{return} m\_tokenBuffer.front();}
\DoxyCodeLine{06451         \}}
\DoxyCodeLine{06452 }
\DoxyCodeLine{06453         \textcolor{keyword}{auto} operator->() const -> Token const * \{}
\DoxyCodeLine{06454             assert( !m\_tokenBuffer.empty() );}
\DoxyCodeLine{06455             \textcolor{keywordflow}{return} \&m\_tokenBuffer.front();}
\DoxyCodeLine{06456         \}}
\DoxyCodeLine{06457 }
\DoxyCodeLine{06458         \textcolor{keyword}{auto} operator++() -> TokenStream \& \{}
\DoxyCodeLine{06459             \textcolor{keywordflow}{if}( m\_tokenBuffer.size() >= 2 ) \{}
\DoxyCodeLine{06460                 m\_tokenBuffer.erase( m\_tokenBuffer.begin() );}
\DoxyCodeLine{06461             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{06462                 \textcolor{keywordflow}{if}( it != itEnd )}
\DoxyCodeLine{06463                     ++it;}
\DoxyCodeLine{06464                 loadBuffer();}
\DoxyCodeLine{06465             \}}
\DoxyCodeLine{06466             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{06467         \}}
\DoxyCodeLine{06468     \};}
\DoxyCodeLine{06469 }
\DoxyCodeLine{06470     \textcolor{keyword}{class }ResultBase \{}
\DoxyCodeLine{06471     \textcolor{keyword}{public}:}
\DoxyCodeLine{06472         \textcolor{keyword}{enum} Type \{}
\DoxyCodeLine{06473             Ok, LogicError, RuntimeError}
\DoxyCodeLine{06474         \};}
\DoxyCodeLine{06475 }
\DoxyCodeLine{06476     \textcolor{keyword}{protected}:}
\DoxyCodeLine{06477         ResultBase( Type type ) : m\_type( type ) \{\}}
\DoxyCodeLine{06478         \textcolor{keyword}{virtual} ~ResultBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{06479 }
\DoxyCodeLine{06480         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} enforceOk() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{06481 }
\DoxyCodeLine{06482         Type m\_type;}
\DoxyCodeLine{06483     \};}
\DoxyCodeLine{06484 }
\DoxyCodeLine{06485     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{06486     \textcolor{keyword}{class }ResultValueBase : \textcolor{keyword}{public} ResultBase \{}
\DoxyCodeLine{06487     \textcolor{keyword}{public}:}
\DoxyCodeLine{06488         \textcolor{keyword}{auto} value() const -> T const \& \{}
\DoxyCodeLine{06489             enforceOk();}
\DoxyCodeLine{06490             \textcolor{keywordflow}{return} m\_value;}
\DoxyCodeLine{06491         \}}
\DoxyCodeLine{06492 }
\DoxyCodeLine{06493     \textcolor{keyword}{protected}:}
\DoxyCodeLine{06494         ResultValueBase( Type type ) : ResultBase( type ) \{\}}
\DoxyCodeLine{06495 }
\DoxyCodeLine{06496         ResultValueBase( ResultValueBase \textcolor{keyword}{const} \&other ) : ResultBase( other ) \{}
\DoxyCodeLine{06497             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{06498                 \textcolor{keyword}{new}( \&m\_value ) T( other.m\_value );}
\DoxyCodeLine{06499         \}}
\DoxyCodeLine{06500 }
\DoxyCodeLine{06501         ResultValueBase( Type, T \textcolor{keyword}{const} \&value ) : ResultBase( Ok ) \{}
\DoxyCodeLine{06502             \textcolor{keyword}{new}( \&m\_value ) T( value );}
\DoxyCodeLine{06503         \}}
\DoxyCodeLine{06504 }
\DoxyCodeLine{06505         \textcolor{keyword}{auto} operator=( ResultValueBase \textcolor{keyword}{const} \&other ) -> ResultValueBase \& \{}
\DoxyCodeLine{06506             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{06507                 m\_value.~T();}
\DoxyCodeLine{06508             ResultBase::operator=(other);}
\DoxyCodeLine{06509             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{06510                 \textcolor{keyword}{new}( \&m\_value ) T( other.m\_value );}
\DoxyCodeLine{06511             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{06512         \}}
\DoxyCodeLine{06513 }
\DoxyCodeLine{06514         ~ResultValueBase()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{06515             \textcolor{keywordflow}{if}( m\_type == Ok )}
\DoxyCodeLine{06516                 m\_value.~T();}
\DoxyCodeLine{06517         \}}
\DoxyCodeLine{06518 }
\DoxyCodeLine{06519         \textcolor{keyword}{union }\{}
\DoxyCodeLine{06520             T m\_value;}
\DoxyCodeLine{06521         \};}
\DoxyCodeLine{06522     \};}
\DoxyCodeLine{06523 }
\DoxyCodeLine{06524     \textcolor{keyword}{template}<>}
\DoxyCodeLine{06525     \textcolor{keyword}{class }ResultValueBase<void> : \textcolor{keyword}{public} ResultBase \{}
\DoxyCodeLine{06526     \textcolor{keyword}{protected}:}
\DoxyCodeLine{06527         \textcolor{keyword}{using} ResultBase::ResultBase;}
\DoxyCodeLine{06528     \};}
\DoxyCodeLine{06529 }
\DoxyCodeLine{06530     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{06531     \textcolor{keyword}{class }BasicResult : \textcolor{keyword}{public} ResultValueBase<T> \{}
\DoxyCodeLine{06532     \textcolor{keyword}{public}:}
\DoxyCodeLine{06533         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{06534         \textcolor{keyword}{explicit} BasicResult( BasicResult<U> \textcolor{keyword}{const} \&other )}
\DoxyCodeLine{06535         :   ResultValueBase<T>( other.type() ),}
\DoxyCodeLine{06536             m\_errorMessage( other.errorMessage() )}
\DoxyCodeLine{06537         \{}
\DoxyCodeLine{06538             assert( type() != ResultBase::Ok );}
\DoxyCodeLine{06539         \}}
\DoxyCodeLine{06540 }
\DoxyCodeLine{06541         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{06542         \textcolor{keyword}{static} \textcolor{keyword}{auto} ok( U \textcolor{keyword}{const} \&value ) -> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::Ok, value \}; \}}
\DoxyCodeLine{06543         \textcolor{keyword}{static} \textcolor{keyword}{auto} ok() -> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::Ok \}; \}}
\DoxyCodeLine{06544         \textcolor{keyword}{static} \textcolor{keyword}{auto} logicError( std::string \textcolor{keyword}{const} \&message ) -> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::LogicError, message \}; \}}
\DoxyCodeLine{06545         \textcolor{keyword}{static} \textcolor{keyword}{auto} runtimeError( std::string \textcolor{keyword}{const} \&message ) -> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::RuntimeError, message \}; \}}
\DoxyCodeLine{06546 }
\DoxyCodeLine{06547         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_type == ResultBase::Ok; \}}
\DoxyCodeLine{06548         \textcolor{keyword}{auto} type() const -> ResultBase::Type \{ \textcolor{keywordflow}{return} m\_type; \}}
\DoxyCodeLine{06549         \textcolor{keyword}{auto} errorMessage() const -> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_errorMessage; \}}
\DoxyCodeLine{06550 }
\DoxyCodeLine{06551     \textcolor{keyword}{protected}:}
\DoxyCodeLine{06552         \textcolor{keywordtype}{void} enforceOk()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{06553 }
\DoxyCodeLine{06554             \textcolor{comment}{// Errors shouldn't reach this point, but if they do}}
\DoxyCodeLine{06555             \textcolor{comment}{// the actual error message will be in m\_errorMessage}}
\DoxyCodeLine{06556             assert( m\_type != ResultBase::LogicError );}
\DoxyCodeLine{06557             assert( m\_type != ResultBase::RuntimeError );}
\DoxyCodeLine{06558             \textcolor{keywordflow}{if}( m\_type != ResultBase::Ok )}
\DoxyCodeLine{06559                 std::abort();}
\DoxyCodeLine{06560         \}}
\DoxyCodeLine{06561 }
\DoxyCodeLine{06562         std::string m\_errorMessage; \textcolor{comment}{// Only populated if resultType is an error}}
\DoxyCodeLine{06563 }
\DoxyCodeLine{06564         BasicResult( ResultBase::Type type, std::string \textcolor{keyword}{const} \&message )}
\DoxyCodeLine{06565         :   ResultValueBase<T>(type),}
\DoxyCodeLine{06566             m\_errorMessage(message)}
\DoxyCodeLine{06567         \{}
\DoxyCodeLine{06568             assert( m\_type != ResultBase::Ok );}
\DoxyCodeLine{06569         \}}
\DoxyCodeLine{06570 }
\DoxyCodeLine{06571         \textcolor{keyword}{using} ResultValueBase<T>::ResultValueBase;}
\DoxyCodeLine{06572         \textcolor{keyword}{using} ResultBase::m\_type;}
\DoxyCodeLine{06573     \};}
\DoxyCodeLine{06574 }
\DoxyCodeLine{06575     \textcolor{keyword}{enum class} ParseResultType \{}
\DoxyCodeLine{06576         Matched, NoMatch, ShortCircuitAll, ShortCircuitSame}
\DoxyCodeLine{06577     \};}
\DoxyCodeLine{06578 }
\DoxyCodeLine{06579     \textcolor{keyword}{class }ParseState \{}
\DoxyCodeLine{06580     \textcolor{keyword}{public}:}
\DoxyCodeLine{06581 }
\DoxyCodeLine{06582         ParseState( ParseResultType type, TokenStream \textcolor{keyword}{const} \&remainingTokens )}
\DoxyCodeLine{06583         : m\_type(type),}
\DoxyCodeLine{06584           m\_remainingTokens( remainingTokens )}
\DoxyCodeLine{06585         \{\}}
\DoxyCodeLine{06586 }
\DoxyCodeLine{06587         \textcolor{keyword}{auto} type() const -> ParseResultType \{ \textcolor{keywordflow}{return} m\_type; \}}
\DoxyCodeLine{06588         \textcolor{keyword}{auto} remainingTokens() const -> TokenStream \{ \textcolor{keywordflow}{return} m\_remainingTokens; \}}
\DoxyCodeLine{06589 }
\DoxyCodeLine{06590     \textcolor{keyword}{private}:}
\DoxyCodeLine{06591         ParseResultType m\_type;}
\DoxyCodeLine{06592         TokenStream m\_remainingTokens;}
\DoxyCodeLine{06593     \};}
\DoxyCodeLine{06594 }
\DoxyCodeLine{06595     \textcolor{keyword}{using} Result = BasicResult<void>;}
\DoxyCodeLine{06596     \textcolor{keyword}{using} ParserResult = BasicResult<ParseResultType>;}
\DoxyCodeLine{06597     \textcolor{keyword}{using} InternalParseResult = BasicResult<ParseState>;}
\DoxyCodeLine{06598 }
\DoxyCodeLine{06599     \textcolor{keyword}{struct }HelpColumns \{}
\DoxyCodeLine{06600         std::string left;}
\DoxyCodeLine{06601         std::string right;}
\DoxyCodeLine{06602     \};}
\DoxyCodeLine{06603 }
\DoxyCodeLine{06604     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{06605     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, T\& target ) -> ParserResult \{}
\DoxyCodeLine{06606         std::stringstream ss;}
\DoxyCodeLine{06607         ss << source;}
\DoxyCodeLine{06608         ss >> target;}
\DoxyCodeLine{06609         \textcolor{keywordflow}{if}( ss.fail() )}
\DoxyCodeLine{06610             \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"Unable to convert '"} + source + \textcolor{stringliteral}{"' to destination type"} );}
\DoxyCodeLine{06611         \textcolor{keywordflow}{else}}
\DoxyCodeLine{06612             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{06613     \}}
\DoxyCodeLine{06614     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, std::string\& target ) -> ParserResult \{}
\DoxyCodeLine{06615         target = source;}
\DoxyCodeLine{06616         \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{06617     \}}
\DoxyCodeLine{06618     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, \textcolor{keywordtype}{bool} \&target ) -> ParserResult \{}
\DoxyCodeLine{06619         std::string srcLC = source;}
\DoxyCodeLine{06620         std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( \textcolor{keywordtype}{char} c ) \{ \textcolor{keywordflow}{return} static\_cast<char>( ::tolower(c) ); \} );}
\DoxyCodeLine{06621         \textcolor{keywordflow}{if} (srcLC == \textcolor{stringliteral}{"y"} || srcLC == \textcolor{stringliteral}{"1"} || srcLC == \textcolor{stringliteral}{"true"} || srcLC == \textcolor{stringliteral}{"yes"} || srcLC == \textcolor{stringliteral}{"on"})}
\DoxyCodeLine{06622             target = \textcolor{keyword}{true};}
\DoxyCodeLine{06623         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (srcLC == \textcolor{stringliteral}{"n"} || srcLC == \textcolor{stringliteral}{"0"} || srcLC == \textcolor{stringliteral}{"false"} || srcLC == \textcolor{stringliteral}{"no"} || srcLC == \textcolor{stringliteral}{"off"})}
\DoxyCodeLine{06624             target = \textcolor{keyword}{false};}
\DoxyCodeLine{06625         \textcolor{keywordflow}{else}}
\DoxyCodeLine{06626             \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"Expected a boolean value but did not recognise: '"} + source + \textcolor{stringliteral}{"'"} );}
\DoxyCodeLine{06627         \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{06628     \}}
\DoxyCodeLine{06629 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{06630     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{06631     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, CLARA\_CONFIG\_OPTIONAL\_TYPE<T>\& target ) -> ParserResult \{}
\DoxyCodeLine{06632         T temp;}
\DoxyCodeLine{06633         \textcolor{keyword}{auto} result = convertInto( source, temp );}
\DoxyCodeLine{06634         \textcolor{keywordflow}{if}( result )}
\DoxyCodeLine{06635             target = std::move(temp);}
\DoxyCodeLine{06636         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{06637     \}}
\DoxyCodeLine{06638 \textcolor{preprocessor}{\#endif // CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{06639 }
\DoxyCodeLine{06640     \textcolor{keyword}{struct }NonCopyable \{}
\DoxyCodeLine{06641         NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{06642         NonCopyable( NonCopyable \textcolor{keyword}{const} \& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{06643         NonCopyable( NonCopyable \&\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{06644         NonCopyable \&operator=( NonCopyable \textcolor{keyword}{const} \& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{06645         NonCopyable \&operator=( NonCopyable \&\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{06646     \};}
\DoxyCodeLine{06647 }
\DoxyCodeLine{06648     \textcolor{keyword}{struct }BoundRef : NonCopyable \{}
\DoxyCodeLine{06649         \textcolor{keyword}{virtual} ~BoundRef() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{06650         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isContainer() const -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{06651         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isFlag() const -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{06652     \};}
\DoxyCodeLine{06653     \textcolor{keyword}{struct }BoundValueRefBase : BoundRef \{}
\DoxyCodeLine{06654         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -> ParserResult = 0;}
\DoxyCodeLine{06655     \};}
\DoxyCodeLine{06656     \textcolor{keyword}{struct }BoundFlagRefBase : BoundRef \{}
\DoxyCodeLine{06657         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -> ParserResult = 0;}
\DoxyCodeLine{06658         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isFlag() const -> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{06659     \};}
\DoxyCodeLine{06660 }
\DoxyCodeLine{06661     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{06662     \textcolor{keyword}{struct }BoundValueRef : BoundValueRefBase \{}
\DoxyCodeLine{06663         T \&m\_ref;}
\DoxyCodeLine{06664 }
\DoxyCodeLine{06665         \textcolor{keyword}{explicit} BoundValueRef( T \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{06666 }
\DoxyCodeLine{06667         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{06668             \textcolor{keywordflow}{return} convertInto( arg, m\_ref );}
\DoxyCodeLine{06669         \}}
\DoxyCodeLine{06670     \};}
\DoxyCodeLine{06671 }
\DoxyCodeLine{06672     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{06673     \textcolor{keyword}{struct }BoundValueRef<std::vector<T>> : BoundValueRefBase \{}
\DoxyCodeLine{06674         std::vector<T> \&m\_ref;}
\DoxyCodeLine{06675 }
\DoxyCodeLine{06676         \textcolor{keyword}{explicit} BoundValueRef( std::vector<T> \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{06677 }
\DoxyCodeLine{06678         \textcolor{keyword}{auto} isContainer() const -> \textcolor{keywordtype}{bool}\textcolor{keyword}{ override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{06679 }
\DoxyCodeLine{06680         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{06681             T temp;}
\DoxyCodeLine{06682             \textcolor{keyword}{auto} result = convertInto( arg, temp );}
\DoxyCodeLine{06683             \textcolor{keywordflow}{if}( result )}
\DoxyCodeLine{06684                 m\_ref.push\_back( temp );}
\DoxyCodeLine{06685             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{06686         \}}
\DoxyCodeLine{06687     \};}
\DoxyCodeLine{06688 }
\DoxyCodeLine{06689     \textcolor{keyword}{struct }BoundFlagRef : BoundFlagRefBase \{}
\DoxyCodeLine{06690         \textcolor{keywordtype}{bool} \&m\_ref;}
\DoxyCodeLine{06691 }
\DoxyCodeLine{06692         \textcolor{keyword}{explicit} BoundFlagRef( \textcolor{keywordtype}{bool} \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{06693 }
\DoxyCodeLine{06694         \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{06695             m\_ref = flag;}
\DoxyCodeLine{06696             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{06697         \}}
\DoxyCodeLine{06698     \};}
\DoxyCodeLine{06699 }
\DoxyCodeLine{06700     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReturnType>}
\DoxyCodeLine{06701     \textcolor{keyword}{struct }LambdaInvoker \{}
\DoxyCodeLine{06702         static\_assert( std::is\_same<ReturnType, ParserResult>::value, \textcolor{stringliteral}{"Lambda must return void or clara::ParserResult"} );}
\DoxyCodeLine{06703 }
\DoxyCodeLine{06704         \textcolor{keyword}{template}<\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} ArgType>}
\DoxyCodeLine{06705         \textcolor{keyword}{static} \textcolor{keyword}{auto} invoke( L \textcolor{keyword}{const} \&lambda, ArgType \textcolor{keyword}{const} \&arg ) -> ParserResult \{}
\DoxyCodeLine{06706             \textcolor{keywordflow}{return} lambda( arg );}
\DoxyCodeLine{06707         \}}
\DoxyCodeLine{06708     \};}
\DoxyCodeLine{06709 }
\DoxyCodeLine{06710     \textcolor{keyword}{template}<>}
\DoxyCodeLine{06711     \textcolor{keyword}{struct }LambdaInvoker<void> \{}
\DoxyCodeLine{06712         \textcolor{keyword}{template}<\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} ArgType>}
\DoxyCodeLine{06713         \textcolor{keyword}{static} \textcolor{keyword}{auto} invoke( L \textcolor{keyword}{const} \&lambda, ArgType \textcolor{keyword}{const} \&arg ) -> ParserResult \{}
\DoxyCodeLine{06714             lambda( arg );}
\DoxyCodeLine{06715             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{06716         \}}
\DoxyCodeLine{06717     \};}
\DoxyCodeLine{06718 }
\DoxyCodeLine{06719     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} L>}
\DoxyCodeLine{06720     \textcolor{keyword}{inline} \textcolor{keyword}{auto} invokeLambda( L \textcolor{keyword}{const} \&lambda, std::string \textcolor{keyword}{const} \&arg ) -> ParserResult \{}
\DoxyCodeLine{06721         ArgType temp\{\};}
\DoxyCodeLine{06722         \textcolor{keyword}{auto} result = convertInto( arg, temp );}
\DoxyCodeLine{06723         \textcolor{keywordflow}{return} !result}
\DoxyCodeLine{06724            ? result}
\DoxyCodeLine{06725            : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );}
\DoxyCodeLine{06726     \}}
\DoxyCodeLine{06727 }
\DoxyCodeLine{06728     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{06729     \textcolor{keyword}{struct }BoundLambda : BoundValueRefBase \{}
\DoxyCodeLine{06730         L m\_lambda;}
\DoxyCodeLine{06731 }
\DoxyCodeLine{06732         static\_assert( UnaryLambdaTraits<L>::isValid, \textcolor{stringliteral}{"Supplied lambda must take exactly one argument"} );}
\DoxyCodeLine{06733         \textcolor{keyword}{explicit} BoundLambda( L \textcolor{keyword}{const} \&lambda ) : m\_lambda( lambda ) \{\}}
\DoxyCodeLine{06734 }
\DoxyCodeLine{06735         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{06736             \textcolor{keywordflow}{return} invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m\_lambda, arg );}
\DoxyCodeLine{06737         \}}
\DoxyCodeLine{06738     \};}
\DoxyCodeLine{06739 }
\DoxyCodeLine{06740     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{06741     \textcolor{keyword}{struct }BoundFlagLambda : BoundFlagRefBase \{}
\DoxyCodeLine{06742         L m\_lambda;}
\DoxyCodeLine{06743 }
\DoxyCodeLine{06744         static\_assert( UnaryLambdaTraits<L>::isValid, \textcolor{stringliteral}{"Supplied lambda must take exactly one argument"} );}
\DoxyCodeLine{06745         static\_assert( std::is\_same<\textcolor{keyword}{typename} UnaryLambdaTraits<L>::ArgType, \textcolor{keywordtype}{bool}>::value, \textcolor{stringliteral}{"flags must be boolean"} );}
\DoxyCodeLine{06746 }
\DoxyCodeLine{06747         \textcolor{keyword}{explicit} BoundFlagLambda( L \textcolor{keyword}{const} \&lambda ) : m\_lambda( lambda ) \{\}}
\DoxyCodeLine{06748 }
\DoxyCodeLine{06749         \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{06750             \textcolor{keywordflow}{return} LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m\_lambda, flag );}
\DoxyCodeLine{06751         \}}
\DoxyCodeLine{06752     \};}
\DoxyCodeLine{06753 }
\DoxyCodeLine{06754     \textcolor{keyword}{enum class} Optionality \{ Optional, Required \};}
\DoxyCodeLine{06755 }
\DoxyCodeLine{06756     \textcolor{keyword}{struct }Parser;}
\DoxyCodeLine{06757 }
\DoxyCodeLine{06758     \textcolor{keyword}{class }ParserBase \{}
\DoxyCodeLine{06759     \textcolor{keyword}{public}:}
\DoxyCodeLine{06760         \textcolor{keyword}{virtual} ~ParserBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{06761         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} validate() const -> Result \{ \textcolor{keywordflow}{return} Result::ok(); \}}
\DoxyCodeLine{06762         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\& exeName, TokenStream \textcolor{keyword}{const} \&tokens) \textcolor{keyword}{const} -> InternalParseResult  = 0;}
\DoxyCodeLine{06763         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} cardinality() const -> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} 1; \}}
\DoxyCodeLine{06764 }
\DoxyCodeLine{06765         \textcolor{keyword}{auto} parse( Args \textcolor{keyword}{const} \&args ) \textcolor{keyword}{const} -> InternalParseResult \{}
\DoxyCodeLine{06766             \textcolor{keywordflow}{return} parse( args.exeName(), TokenStream( args ) );}
\DoxyCodeLine{06767         \}}
\DoxyCodeLine{06768     \};}
\DoxyCodeLine{06769 }
\DoxyCodeLine{06770     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{06771     \textcolor{keyword}{class }ComposableParserImpl : \textcolor{keyword}{public} ParserBase \{}
\DoxyCodeLine{06772     \textcolor{keyword}{public}:}
\DoxyCodeLine{06773         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{06774         \textcolor{keyword}{auto} operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -> Parser;}
\DoxyCodeLine{06775 }
\DoxyCodeLine{06776         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{06777         \textcolor{keyword}{auto} operator+( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -> Parser;}
\DoxyCodeLine{06778     \};}
\DoxyCodeLine{06779 }
\DoxyCodeLine{06780     \textcolor{comment}{// Common code and state for Args and Opts}}
\DoxyCodeLine{06781     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{06782     \textcolor{keyword}{class }ParserRefImpl : \textcolor{keyword}{public} ComposableParserImpl<DerivedT> \{}
\DoxyCodeLine{06783     \textcolor{keyword}{protected}:}
\DoxyCodeLine{06784         Optionality m\_optionality = Optionality::Optional;}
\DoxyCodeLine{06785         std::shared\_ptr<BoundRef> m\_ref;}
\DoxyCodeLine{06786         std::string m\_hint;}
\DoxyCodeLine{06787         std::string m\_description;}
\DoxyCodeLine{06788 }
\DoxyCodeLine{06789         \textcolor{keyword}{explicit} ParserRefImpl( std::shared\_ptr<BoundRef> \textcolor{keyword}{const} \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{06790 }
\DoxyCodeLine{06791     \textcolor{keyword}{public}:}
\DoxyCodeLine{06792         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{06793         ParserRefImpl( T \&ref, std::string \textcolor{keyword}{const} \&hint )}
\DoxyCodeLine{06794         :   m\_ref( std::make\_shared<BoundValueRef<T>>( ref ) ),}
\DoxyCodeLine{06795             m\_hint( hint )}
\DoxyCodeLine{06796         \{\}}
\DoxyCodeLine{06797 }
\DoxyCodeLine{06798         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{06799         ParserRefImpl( LambdaT \textcolor{keyword}{const} \&ref, std::string \textcolor{keyword}{const} \&hint )}
\DoxyCodeLine{06800         :   m\_ref( std::make\_shared<BoundLambda<LambdaT>>( ref ) ),}
\DoxyCodeLine{06801             m\_hint(hint)}
\DoxyCodeLine{06802         \{\}}
\DoxyCodeLine{06803 }
\DoxyCodeLine{06804         \textcolor{keyword}{auto} operator()( std::string \textcolor{keyword}{const} \&description ) -> DerivedT \& \{}
\DoxyCodeLine{06805             m\_description = description;}
\DoxyCodeLine{06806             \textcolor{keywordflow}{return} static\_cast<DerivedT \&>( *\textcolor{keyword}{this} );}
\DoxyCodeLine{06807         \}}
\DoxyCodeLine{06808 }
\DoxyCodeLine{06809         \textcolor{keyword}{auto} optional() -> DerivedT \& \{}
\DoxyCodeLine{06810             m\_optionality = Optionality::Optional;}
\DoxyCodeLine{06811             \textcolor{keywordflow}{return} static\_cast<DerivedT \&>( *\textcolor{keyword}{this} );}
\DoxyCodeLine{06812         \};}
\DoxyCodeLine{06813 }
\DoxyCodeLine{06814         \textcolor{keyword}{auto} required() -> DerivedT \& \{}
\DoxyCodeLine{06815             m\_optionality = Optionality::Required;}
\DoxyCodeLine{06816             \textcolor{keywordflow}{return} static\_cast<DerivedT \&>( *\textcolor{keyword}{this} );}
\DoxyCodeLine{06817         \};}
\DoxyCodeLine{06818 }
\DoxyCodeLine{06819         \textcolor{keyword}{auto} isOptional() const -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{06820             \textcolor{keywordflow}{return} m\_optionality == Optionality::Optional;}
\DoxyCodeLine{06821         \}}
\DoxyCodeLine{06822 }
\DoxyCodeLine{06823         \textcolor{keyword}{auto} cardinality() const -> \textcolor{keywordtype}{size\_t}\textcolor{keyword}{ override }\{}
\DoxyCodeLine{06824             \textcolor{keywordflow}{if}( m\_ref->isContainer() )}
\DoxyCodeLine{06825                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{06826             \textcolor{keywordflow}{else}}
\DoxyCodeLine{06827                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{06828         \}}
\DoxyCodeLine{06829 }
\DoxyCodeLine{06830         \textcolor{keyword}{auto} hint() const -> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_hint; \}}
\DoxyCodeLine{06831     \};}
\DoxyCodeLine{06832 }
\DoxyCodeLine{06833     \textcolor{keyword}{class }ExeName : \textcolor{keyword}{public} ComposableParserImpl<ExeName> \{}
\DoxyCodeLine{06834         std::shared\_ptr<std::string> m\_name;}
\DoxyCodeLine{06835         std::shared\_ptr<BoundValueRefBase> m\_ref;}
\DoxyCodeLine{06836 }
\DoxyCodeLine{06837         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{06838         \textcolor{keyword}{static} \textcolor{keyword}{auto} makeRef(LambdaT \textcolor{keyword}{const} \&lambda) -> std::shared\_ptr<BoundValueRefBase> \{}
\DoxyCodeLine{06839             \textcolor{keywordflow}{return} std::make\_shared<BoundLambda<LambdaT>>( lambda) ;}
\DoxyCodeLine{06840         \}}
\DoxyCodeLine{06841 }
\DoxyCodeLine{06842     \textcolor{keyword}{public}:}
\DoxyCodeLine{06843         ExeName() : m\_name( std::make\_shared<std::string>( \textcolor{stringliteral}{"<executable>"} ) ) \{\}}
\DoxyCodeLine{06844 }
\DoxyCodeLine{06845         \textcolor{keyword}{explicit} ExeName( std::string \&ref ) : ExeName() \{}
\DoxyCodeLine{06846             m\_ref = std::make\_shared<BoundValueRef<std::string>>( ref );}
\DoxyCodeLine{06847         \}}
\DoxyCodeLine{06848 }
\DoxyCodeLine{06849         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{06850         \textcolor{keyword}{explicit} ExeName( LambdaT \textcolor{keyword}{const}\& lambda ) : ExeName() \{}
\DoxyCodeLine{06851             m\_ref = std::make\_shared<BoundLambda<LambdaT>>( lambda );}
\DoxyCodeLine{06852         \}}
\DoxyCodeLine{06853 }
\DoxyCodeLine{06854         \textcolor{comment}{// The exe name is not parsed out of the normal tokens, but is handled specially}}
\DoxyCodeLine{06855         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{06856             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );}
\DoxyCodeLine{06857         \}}
\DoxyCodeLine{06858 }
\DoxyCodeLine{06859         \textcolor{keyword}{auto} name() const -> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} *m\_name; \}}
\DoxyCodeLine{06860         \textcolor{keyword}{auto} set( std::string \textcolor{keyword}{const}\& newName ) -> ParserResult \{}
\DoxyCodeLine{06861 }
\DoxyCodeLine{06862             \textcolor{keyword}{auto} lastSlash = newName.find\_last\_of( \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)/"} );}
\DoxyCodeLine{06863             \textcolor{keyword}{auto} filename = ( lastSlash == std::string::npos )}
\DoxyCodeLine{06864                     ? newName}
\DoxyCodeLine{06865                     : newName.substr( lastSlash+1 );}
\DoxyCodeLine{06866 }
\DoxyCodeLine{06867             *m\_name = filename;}
\DoxyCodeLine{06868             \textcolor{keywordflow}{if}( m\_ref )}
\DoxyCodeLine{06869                 \textcolor{keywordflow}{return} m\_ref->setValue( filename );}
\DoxyCodeLine{06870             \textcolor{keywordflow}{else}}
\DoxyCodeLine{06871                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{06872         \}}
\DoxyCodeLine{06873     \};}
\DoxyCodeLine{06874 }
\DoxyCodeLine{06875     \textcolor{keyword}{class }Arg : \textcolor{keyword}{public} ParserRefImpl<Arg> \{}
\DoxyCodeLine{06876     \textcolor{keyword}{public}:}
\DoxyCodeLine{06877         \textcolor{keyword}{using} ParserRefImpl::ParserRefImpl;}
\DoxyCodeLine{06878 }
\DoxyCodeLine{06879         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const} \&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{06880             \textcolor{keyword}{auto} validationResult = validate();}
\DoxyCodeLine{06881             \textcolor{keywordflow}{if}( !validationResult )}
\DoxyCodeLine{06882                 \textcolor{keywordflow}{return} InternalParseResult( validationResult );}
\DoxyCodeLine{06883 }
\DoxyCodeLine{06884             \textcolor{keyword}{auto} remainingTokens = tokens;}
\DoxyCodeLine{06885             \textcolor{keyword}{auto} \textcolor{keyword}{const} \&token = *remainingTokens;}
\DoxyCodeLine{06886             \textcolor{keywordflow}{if}( token.type != TokenType::Argument )}
\DoxyCodeLine{06887                 \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );}
\DoxyCodeLine{06888 }
\DoxyCodeLine{06889             assert( !m\_ref->isFlag() );}
\DoxyCodeLine{06890             \textcolor{keyword}{auto} valueRef = static\_cast<detail::BoundValueRefBase*>( m\_ref.get() );}
\DoxyCodeLine{06891 }
\DoxyCodeLine{06892             \textcolor{keyword}{auto} result = valueRef->setValue( remainingTokens->token );}
\DoxyCodeLine{06893             \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{06894                 \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{06895             \textcolor{keywordflow}{else}}
\DoxyCodeLine{06896                 \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );}
\DoxyCodeLine{06897         \}}
\DoxyCodeLine{06898     \};}
\DoxyCodeLine{06899 }
\DoxyCodeLine{06900     \textcolor{keyword}{inline} \textcolor{keyword}{auto} normaliseOpt( std::string \textcolor{keyword}{const} \&optName ) -> std::string \{}
\DoxyCodeLine{06901 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{06902         \textcolor{keywordflow}{if}( optName[0] == \textcolor{charliteral}{'/'} )}
\DoxyCodeLine{06903             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"-"} + optName.substr( 1 );}
\DoxyCodeLine{06904         \textcolor{keywordflow}{else}}
\DoxyCodeLine{06905 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{06906             \textcolor{keywordflow}{return} optName;}
\DoxyCodeLine{06907     \}}
\DoxyCodeLine{06908 }
\DoxyCodeLine{06909     \textcolor{keyword}{class }Opt : \textcolor{keyword}{public} ParserRefImpl<Opt> \{}
\DoxyCodeLine{06910     \textcolor{keyword}{protected}:}
\DoxyCodeLine{06911         std::vector<std::string> m\_optNames;}
\DoxyCodeLine{06912 }
\DoxyCodeLine{06913     \textcolor{keyword}{public}:}
\DoxyCodeLine{06914         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{06915         \textcolor{keyword}{explicit} Opt( LambdaT \textcolor{keyword}{const} \&ref ) : ParserRefImpl( std::make\_shared<BoundFlagLambda<LambdaT>>( ref ) ) \{\}}
\DoxyCodeLine{06916 }
\DoxyCodeLine{06917         \textcolor{keyword}{explicit} Opt( \textcolor{keywordtype}{bool} \&ref ) : ParserRefImpl( std::make\_shared<BoundFlagRef>( ref ) ) \{\}}
\DoxyCodeLine{06918 }
\DoxyCodeLine{06919         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{06920         Opt( LambdaT \textcolor{keyword}{const} \&ref, std::string \textcolor{keyword}{const} \&hint ) : ParserRefImpl( ref, hint ) \{\}}
\DoxyCodeLine{06921 }
\DoxyCodeLine{06922         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{06923         Opt( T \&ref, std::string \textcolor{keyword}{const} \&hint ) : ParserRefImpl( ref, hint ) \{\}}
\DoxyCodeLine{06924 }
\DoxyCodeLine{06925         \textcolor{keyword}{auto} operator[]( std::string \textcolor{keyword}{const} \&optName ) -> Opt \& \{}
\DoxyCodeLine{06926             m\_optNames.push\_back( optName );}
\DoxyCodeLine{06927             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{06928         \}}
\DoxyCodeLine{06929 }
\DoxyCodeLine{06930         \textcolor{keyword}{auto} getHelpColumns() const -> std::vector<HelpColumns> \{}
\DoxyCodeLine{06931             std::ostringstream oss;}
\DoxyCodeLine{06932             \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{06933             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_optNames ) \{}
\DoxyCodeLine{06934                 \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{06935                     first = \textcolor{keyword}{false};}
\DoxyCodeLine{06936                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{06937                     oss << \textcolor{stringliteral}{", "};}
\DoxyCodeLine{06938                 oss << opt;}
\DoxyCodeLine{06939             \}}
\DoxyCodeLine{06940             \textcolor{keywordflow}{if}( !m\_hint.empty() )}
\DoxyCodeLine{06941                 oss << \textcolor{stringliteral}{" <"} << m\_hint << \textcolor{stringliteral}{">"};}
\DoxyCodeLine{06942             \textcolor{keywordflow}{return} \{ \{ oss.str(), m\_description \} \};}
\DoxyCodeLine{06943         \}}
\DoxyCodeLine{06944 }
\DoxyCodeLine{06945         \textcolor{keyword}{auto} isMatch( std::string \textcolor{keyword}{const} \&optToken ) \textcolor{keyword}{const} -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{06946             \textcolor{keyword}{auto} normalisedToken = normaliseOpt( optToken );}
\DoxyCodeLine{06947             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&name : m\_optNames ) \{}
\DoxyCodeLine{06948                 \textcolor{keywordflow}{if}( normaliseOpt( name ) == normalisedToken )}
\DoxyCodeLine{06949                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{06950             \}}
\DoxyCodeLine{06951             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{06952         \}}
\DoxyCodeLine{06953 }
\DoxyCodeLine{06954         \textcolor{keyword}{using} ParserBase::parse;}
\DoxyCodeLine{06955 }
\DoxyCodeLine{06956         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{06957             \textcolor{keyword}{auto} validationResult = validate();}
\DoxyCodeLine{06958             \textcolor{keywordflow}{if}( !validationResult )}
\DoxyCodeLine{06959                 \textcolor{keywordflow}{return} InternalParseResult( validationResult );}
\DoxyCodeLine{06960 }
\DoxyCodeLine{06961             \textcolor{keyword}{auto} remainingTokens = tokens;}
\DoxyCodeLine{06962             \textcolor{keywordflow}{if}( remainingTokens \&\& remainingTokens->type == TokenType::Option ) \{}
\DoxyCodeLine{06963                 \textcolor{keyword}{auto} \textcolor{keyword}{const} \&token = *remainingTokens;}
\DoxyCodeLine{06964                 \textcolor{keywordflow}{if}( isMatch(token.token ) ) \{}
\DoxyCodeLine{06965                     \textcolor{keywordflow}{if}( m\_ref->isFlag() ) \{}
\DoxyCodeLine{06966                         \textcolor{keyword}{auto} flagRef = static\_cast<detail::BoundFlagRefBase*>( m\_ref.get() );}
\DoxyCodeLine{06967                         \textcolor{keyword}{auto} result = flagRef->setFlag( \textcolor{keyword}{true} );}
\DoxyCodeLine{06968                         \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{06969                             \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{06970                         \textcolor{keywordflow}{if}( result.value() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{06971                             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );}
\DoxyCodeLine{06972                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{06973                         \textcolor{keyword}{auto} valueRef = static\_cast<detail::BoundValueRefBase*>( m\_ref.get() );}
\DoxyCodeLine{06974                         ++remainingTokens;}
\DoxyCodeLine{06975                         \textcolor{keywordflow}{if}( !remainingTokens )}
\DoxyCodeLine{06976                             \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"Expected argument following "} + token.token );}
\DoxyCodeLine{06977                         \textcolor{keyword}{auto} \textcolor{keyword}{const} \&argToken = *remainingTokens;}
\DoxyCodeLine{06978                         \textcolor{keywordflow}{if}( argToken.type != TokenType::Argument )}
\DoxyCodeLine{06979                             \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"Expected argument following "} + token.token );}
\DoxyCodeLine{06980                         \textcolor{keyword}{auto} result = valueRef->setValue( argToken.token );}
\DoxyCodeLine{06981                         \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{06982                             \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{06983                         \textcolor{keywordflow}{if}( result.value() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{06984                             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );}
\DoxyCodeLine{06985                     \}}
\DoxyCodeLine{06986                     \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );}
\DoxyCodeLine{06987                 \}}
\DoxyCodeLine{06988             \}}
\DoxyCodeLine{06989             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );}
\DoxyCodeLine{06990         \}}
\DoxyCodeLine{06991 }
\DoxyCodeLine{06992         \textcolor{keyword}{auto} validate() const -> Result\textcolor{keyword}{ override }\{}
\DoxyCodeLine{06993             \textcolor{keywordflow}{if}( m\_optNames.empty() )}
\DoxyCodeLine{06994                 \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"No options supplied to Opt"} );}
\DoxyCodeLine{06995             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&name : m\_optNames ) \{}
\DoxyCodeLine{06996                 \textcolor{keywordflow}{if}( name.empty() )}
\DoxyCodeLine{06997                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"Option name cannot be empty"} );}
\DoxyCodeLine{06998 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{06999                 \textcolor{keywordflow}{if}( name[0] != \textcolor{charliteral}{'-'} \&\& name[0] != \textcolor{charliteral}{'/'} )}
\DoxyCodeLine{07000                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"Option name must begin with '-' or '/'"} );}
\DoxyCodeLine{07001 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{07002                 \textcolor{keywordflow}{if}( name[0] != \textcolor{charliteral}{'-'} )}
\DoxyCodeLine{07003                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"Option name must begin with '-'"} );}
\DoxyCodeLine{07004 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{07005             \}}
\DoxyCodeLine{07006             \textcolor{keywordflow}{return} ParserRefImpl::validate();}
\DoxyCodeLine{07007         \}}
\DoxyCodeLine{07008     \};}
\DoxyCodeLine{07009 }
\DoxyCodeLine{07010     \textcolor{keyword}{struct }Help : Opt \{}
\DoxyCodeLine{07011         Help( \textcolor{keywordtype}{bool} \&showHelpFlag )}
\DoxyCodeLine{07012         :   Opt([\&]( bool flag ) \{}
\DoxyCodeLine{07013                 showHelpFlag = flag;}
\DoxyCodeLine{07014                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::ShortCircuitAll );}
\DoxyCodeLine{07015             \})}
\DoxyCodeLine{07016         \{}
\DoxyCodeLine{07017             static\_cast<Opt \&>( *\textcolor{keyword}{this} )}
\DoxyCodeLine{07018                     (\textcolor{stringliteral}{"display usage information"})}
\DoxyCodeLine{07019                     [\textcolor{stringliteral}{"-?"}][\textcolor{stringliteral}{"-h"}][\textcolor{stringliteral}{"--help"}]}
\DoxyCodeLine{07020                     .optional();}
\DoxyCodeLine{07021         \}}
\DoxyCodeLine{07022     \};}
\DoxyCodeLine{07023 }
\DoxyCodeLine{07024     \textcolor{keyword}{struct }Parser : ParserBase \{}
\DoxyCodeLine{07025 }
\DoxyCodeLine{07026         \textcolor{keyword}{mutable} ExeName m\_exeName;}
\DoxyCodeLine{07027         std::vector<Opt> m\_options;}
\DoxyCodeLine{07028         std::vector<Arg> m\_args;}
\DoxyCodeLine{07029 }
\DoxyCodeLine{07030         \textcolor{keyword}{auto} operator|=( ExeName \textcolor{keyword}{const} \&exeName ) -> Parser \& \{}
\DoxyCodeLine{07031             m\_exeName = exeName;}
\DoxyCodeLine{07032             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{07033         \}}
\DoxyCodeLine{07034 }
\DoxyCodeLine{07035         \textcolor{keyword}{auto} operator|=( Arg \textcolor{keyword}{const} \&arg ) -> Parser \& \{}
\DoxyCodeLine{07036             m\_args.push\_back(arg);}
\DoxyCodeLine{07037             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{07038         \}}
\DoxyCodeLine{07039 }
\DoxyCodeLine{07040         \textcolor{keyword}{auto} operator|=( Opt \textcolor{keyword}{const} \&opt ) -> Parser \& \{}
\DoxyCodeLine{07041             m\_options.push\_back(opt);}
\DoxyCodeLine{07042             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{07043         \}}
\DoxyCodeLine{07044 }
\DoxyCodeLine{07045         \textcolor{keyword}{auto} operator|=( Parser \textcolor{keyword}{const} \&other ) -> Parser \& \{}
\DoxyCodeLine{07046             m\_options.insert(m\_options.end(), other.m\_options.begin(), other.m\_options.end());}
\DoxyCodeLine{07047             m\_args.insert(m\_args.end(), other.m\_args.begin(), other.m\_args.end());}
\DoxyCodeLine{07048             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{07049         \}}
\DoxyCodeLine{07050 }
\DoxyCodeLine{07051         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{07052         \textcolor{keyword}{auto} operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -> Parser \{}
\DoxyCodeLine{07053             \textcolor{keywordflow}{return} Parser( *\textcolor{keyword}{this} ) |= other;}
\DoxyCodeLine{07054         \}}
\DoxyCodeLine{07055 }
\DoxyCodeLine{07056         \textcolor{comment}{// Forward deprecated interface with '+' instead of '|'}}
\DoxyCodeLine{07057         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{07058         \textcolor{keyword}{auto} operator+=( T \textcolor{keyword}{const} \&other ) -> Parser \& \{ \textcolor{keywordflow}{return} operator|=( other ); \}}
\DoxyCodeLine{07059         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{07060         \textcolor{keyword}{auto} operator+( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -> Parser \{ \textcolor{keywordflow}{return} operator|( other ); \}}
\DoxyCodeLine{07061 }
\DoxyCodeLine{07062         \textcolor{keyword}{auto} getHelpColumns() const -> std::vector<HelpColumns> \{}
\DoxyCodeLine{07063             std::vector<HelpColumns> cols;}
\DoxyCodeLine{07064             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&o : m\_options) \{}
\DoxyCodeLine{07065                 \textcolor{keyword}{auto} childCols = o.getHelpColumns();}
\DoxyCodeLine{07066                 cols.insert( cols.end(), childCols.begin(), childCols.end() );}
\DoxyCodeLine{07067             \}}
\DoxyCodeLine{07068             \textcolor{keywordflow}{return} cols;}
\DoxyCodeLine{07069         \}}
\DoxyCodeLine{07070 }
\DoxyCodeLine{07071         \textcolor{keywordtype}{void} writeToStream( std::ostream \&os )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{07072             \textcolor{keywordflow}{if} (!m\_exeName.name().empty()) \{}
\DoxyCodeLine{07073                 os << \textcolor{stringliteral}{"usage:\(\backslash\)n"} << \textcolor{stringliteral}{"  "} << m\_exeName.name() << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{07074                 \textcolor{keywordtype}{bool} required = \textcolor{keyword}{true}, first = \textcolor{keyword}{true};}
\DoxyCodeLine{07075                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args ) \{}
\DoxyCodeLine{07076                     \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{07077                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{07078                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{07079                         os << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{07080                     \textcolor{keywordflow}{if}( arg.isOptional() \&\& required ) \{}
\DoxyCodeLine{07081                         os << \textcolor{stringliteral}{"["};}
\DoxyCodeLine{07082                         required = \textcolor{keyword}{false};}
\DoxyCodeLine{07083                     \}}
\DoxyCodeLine{07084                     os << \textcolor{stringliteral}{"<"} << arg.hint() << \textcolor{stringliteral}{">"};}
\DoxyCodeLine{07085                     \textcolor{keywordflow}{if}( arg.cardinality() == 0 )}
\DoxyCodeLine{07086                         os << \textcolor{stringliteral}{" ... "};}
\DoxyCodeLine{07087                 \}}
\DoxyCodeLine{07088                 \textcolor{keywordflow}{if}( !required )}
\DoxyCodeLine{07089                     os << \textcolor{stringliteral}{"]"};}
\DoxyCodeLine{07090                 \textcolor{keywordflow}{if}( !m\_options.empty() )}
\DoxyCodeLine{07091                     os << \textcolor{stringliteral}{" options"};}
\DoxyCodeLine{07092                 os << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)nwhere options are:"} << std::endl;}
\DoxyCodeLine{07093             \}}
\DoxyCodeLine{07094 }
\DoxyCodeLine{07095             \textcolor{keyword}{auto} rows = getHelpColumns();}
\DoxyCodeLine{07096             \textcolor{keywordtype}{size\_t} consoleWidth = CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH;}
\DoxyCodeLine{07097             \textcolor{keywordtype}{size\_t} optWidth = 0;}
\DoxyCodeLine{07098             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&cols : rows )}
\DoxyCodeLine{07099                 optWidth = (std::max)(optWidth, cols.left.size() + 2);}
\DoxyCodeLine{07100 }
\DoxyCodeLine{07101             optWidth = (std::min)(optWidth, consoleWidth/2);}
\DoxyCodeLine{07102 }
\DoxyCodeLine{07103             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&cols : rows ) \{}
\DoxyCodeLine{07104                 \textcolor{keyword}{auto} row =}
\DoxyCodeLine{07105                         TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +}
\DoxyCodeLine{07106                         TextFlow::Spacer(4) +}
\DoxyCodeLine{07107                         TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );}
\DoxyCodeLine{07108                 os << row << std::endl;}
\DoxyCodeLine{07109             \}}
\DoxyCodeLine{07110         \}}
\DoxyCodeLine{07111 }
\DoxyCodeLine{07112         \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator<<( std::ostream \&os, Parser \textcolor{keyword}{const} \&parser ) -> std::ostream\& \{}
\DoxyCodeLine{07113             parser.writeToStream( os );}
\DoxyCodeLine{07114             \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{07115         \}}
\DoxyCodeLine{07116 }
\DoxyCodeLine{07117         \textcolor{keyword}{auto} validate() const -> Result\textcolor{keyword}{ override }\{}
\DoxyCodeLine{07118             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_options ) \{}
\DoxyCodeLine{07119                 \textcolor{keyword}{auto} result = opt.validate();}
\DoxyCodeLine{07120                 \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{07121                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{07122             \}}
\DoxyCodeLine{07123             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args ) \{}
\DoxyCodeLine{07124                 \textcolor{keyword}{auto} result = arg.validate();}
\DoxyCodeLine{07125                 \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{07126                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{07127             \}}
\DoxyCodeLine{07128             \textcolor{keywordflow}{return} Result::ok();}
\DoxyCodeLine{07129         \}}
\DoxyCodeLine{07130 }
\DoxyCodeLine{07131         \textcolor{keyword}{using} ParserBase::parse;}
\DoxyCodeLine{07132 }
\DoxyCodeLine{07133         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\& exeName, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{07134 }
\DoxyCodeLine{07135             \textcolor{keyword}{struct }ParserInfo \{}
\DoxyCodeLine{07136                 ParserBase \textcolor{keyword}{const}* parser = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{07137                 \textcolor{keywordtype}{size\_t} count = 0;}
\DoxyCodeLine{07138             \};}
\DoxyCodeLine{07139             \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} totalParsers = m\_options.size() + m\_args.size();}
\DoxyCodeLine{07140             assert( totalParsers < 512 );}
\DoxyCodeLine{07141             \textcolor{comment}{// ParserInfo parseInfos[totalParsers]; // <-- this is what we really want to do}}
\DoxyCodeLine{07142             ParserInfo parseInfos[512];}
\DoxyCodeLine{07143 }
\DoxyCodeLine{07144             \{}
\DoxyCodeLine{07145                 \textcolor{keywordtype}{size\_t} i = 0;}
\DoxyCodeLine{07146                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_options) parseInfos[i++].parser = \&opt;}
\DoxyCodeLine{07147                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args) parseInfos[i++].parser = \&arg;}
\DoxyCodeLine{07148             \}}
\DoxyCodeLine{07149 }
\DoxyCodeLine{07150             m\_exeName.set( exeName );}
\DoxyCodeLine{07151 }
\DoxyCodeLine{07152             \textcolor{keyword}{auto} result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );}
\DoxyCodeLine{07153             \textcolor{keywordflow}{while}( result.value().remainingTokens() ) \{}
\DoxyCodeLine{07154                 \textcolor{keywordtype}{bool} tokenParsed = \textcolor{keyword}{false};}
\DoxyCodeLine{07155 }
\DoxyCodeLine{07156                 \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 0; i < totalParsers; ++i ) \{}
\DoxyCodeLine{07157                     \textcolor{keyword}{auto}\&  parseInfo = parseInfos[i];}
\DoxyCodeLine{07158                     \textcolor{keywordflow}{if}( parseInfo.parser->cardinality() == 0 || parseInfo.count < parseInfo.parser->cardinality() ) \{}
\DoxyCodeLine{07159                         result = parseInfo.parser->parse(exeName, result.value().remainingTokens());}
\DoxyCodeLine{07160                         \textcolor{keywordflow}{if} (!result)}
\DoxyCodeLine{07161                             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{07162                         \textcolor{keywordflow}{if} (result.value().type() != ParseResultType::NoMatch) \{}
\DoxyCodeLine{07163                             tokenParsed = \textcolor{keyword}{true};}
\DoxyCodeLine{07164                             ++parseInfo.count;}
\DoxyCodeLine{07165                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{07166                         \}}
\DoxyCodeLine{07167                     \}}
\DoxyCodeLine{07168                 \}}
\DoxyCodeLine{07169 }
\DoxyCodeLine{07170                 \textcolor{keywordflow}{if}( result.value().type() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{07171                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{07172                 \textcolor{keywordflow}{if}( !tokenParsed )}
\DoxyCodeLine{07173                     \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"Unrecognised token: "} + result.value().remainingTokens()->token );}
\DoxyCodeLine{07174             \}}
\DoxyCodeLine{07175             \textcolor{comment}{// !TBD Check missing required options}}
\DoxyCodeLine{07176             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{07177         \}}
\DoxyCodeLine{07178     \};}
\DoxyCodeLine{07179 }
\DoxyCodeLine{07180     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{07181     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{07182     \textcolor{keyword}{auto} ComposableParserImpl<DerivedT>::operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -> Parser \{}
\DoxyCodeLine{07183         \textcolor{keywordflow}{return} Parser() | static\_cast<DerivedT const \&>( *\textcolor{keyword}{this} ) | other;}
\DoxyCodeLine{07184     \}}
\DoxyCodeLine{07185 \} \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{07186 }
\DoxyCodeLine{07187 \textcolor{comment}{// A Combined parser}}
\DoxyCodeLine{07188 \textcolor{keyword}{using} detail::Parser;}
\DoxyCodeLine{07189 }
\DoxyCodeLine{07190 \textcolor{comment}{// A parser for options}}
\DoxyCodeLine{07191 \textcolor{keyword}{using} detail::Opt;}
\DoxyCodeLine{07192 }
\DoxyCodeLine{07193 \textcolor{comment}{// A parser for arguments}}
\DoxyCodeLine{07194 \textcolor{keyword}{using} detail::Arg;}
\DoxyCodeLine{07195 }
\DoxyCodeLine{07196 \textcolor{comment}{// Wrapper for argc, argv from main()}}
\DoxyCodeLine{07197 \textcolor{keyword}{using} detail::Args;}
\DoxyCodeLine{07198 }
\DoxyCodeLine{07199 \textcolor{comment}{// Specifies the name of the executable}}
\DoxyCodeLine{07200 \textcolor{keyword}{using} detail::ExeName;}
\DoxyCodeLine{07201 }
\DoxyCodeLine{07202 \textcolor{comment}{// Convenience wrapper for option parser that specifies the help option}}
\DoxyCodeLine{07203 \textcolor{keyword}{using} detail::Help;}
\DoxyCodeLine{07204 }
\DoxyCodeLine{07205 \textcolor{comment}{// enum of result types from a parse}}
\DoxyCodeLine{07206 \textcolor{keyword}{using} detail::ParseResultType;}
\DoxyCodeLine{07207 }
\DoxyCodeLine{07208 \textcolor{comment}{// Result type for parser operation}}
\DoxyCodeLine{07209 \textcolor{keyword}{using} detail::ParserResult;}
\DoxyCodeLine{07210 }
\DoxyCodeLine{07211 \}\} \textcolor{comment}{// namespace Catch::clara}}
\DoxyCodeLine{07212 }
\DoxyCodeLine{07213 \textcolor{comment}{// end clara.hpp}}
\DoxyCodeLine{07214 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{07215 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{07216 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{07217 }
\DoxyCodeLine{07218 \textcolor{comment}{// Restore Clara's value for console width, if present}}
\DoxyCodeLine{07219 \textcolor{preprocessor}{\#ifdef CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{07220 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{07221 \textcolor{preprocessor}{\#undef CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{07222 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{07223 }
\DoxyCodeLine{07224 \textcolor{comment}{// end catch\_clara.h}}
\DoxyCodeLine{07225 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07226 }
\DoxyCodeLine{07227     clara::Parser makeCommandLineParser( ConfigData\& config );}
\DoxyCodeLine{07228 }
\DoxyCodeLine{07229 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{07230 }
\DoxyCodeLine{07231 \textcolor{comment}{// end catch\_commandline.h}}
\DoxyCodeLine{07232 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{07233 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{07234 }
\DoxyCodeLine{07235 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07236 }
\DoxyCodeLine{07237     clara::Parser makeCommandLineParser( ConfigData\& config ) \{}
\DoxyCodeLine{07238 }
\DoxyCodeLine{07239         \textcolor{keyword}{using namespace }clara;}
\DoxyCodeLine{07240 }
\DoxyCodeLine{07241         \textcolor{keyword}{auto} \textcolor{keyword}{const} setWarning = [\&]( std::string \textcolor{keyword}{const}\& warning ) \{}
\DoxyCodeLine{07242                 \textcolor{keyword}{auto} warningSet = [\&]() \{}
\DoxyCodeLine{07243                     \textcolor{keywordflow}{if}( warning == \textcolor{stringliteral}{"NoAssertions"} )}
\DoxyCodeLine{07244                         \textcolor{keywordflow}{return} WarnAbout::NoAssertions;}
\DoxyCodeLine{07245 }
\DoxyCodeLine{07246                     \textcolor{keywordflow}{if} ( warning == \textcolor{stringliteral}{"NoTests"} )}
\DoxyCodeLine{07247                         \textcolor{keywordflow}{return} WarnAbout::NoTests;}
\DoxyCodeLine{07248 }
\DoxyCodeLine{07249                     \textcolor{keywordflow}{return} WarnAbout::Nothing;}
\DoxyCodeLine{07250                 \}();}
\DoxyCodeLine{07251 }
\DoxyCodeLine{07252                 \textcolor{keywordflow}{if} (warningSet == WarnAbout::Nothing)}
\DoxyCodeLine{07253                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"Unrecognised warning: '"} + warning + \textcolor{stringliteral}{"'"} );}
\DoxyCodeLine{07254                 config.warnings = static\_cast<WarnAbout::What>( config.warnings | warningSet );}
\DoxyCodeLine{07255                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{07256             \};}
\DoxyCodeLine{07257         \textcolor{keyword}{auto} \textcolor{keyword}{const} loadTestNamesFromFile = [\&]( std::string \textcolor{keyword}{const}\& filename ) \{}
\DoxyCodeLine{07258                 std::ifstream f( filename.c\_str() );}
\DoxyCodeLine{07259                 \textcolor{keywordflow}{if}( !f.is\_open() )}
\DoxyCodeLine{07260                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"Unable to load input file: '"} + filename + \textcolor{stringliteral}{"'"} );}
\DoxyCodeLine{07261 }
\DoxyCodeLine{07262                 std::string line;}
\DoxyCodeLine{07263                 \textcolor{keywordflow}{while}( std::getline( f, line ) ) \{}
\DoxyCodeLine{07264                     line = trim(line);}
\DoxyCodeLine{07265                     \textcolor{keywordflow}{if}( !line.empty() \&\& !startsWith( line, \textcolor{charliteral}{'\#'} ) ) \{}
\DoxyCodeLine{07266                         \textcolor{keywordflow}{if}( !startsWith( line, \textcolor{charliteral}{'"'} ) )}
\DoxyCodeLine{07267                             line = \textcolor{charliteral}{'"'} + line + \textcolor{charliteral}{'"'};}
\DoxyCodeLine{07268                         config.testsOrTags.push\_back( line + \textcolor{charliteral}{','} );}
\DoxyCodeLine{07269                     \}}
\DoxyCodeLine{07270                 \}}
\DoxyCodeLine{07271                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{07272             \};}
\DoxyCodeLine{07273         \textcolor{keyword}{auto} \textcolor{keyword}{const} setTestOrder = [\&]( std::string \textcolor{keyword}{const}\& order ) \{}
\DoxyCodeLine{07274                 \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"declared"}, order ) )}
\DoxyCodeLine{07275                     config.runOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{07276                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"lexical"}, order ) )}
\DoxyCodeLine{07277                     config.runOrder = RunTests::InLexicographicalOrder;}
\DoxyCodeLine{07278                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"random"}, order ) )}
\DoxyCodeLine{07279                     config.runOrder = RunTests::InRandomOrder;}
\DoxyCodeLine{07280                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{07281                     \textcolor{keywordflow}{return} clara::ParserResult::runtimeError( \textcolor{stringliteral}{"Unrecognised ordering: '"} + order + \textcolor{stringliteral}{"'"} );}
\DoxyCodeLine{07282                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{07283             \};}
\DoxyCodeLine{07284         \textcolor{keyword}{auto} \textcolor{keyword}{const} setRngSeed = [\&]( std::string \textcolor{keyword}{const}\& seed ) \{}
\DoxyCodeLine{07285                 \textcolor{keywordflow}{if}( seed != \textcolor{stringliteral}{"time"} )}
\DoxyCodeLine{07286                     \textcolor{keywordflow}{return} clara::detail::convertInto( seed, config.rngSeed );}
\DoxyCodeLine{07287                 config.rngSeed = static\_cast<unsigned int>( std::time(\textcolor{keyword}{nullptr}) );}
\DoxyCodeLine{07288                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{07289             \};}
\DoxyCodeLine{07290         \textcolor{keyword}{auto} \textcolor{keyword}{const} setColourUsage = [\&]( std::string \textcolor{keyword}{const}\& useColour ) \{}
\DoxyCodeLine{07291                     \textcolor{keyword}{auto} mode = toLower( useColour );}
\DoxyCodeLine{07292 }
\DoxyCodeLine{07293                     \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"yes"} )}
\DoxyCodeLine{07294                         config.useColour = UseColour::Yes;}
\DoxyCodeLine{07295                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"no"} )}
\DoxyCodeLine{07296                         config.useColour = UseColour::No;}
\DoxyCodeLine{07297                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"auto"} )}
\DoxyCodeLine{07298                         config.useColour = UseColour::Auto;}
\DoxyCodeLine{07299                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{07300                         \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"colour mode must be one of: auto, yes or no. '"} + useColour + \textcolor{stringliteral}{"' not recognised"} );}
\DoxyCodeLine{07301                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{07302             \};}
\DoxyCodeLine{07303         \textcolor{keyword}{auto} \textcolor{keyword}{const} setWaitForKeypress = [\&]( std::string \textcolor{keyword}{const}\& keypress ) \{}
\DoxyCodeLine{07304                 \textcolor{keyword}{auto} keypressLc = toLower( keypress );}
\DoxyCodeLine{07305                 \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"start"} )}
\DoxyCodeLine{07306                     config.waitForKeypress = WaitForKeypress::BeforeStart;}
\DoxyCodeLine{07307                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"exit"} )}
\DoxyCodeLine{07308                     config.waitForKeypress = WaitForKeypress::BeforeExit;}
\DoxyCodeLine{07309                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"both"} )}
\DoxyCodeLine{07310                     config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;}
\DoxyCodeLine{07311                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{07312                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"keypress argument must be one of: start, exit or both. '"} + keypress + \textcolor{stringliteral}{"' not recognised"} );}
\DoxyCodeLine{07313             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{07314             \};}
\DoxyCodeLine{07315         \textcolor{keyword}{auto} \textcolor{keyword}{const} setVerbosity = [\&]( std::string \textcolor{keyword}{const}\& verbosity ) \{}
\DoxyCodeLine{07316             \textcolor{keyword}{auto} lcVerbosity = toLower( verbosity );}
\DoxyCodeLine{07317             \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"quiet"} )}
\DoxyCodeLine{07318                 config.verbosity = Verbosity::Quiet;}
\DoxyCodeLine{07319             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"normal"} )}
\DoxyCodeLine{07320                 config.verbosity = Verbosity::Normal;}
\DoxyCodeLine{07321             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"high"} )}
\DoxyCodeLine{07322                 config.verbosity = Verbosity::High;}
\DoxyCodeLine{07323             \textcolor{keywordflow}{else}}
\DoxyCodeLine{07324                 \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"Unrecognised verbosity, '"} + verbosity + \textcolor{stringliteral}{"'"} );}
\DoxyCodeLine{07325             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{07326         \};}
\DoxyCodeLine{07327         \textcolor{keyword}{auto} \textcolor{keyword}{const} setReporter = [\&]( std::string \textcolor{keyword}{const}\& reporter ) \{}
\DoxyCodeLine{07328             IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& factories = getRegistryHub().getReporterRegistry().getFactories();}
\DoxyCodeLine{07329 }
\DoxyCodeLine{07330             \textcolor{keyword}{auto} lcReporter = toLower( reporter );}
\DoxyCodeLine{07331             \textcolor{keyword}{auto} result = factories.find( lcReporter );}
\DoxyCodeLine{07332 }
\DoxyCodeLine{07333             \textcolor{keywordflow}{if}( factories.end() != result )}
\DoxyCodeLine{07334                 config.reporterName = lcReporter;}
\DoxyCodeLine{07335             \textcolor{keywordflow}{else}}
\DoxyCodeLine{07336                 \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"Unrecognized reporter, '"} + reporter + \textcolor{stringliteral}{"'. Check available with --list-reporters"} );}
\DoxyCodeLine{07337             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{07338         \};}
\DoxyCodeLine{07339 }
\DoxyCodeLine{07340         \textcolor{keyword}{auto} cli}
\DoxyCodeLine{07341             = ExeName( config.processName )}
\DoxyCodeLine{07342             | Help( config.showHelp )}
\DoxyCodeLine{07343             | Opt( config.listTests )}
\DoxyCodeLine{07344                 ["-l"]["--list-tests"]}
\DoxyCodeLine{07345                 ( \textcolor{stringliteral}{"list all/matching test cases"} )}
\DoxyCodeLine{07346             | Opt( config.listTags )}
\DoxyCodeLine{07347                 ["-t"]["--list-tags"]}
\DoxyCodeLine{07348                 ( \textcolor{stringliteral}{"list all/matching tags"} )}
\DoxyCodeLine{07349             | Opt( config.showSuccessfulTests )}
\DoxyCodeLine{07350                 ["-s"]["--success"]}
\DoxyCodeLine{07351                 ( \textcolor{stringliteral}{"include successful tests in output"} )}
\DoxyCodeLine{07352             | Opt( config.shouldDebugBreak )}
\DoxyCodeLine{07353                 ["-b"]["--break"]}
\DoxyCodeLine{07354                 ( \textcolor{stringliteral}{"break into debugger on failure"} )}
\DoxyCodeLine{07355             | Opt( config.noThrow )}
\DoxyCodeLine{07356                 ["-e"]["--nothrow"]}
\DoxyCodeLine{07357                 ( \textcolor{stringliteral}{"skip exception tests"} )}
\DoxyCodeLine{07358             | Opt( config.showInvisibles )}
\DoxyCodeLine{07359                 ["-i"]["--invisibles"]}
\DoxyCodeLine{07360                 ( \textcolor{stringliteral}{"show invisibles (tabs, newlines)"} )}
\DoxyCodeLine{07361             | Opt( config.outputFilename, \textcolor{stringliteral}{"filename"} )}
\DoxyCodeLine{07362                 ["-o"]["--out"]}
\DoxyCodeLine{07363                 ( \textcolor{stringliteral}{"output filename"} )}
\DoxyCodeLine{07364             | Opt( setReporter, \textcolor{stringliteral}{"name"} )}
\DoxyCodeLine{07365                 ["-r"]["--reporter"]}
\DoxyCodeLine{07366                 ( \textcolor{stringliteral}{"reporter to use (defaults to console)"} )}
\DoxyCodeLine{07367             | Opt( config.name, \textcolor{stringliteral}{"name"} )}
\DoxyCodeLine{07368                 ["-n"]["--name"]}
\DoxyCodeLine{07369                 ( \textcolor{stringliteral}{"suite name"} )}
\DoxyCodeLine{07370             | Opt( [\&]( \textcolor{keywordtype}{bool} )\{ config.abortAfter = 1; \} )}
\DoxyCodeLine{07371                 [\textcolor{stringliteral}{"-a"}][\textcolor{stringliteral}{"--abort"}]}
\DoxyCodeLine{07372                 ( \textcolor{stringliteral}{"abort at first failure"} )}
\DoxyCodeLine{07373             | Opt( [\&]( \textcolor{keywordtype}{int} x )\{ config.abortAfter = x; \}, \textcolor{stringliteral}{"no. failures"} )}
\DoxyCodeLine{07374                 [\textcolor{stringliteral}{"-x"}][\textcolor{stringliteral}{"--abortx"}]}
\DoxyCodeLine{07375                 ( \textcolor{stringliteral}{"abort after x failures"} )}
\DoxyCodeLine{07376             | Opt( setWarning, \textcolor{stringliteral}{"warning name"} )}
\DoxyCodeLine{07377                 ["-w"]["--warn"]}
\DoxyCodeLine{07378                 ( \textcolor{stringliteral}{"enable warnings"} )}
\DoxyCodeLine{07379             | Opt( [\&]( \textcolor{keywordtype}{bool} flag ) \{ config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; \}, \textcolor{stringliteral}{"yes|no"} )}
\DoxyCodeLine{07380                 [\textcolor{stringliteral}{"-d"}][\textcolor{stringliteral}{"--durations"}]}
\DoxyCodeLine{07381                 ( \textcolor{stringliteral}{"show test durations"} )}
\DoxyCodeLine{07382             | Opt( loadTestNamesFromFile, \textcolor{stringliteral}{"filename"} )}
\DoxyCodeLine{07383                 ["-f"]["--input-file"]}
\DoxyCodeLine{07384                 ( \textcolor{stringliteral}{"load test names to run from a file"} )}
\DoxyCodeLine{07385             | Opt( config.filenamesAsTags )}
\DoxyCodeLine{07386                 ["-\#"]["--filenames-as-tags"]}
\DoxyCodeLine{07387                 ( \textcolor{stringliteral}{"adds a tag for the filename"} )}
\DoxyCodeLine{07388             | Opt( config.sectionsToRun, \textcolor{stringliteral}{"section name"} )}
\DoxyCodeLine{07389                 ["-c"]["--section"]}
\DoxyCodeLine{07390                 ( \textcolor{stringliteral}{"specify section to run"} )}
\DoxyCodeLine{07391             | Opt( setVerbosity, \textcolor{stringliteral}{"quiet|normal|high"} )}
\DoxyCodeLine{07392                 ["-v"]["--verbosity"]}
\DoxyCodeLine{07393                 ( \textcolor{stringliteral}{"set output verbosity"} )}
\DoxyCodeLine{07394             | Opt( config.listTestNamesOnly )}
\DoxyCodeLine{07395                 ["--list-test-names-only"]}
\DoxyCodeLine{07396                 ( \textcolor{stringliteral}{"list all/matching test cases names only"} )}
\DoxyCodeLine{07397             | Opt( config.listReporters )}
\DoxyCodeLine{07398                 ["--list-reporters"]}
\DoxyCodeLine{07399                 ( \textcolor{stringliteral}{"list all reporters"} )}
\DoxyCodeLine{07400             | Opt( setTestOrder, \textcolor{stringliteral}{"decl|lex|rand"} )}
\DoxyCodeLine{07401                 ["--order"]}
\DoxyCodeLine{07402                 ( \textcolor{stringliteral}{"test case order (defaults to decl)"} )}
\DoxyCodeLine{07403             | Opt( setRngSeed, \textcolor{stringliteral}{"'time'|number"} )}
\DoxyCodeLine{07404                 ["--rng-seed"]}
\DoxyCodeLine{07405                 ( \textcolor{stringliteral}{"set a specific seed for random numbers"} )}
\DoxyCodeLine{07406             | Opt( setColourUsage, \textcolor{stringliteral}{"yes|no"} )}
\DoxyCodeLine{07407                 ["--use-colour"]}
\DoxyCodeLine{07408                 ( \textcolor{stringliteral}{"should output be colourised"} )}
\DoxyCodeLine{07409             | Opt( config.libIdentify )}
\DoxyCodeLine{07410                 ["--libidentify"]}
\DoxyCodeLine{07411                 ( \textcolor{stringliteral}{"report name and version according to libidentify standard"} )}
\DoxyCodeLine{07412             | Opt( setWaitForKeypress, \textcolor{stringliteral}{"start|exit|both"} )}
\DoxyCodeLine{07413                 ["--wait-for-keypress"]}
\DoxyCodeLine{07414                 ( \textcolor{stringliteral}{"waits for a keypress before exiting"} )}
\DoxyCodeLine{07415             | Opt( config.benchmarkResolutionMultiple, \textcolor{stringliteral}{"multiplier"} )}
\DoxyCodeLine{07416                 ["--benchmark-resolution-multiple"]}
\DoxyCodeLine{07417                 ( \textcolor{stringliteral}{"multiple of clock resolution to run benchmarks"} )}
\DoxyCodeLine{07418 }
\DoxyCodeLine{07419             | Arg( config.testsOrTags, \textcolor{stringliteral}{"test name|pattern|tags"} )}
\DoxyCodeLine{07420                 ( \textcolor{stringliteral}{"which test or tests to use"} );}
\DoxyCodeLine{07421 }
\DoxyCodeLine{07422         \textcolor{keywordflow}{return} cli;}
\DoxyCodeLine{07423     \}}
\DoxyCodeLine{07424 }
\DoxyCodeLine{07425 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{07426 \textcolor{comment}{// end catch\_commandline.cpp}}
\DoxyCodeLine{07427 \textcolor{comment}{// start catch\_common.cpp}}
\DoxyCodeLine{07428 }
\DoxyCodeLine{07429 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{07430 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{07431 }
\DoxyCodeLine{07432 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07433 }
\DoxyCodeLine{07434     \textcolor{keywordtype}{bool} SourceLineInfo::empty() const noexcept \{}
\DoxyCodeLine{07435         \textcolor{keywordflow}{return} file[0] == \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{07436     \}}
\DoxyCodeLine{07437     \textcolor{keywordtype}{bool} SourceLineInfo::operator == ( SourceLineInfo \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} noexcept \{}
\DoxyCodeLine{07438         \textcolor{keywordflow}{return} line == other.line \&\& (file == other.file || std::strcmp(file, other.file) == 0);}
\DoxyCodeLine{07439     \}}
\DoxyCodeLine{07440     \textcolor{keywordtype}{bool} SourceLineInfo::operator < ( SourceLineInfo \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} noexcept \{}
\DoxyCodeLine{07441         \textcolor{comment}{// We can assume that the same file will usually have the same pointer.}}
\DoxyCodeLine{07442         \textcolor{comment}{// Thus, if the pointers are the same, there is no point in calling the strcmp}}
\DoxyCodeLine{07443         \textcolor{keywordflow}{return} line < other.line || ( line == other.line \&\& file != other.file \&\& (std::strcmp(file, other.file) < 0));}
\DoxyCodeLine{07444     \}}
\DoxyCodeLine{07445 }
\DoxyCodeLine{07446     std::ostream\& operator << ( std::ostream\& os, SourceLineInfo \textcolor{keyword}{const}\& info ) \{}
\DoxyCodeLine{07447 \textcolor{preprocessor}{\#ifndef \_\_GNUG\_\_}}
\DoxyCodeLine{07448         os << info.file << \textcolor{charliteral}{'('} << info.line << \textcolor{charliteral}{')'};}
\DoxyCodeLine{07449 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{07450         os << info.file << \textcolor{charliteral}{':'} << info.line;}
\DoxyCodeLine{07451 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{07452         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{07453     \}}
\DoxyCodeLine{07454 }
\DoxyCodeLine{07455     std::string StreamEndStop::operator+()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{07456         \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{07457     \}}
\DoxyCodeLine{07458 }
\DoxyCodeLine{07459     NonCopyable::NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{07460     NonCopyable::~NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{07461 }
\DoxyCodeLine{07462 \}}
\DoxyCodeLine{07463 \textcolor{comment}{// end catch\_common.cpp}}
\DoxyCodeLine{07464 \textcolor{comment}{// start catch\_config.cpp}}
\DoxyCodeLine{07465 }
\DoxyCodeLine{07466 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07467 }
\DoxyCodeLine{07468     Config::Config( ConfigData \textcolor{keyword}{const}\& data )}
\DoxyCodeLine{07469     :   m\_data( data ),}
\DoxyCodeLine{07470         m\_stream( openStream() )}
\DoxyCodeLine{07471     \{}
\DoxyCodeLine{07472         TestSpecParser parser(ITagAliasRegistry::get());}
\DoxyCodeLine{07473         \textcolor{keywordflow}{if} (data.testsOrTags.empty()) \{}
\DoxyCodeLine{07474             parser.parse(\textcolor{stringliteral}{"~[.]"}); \textcolor{comment}{// All not hidden tests}}
\DoxyCodeLine{07475         \}}
\DoxyCodeLine{07476         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{07477             m\_hasTestFilters = \textcolor{keyword}{true};}
\DoxyCodeLine{07478             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testOrTags : data.testsOrTags )}
\DoxyCodeLine{07479                 parser.parse( testOrTags );}
\DoxyCodeLine{07480         \}}
\DoxyCodeLine{07481         m\_testSpec = parser.testSpec();}
\DoxyCodeLine{07482     \}}
\DoxyCodeLine{07483 }
\DoxyCodeLine{07484     std::string \textcolor{keyword}{const}\& Config::getFilename()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{07485         \textcolor{keywordflow}{return} m\_data.outputFilename ;}
\DoxyCodeLine{07486     \}}
\DoxyCodeLine{07487 }
\DoxyCodeLine{07488     \textcolor{keywordtype}{bool} Config::listTests()\textcolor{keyword}{ const          }\{ \textcolor{keywordflow}{return} m\_data.listTests; \}}
\DoxyCodeLine{07489     \textcolor{keywordtype}{bool} Config::listTestNamesOnly()\textcolor{keyword}{ const  }\{ \textcolor{keywordflow}{return} m\_data.listTestNamesOnly; \}}
\DoxyCodeLine{07490     \textcolor{keywordtype}{bool} Config::listTags()\textcolor{keyword}{ const           }\{ \textcolor{keywordflow}{return} m\_data.listTags; \}}
\DoxyCodeLine{07491     \textcolor{keywordtype}{bool} Config::listReporters()\textcolor{keyword}{ const      }\{ \textcolor{keywordflow}{return} m\_data.listReporters; \}}
\DoxyCodeLine{07492 }
\DoxyCodeLine{07493     std::string Config::getProcessName()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.processName; \}}
\DoxyCodeLine{07494     std::string \textcolor{keyword}{const}\& Config::getReporterName()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.reporterName; \}}
\DoxyCodeLine{07495 }
\DoxyCodeLine{07496     std::vector<std::string> \textcolor{keyword}{const}\& Config::getTestsOrTags()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.testsOrTags; \}}
\DoxyCodeLine{07497     std::vector<std::string> \textcolor{keyword}{const}\& Config::getSectionsToRun()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.sectionsToRun; \}}
\DoxyCodeLine{07498 }
\DoxyCodeLine{07499     TestSpec \textcolor{keyword}{const}\& Config::testSpec()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_testSpec; \}}
\DoxyCodeLine{07500     \textcolor{keywordtype}{bool} Config::hasTestFilters()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_hasTestFilters; \}}
\DoxyCodeLine{07501 }
\DoxyCodeLine{07502     \textcolor{keywordtype}{bool} Config::showHelp()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.showHelp; \}}
\DoxyCodeLine{07503 }
\DoxyCodeLine{07504     \textcolor{comment}{// IConfig interface}}
\DoxyCodeLine{07505     \textcolor{keywordtype}{bool} Config::allowThrows()\textcolor{keyword}{ const                   }\{ \textcolor{keywordflow}{return} !m\_data.noThrow; \}}
\DoxyCodeLine{07506     std::ostream\& Config::stream()\textcolor{keyword}{ const               }\{ \textcolor{keywordflow}{return} m\_stream->stream(); \}}
\DoxyCodeLine{07507     std::string Config::name()\textcolor{keyword}{ const                   }\{ \textcolor{keywordflow}{return} m\_data.name.empty() ? m\_data.processName : m\_data.name; \}}
\DoxyCodeLine{07508     \textcolor{keywordtype}{bool} Config::includeSuccessfulResults()\textcolor{keyword}{ const      }\{ \textcolor{keywordflow}{return} m\_data.showSuccessfulTests; \}}
\DoxyCodeLine{07509     \textcolor{keywordtype}{bool} Config::warnAboutMissingAssertions()\textcolor{keyword}{ const    }\{ \textcolor{keywordflow}{return} !!(m\_data.warnings \& WarnAbout::NoAssertions); \}}
\DoxyCodeLine{07510     \textcolor{keywordtype}{bool} Config::warnAboutNoTests()\textcolor{keyword}{ const              }\{ \textcolor{keywordflow}{return} !!(m\_data.warnings \& WarnAbout::NoTests); \}}
\DoxyCodeLine{07511     ShowDurations::OrNot Config::showDurations()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.showDurations; \}}
\DoxyCodeLine{07512     RunTests::InWhatOrder Config::runOrder()\textcolor{keyword}{ const     }\{ \textcolor{keywordflow}{return} m\_data.runOrder; \}}
\DoxyCodeLine{07513     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Config::rngSeed()\textcolor{keyword}{ const               }\{ \textcolor{keywordflow}{return} m\_data.rngSeed; \}}
\DoxyCodeLine{07514     \textcolor{keywordtype}{int} Config::benchmarkResolutionMultiple()\textcolor{keyword}{ const    }\{ \textcolor{keywordflow}{return} m\_data.benchmarkResolutionMultiple; \}}
\DoxyCodeLine{07515     UseColour::YesOrNo Config::useColour()\textcolor{keyword}{ const       }\{ \textcolor{keywordflow}{return} m\_data.useColour; \}}
\DoxyCodeLine{07516     \textcolor{keywordtype}{bool} Config::shouldDebugBreak()\textcolor{keyword}{ const              }\{ \textcolor{keywordflow}{return} m\_data.shouldDebugBreak; \}}
\DoxyCodeLine{07517     \textcolor{keywordtype}{int} Config::abortAfter()\textcolor{keyword}{ const                     }\{ \textcolor{keywordflow}{return} m\_data.abortAfter; \}}
\DoxyCodeLine{07518     \textcolor{keywordtype}{bool} Config::showInvisibles()\textcolor{keyword}{ const                }\{ \textcolor{keywordflow}{return} m\_data.showInvisibles; \}}
\DoxyCodeLine{07519     Verbosity Config::verbosity()\textcolor{keyword}{ const                }\{ \textcolor{keywordflow}{return} m\_data.verbosity; \}}
\DoxyCodeLine{07520 }
\DoxyCodeLine{07521     IStream \textcolor{keyword}{const}* Config::openStream() \{}
\DoxyCodeLine{07522         \textcolor{keywordflow}{return} Catch::makeStream(m\_data.outputFilename);}
\DoxyCodeLine{07523     \}}
\DoxyCodeLine{07524 }
\DoxyCodeLine{07525 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{07526 \textcolor{comment}{// end catch\_config.cpp}}
\DoxyCodeLine{07527 \textcolor{comment}{// start catch\_console\_colour.cpp}}
\DoxyCodeLine{07528 }
\DoxyCodeLine{07529 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{07530 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{07531 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "-Wexit-time-destructors"}}
\DoxyCodeLine{07532 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{07533 }
\DoxyCodeLine{07534 \textcolor{comment}{// start catch\_errno\_guard.h}}
\DoxyCodeLine{07535 }
\DoxyCodeLine{07536 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07537 }
\DoxyCodeLine{07538     \textcolor{keyword}{class }ErrnoGuard \{}
\DoxyCodeLine{07539     \textcolor{keyword}{public}:}
\DoxyCodeLine{07540         ErrnoGuard();}
\DoxyCodeLine{07541         ~ErrnoGuard();}
\DoxyCodeLine{07542     \textcolor{keyword}{private}:}
\DoxyCodeLine{07543         \textcolor{keywordtype}{int} m\_oldErrno;}
\DoxyCodeLine{07544     \};}
\DoxyCodeLine{07545 }
\DoxyCodeLine{07546 \}}
\DoxyCodeLine{07547 }
\DoxyCodeLine{07548 \textcolor{comment}{// end catch\_errno\_guard.h}}
\DoxyCodeLine{07549 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{07550 }
\DoxyCodeLine{07551 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07552     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{07553 }
\DoxyCodeLine{07554         \textcolor{keyword}{struct }IColourImpl \{}
\DoxyCodeLine{07555             \textcolor{keyword}{virtual} ~IColourImpl() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{07556             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} use( Colour::Code \_colourCode ) = 0;}
\DoxyCodeLine{07557         \};}
\DoxyCodeLine{07558 }
\DoxyCodeLine{07559         \textcolor{keyword}{struct }NoColourImpl : IColourImpl \{}
\DoxyCodeLine{07560             \textcolor{keywordtype}{void} use( Colour::Code ) \{\}}
\DoxyCodeLine{07561 }
\DoxyCodeLine{07562             \textcolor{keyword}{static} IColourImpl* instance() \{}
\DoxyCodeLine{07563                 \textcolor{keyword}{static} NoColourImpl s\_instance;}
\DoxyCodeLine{07564                 \textcolor{keywordflow}{return} \&s\_instance;}
\DoxyCodeLine{07565             \}}
\DoxyCodeLine{07566         \};}
\DoxyCodeLine{07567 }
\DoxyCodeLine{07568     \} \textcolor{comment}{// anon namespace}}
\DoxyCodeLine{07569 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{07570 }
\DoxyCodeLine{07571 \textcolor{preprocessor}{\#if !defined( CATCH\_CONFIG\_COLOUR\_NONE ) \&\& !defined( CATCH\_CONFIG\_COLOUR\_WINDOWS ) \&\& !defined( CATCH\_CONFIG\_COLOUR\_ANSI )}}
\DoxyCodeLine{07572 \textcolor{preprocessor}{\#   ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{07573 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_WINDOWS}}
\DoxyCodeLine{07574 \textcolor{preprocessor}{\#   else}}
\DoxyCodeLine{07575 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_ANSI}}
\DoxyCodeLine{07576 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{07577 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{07578 }
\DoxyCodeLine{07579 \textcolor{preprocessor}{\#if defined ( CATCH\_CONFIG\_COLOUR\_WINDOWS ) }}
\DoxyCodeLine{07580 \textcolor{preprocessor}{}}
\DoxyCodeLine{07581 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07582 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{07583 }
\DoxyCodeLine{07584     \textcolor{keyword}{class }Win32ColourImpl : \textcolor{keyword}{public} IColourImpl \{}
\DoxyCodeLine{07585     \textcolor{keyword}{public}:}
\DoxyCodeLine{07586         Win32ColourImpl() : stdoutHandle( GetStdHandle(STD\_OUTPUT\_HANDLE) )}
\DoxyCodeLine{07587         \{}
\DoxyCodeLine{07588             CONSOLE\_SCREEN\_BUFFER\_INFO csbiInfo;}
\DoxyCodeLine{07589             GetConsoleScreenBufferInfo( stdoutHandle, \&csbiInfo );}
\DoxyCodeLine{07590             originalForegroundAttributes = csbiInfo.wAttributes \& ~( BACKGROUND\_GREEN | BACKGROUND\_RED | BACKGROUND\_BLUE | BACKGROUND\_INTENSITY );}
\DoxyCodeLine{07591             originalBackgroundAttributes = csbiInfo.wAttributes \& ~( FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE | FOREGROUND\_INTENSITY );}
\DoxyCodeLine{07592         \}}
\DoxyCodeLine{07593 }
\DoxyCodeLine{07594         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} use( Colour::Code \_colourCode )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{07595             \textcolor{keywordflow}{switch}( \_colourCode ) \{}
\DoxyCodeLine{07596                 \textcolor{keywordflow}{case} Colour::None:      \textcolor{keywordflow}{return} setTextAttribute( originalForegroundAttributes );}
\DoxyCodeLine{07597                 \textcolor{keywordflow}{case} Colour::White:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE );}
\DoxyCodeLine{07598                 \textcolor{keywordflow}{case} Colour::Red:       \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_RED );}
\DoxyCodeLine{07599                 \textcolor{keywordflow}{case} Colour::Green:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_GREEN );}
\DoxyCodeLine{07600                 \textcolor{keywordflow}{case} Colour::Blue:      \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_BLUE );}
\DoxyCodeLine{07601                 \textcolor{keywordflow}{case} Colour::Cyan:      \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_BLUE | FOREGROUND\_GREEN );}
\DoxyCodeLine{07602                 \textcolor{keywordflow}{case} Colour::Yellow:    \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_RED | FOREGROUND\_GREEN );}
\DoxyCodeLine{07603                 \textcolor{keywordflow}{case} Colour::Grey:      \textcolor{keywordflow}{return} setTextAttribute( 0 );}
\DoxyCodeLine{07604 }
\DoxyCodeLine{07605                 \textcolor{keywordflow}{case} Colour::LightGrey:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY );}
\DoxyCodeLine{07606                 \textcolor{keywordflow}{case} Colour::BrightRed:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_RED );}
\DoxyCodeLine{07607                 \textcolor{keywordflow}{case} Colour::BrightGreen:   \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_GREEN );}
\DoxyCodeLine{07608                 \textcolor{keywordflow}{case} Colour::BrightWhite:   \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE );}
\DoxyCodeLine{07609                 \textcolor{keywordflow}{case} Colour::BrightYellow:  \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_RED | FOREGROUND\_GREEN );}
\DoxyCodeLine{07610 }
\DoxyCodeLine{07611                 \textcolor{keywordflow}{case} Colour::Bright: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"not a colour"} );}
\DoxyCodeLine{07612 }
\DoxyCodeLine{07613                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{07614                     CATCH\_ERROR( \textcolor{stringliteral}{"Unknown colour requested"} );}
\DoxyCodeLine{07615             \}}
\DoxyCodeLine{07616         \}}
\DoxyCodeLine{07617 }
\DoxyCodeLine{07618     \textcolor{keyword}{private}:}
\DoxyCodeLine{07619         \textcolor{keywordtype}{void} setTextAttribute( WORD \_textAttribute ) \{}
\DoxyCodeLine{07620             SetConsoleTextAttribute( stdoutHandle, \_textAttribute | originalBackgroundAttributes );}
\DoxyCodeLine{07621         \}}
\DoxyCodeLine{07622         HANDLE stdoutHandle;}
\DoxyCodeLine{07623         WORD originalForegroundAttributes;}
\DoxyCodeLine{07624         WORD originalBackgroundAttributes;}
\DoxyCodeLine{07625     \};}
\DoxyCodeLine{07626 }
\DoxyCodeLine{07627     IColourImpl* platformColourInstance() \{}
\DoxyCodeLine{07628         \textcolor{keyword}{static} Win32ColourImpl s\_instance;}
\DoxyCodeLine{07629 }
\DoxyCodeLine{07630         IConfigPtr config = getCurrentContext().getConfig();}
\DoxyCodeLine{07631         UseColour::YesOrNo colourMode = config}
\DoxyCodeLine{07632             ? config->useColour()}
\DoxyCodeLine{07633             : UseColour::Auto;}
\DoxyCodeLine{07634         \textcolor{keywordflow}{if}( colourMode == UseColour::Auto )}
\DoxyCodeLine{07635             colourMode = UseColour::Yes;}
\DoxyCodeLine{07636         \textcolor{keywordflow}{return} colourMode == UseColour::Yes}
\DoxyCodeLine{07637             ? \&s\_instance}
\DoxyCodeLine{07638             : NoColourImpl::instance();}
\DoxyCodeLine{07639     \}}
\DoxyCodeLine{07640 }
\DoxyCodeLine{07641 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{07642 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{07643 }
\DoxyCodeLine{07644 \textcolor{preprocessor}{\#elif defined( CATCH\_CONFIG\_COLOUR\_ANSI ) }}
\DoxyCodeLine{07645 \textcolor{preprocessor}{}}
\DoxyCodeLine{07646 \textcolor{preprocessor}{\#include <unistd.h>}}
\DoxyCodeLine{07647 }
\DoxyCodeLine{07648 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07649 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{07650 }
\DoxyCodeLine{07651     \textcolor{comment}{// use POSIX/ ANSI console terminal codes}}
\DoxyCodeLine{07652     \textcolor{comment}{// Thanks to Adam Strzelecki for original contribution}}
\DoxyCodeLine{07653     \textcolor{comment}{// (http://github.com/nanoant)}}
\DoxyCodeLine{07654     \textcolor{comment}{// https://github.com/philsquared/Catch/pull/131}}
\DoxyCodeLine{07655     \textcolor{keyword}{class }PosixColourImpl : \textcolor{keyword}{public} IColourImpl \{}
\DoxyCodeLine{07656     \textcolor{keyword}{public}:}
\DoxyCodeLine{07657         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} use( Colour::Code \_colourCode )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{07658             \textcolor{keywordflow}{switch}( \_colourCode ) \{}
\DoxyCodeLine{07659                 \textcolor{keywordflow}{case} Colour::None:}
\DoxyCodeLine{07660                 \textcolor{keywordflow}{case} Colour::White:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[0m"} );}
\DoxyCodeLine{07661                 \textcolor{keywordflow}{case} Colour::Red:       \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[0;31m"} );}
\DoxyCodeLine{07662                 \textcolor{keywordflow}{case} Colour::Green:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[0;32m"} );}
\DoxyCodeLine{07663                 \textcolor{keywordflow}{case} Colour::Blue:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[0;34m"} );}
\DoxyCodeLine{07664                 \textcolor{keywordflow}{case} Colour::Cyan:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[0;36m"} );}
\DoxyCodeLine{07665                 \textcolor{keywordflow}{case} Colour::Yellow:    \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[0;33m"} );}
\DoxyCodeLine{07666                 \textcolor{keywordflow}{case} Colour::Grey:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[1;30m"} );}
\DoxyCodeLine{07667 }
\DoxyCodeLine{07668                 \textcolor{keywordflow}{case} Colour::LightGrey:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[0;37m"} );}
\DoxyCodeLine{07669                 \textcolor{keywordflow}{case} Colour::BrightRed:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[1;31m"} );}
\DoxyCodeLine{07670                 \textcolor{keywordflow}{case} Colour::BrightGreen:   \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[1;32m"} );}
\DoxyCodeLine{07671                 \textcolor{keywordflow}{case} Colour::BrightWhite:   \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[1;37m"} );}
\DoxyCodeLine{07672                 \textcolor{keywordflow}{case} Colour::BrightYellow:  \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"[1;33m"} );}
\DoxyCodeLine{07673 }
\DoxyCodeLine{07674                 \textcolor{keywordflow}{case} Colour::Bright: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"not a colour"} );}
\DoxyCodeLine{07675                 \textcolor{keywordflow}{default}: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"Unknown colour requested"} );}
\DoxyCodeLine{07676             \}}
\DoxyCodeLine{07677         \}}
\DoxyCodeLine{07678         \textcolor{keyword}{static} IColourImpl* instance() \{}
\DoxyCodeLine{07679             \textcolor{keyword}{static} PosixColourImpl s\_instance;}
\DoxyCodeLine{07680             \textcolor{keywordflow}{return} \&s\_instance;}
\DoxyCodeLine{07681         \}}
\DoxyCodeLine{07682 }
\DoxyCodeLine{07683     \textcolor{keyword}{private}:}
\DoxyCodeLine{07684         \textcolor{keywordtype}{void} setColour( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \_escapeCode ) \{}
\DoxyCodeLine{07685             Catch::cout() << \textcolor{charliteral}{'\(\backslash\)033'} << \_escapeCode;}
\DoxyCodeLine{07686         \}}
\DoxyCodeLine{07687     \};}
\DoxyCodeLine{07688 }
\DoxyCodeLine{07689     \textcolor{keywordtype}{bool} useColourOnPlatform() \{}
\DoxyCodeLine{07690         \textcolor{keywordflow}{return}}
\DoxyCodeLine{07691 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{07692             !isDebuggerActive() \&\&}
\DoxyCodeLine{07693 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{07694 \textcolor{preprocessor}{\#if !(defined(\_\_DJGPP\_\_) \&\& defined(\_\_STRICT\_ANSI\_\_))}}
\DoxyCodeLine{07695             isatty(STDOUT\_FILENO)}
\DoxyCodeLine{07696 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{07697             \textcolor{keyword}{false}}
\DoxyCodeLine{07698 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{07699             ;}
\DoxyCodeLine{07700     \}}
\DoxyCodeLine{07701     IColourImpl* platformColourInstance() \{}
\DoxyCodeLine{07702         ErrnoGuard guard;}
\DoxyCodeLine{07703         IConfigPtr config = getCurrentContext().getConfig();}
\DoxyCodeLine{07704         UseColour::YesOrNo colourMode = config}
\DoxyCodeLine{07705             ? config->useColour()}
\DoxyCodeLine{07706             : UseColour::Auto;}
\DoxyCodeLine{07707         \textcolor{keywordflow}{if}( colourMode == UseColour::Auto )}
\DoxyCodeLine{07708             colourMode = useColourOnPlatform()}
\DoxyCodeLine{07709                 ? UseColour::Yes}
\DoxyCodeLine{07710                 : UseColour::No;}
\DoxyCodeLine{07711         \textcolor{keywordflow}{return} colourMode == UseColour::Yes}
\DoxyCodeLine{07712             ? PosixColourImpl::instance()}
\DoxyCodeLine{07713             : NoColourImpl::instance();}
\DoxyCodeLine{07714     \}}
\DoxyCodeLine{07715 }
\DoxyCodeLine{07716 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{07717 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{07718 }
\DoxyCodeLine{07719 \textcolor{preprocessor}{\#else  // not Windows or ANSI }}
\DoxyCodeLine{07720 \textcolor{preprocessor}{}}
\DoxyCodeLine{07721 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07722 }
\DoxyCodeLine{07723     \textcolor{keyword}{static} IColourImpl* platformColourInstance() \{ \textcolor{keywordflow}{return} NoColourImpl::instance(); \}}
\DoxyCodeLine{07724 }
\DoxyCodeLine{07725 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{07726 }
\DoxyCodeLine{07727 \textcolor{preprocessor}{\#endif // Windows/ ANSI/ None}}
\DoxyCodeLine{07728 }
\DoxyCodeLine{07729 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07730 }
\DoxyCodeLine{07731     Colour::Colour( Code \_colourCode ) \{ use( \_colourCode ); \}}
\DoxyCodeLine{07732     Colour::Colour( Colour\&\& rhs ) noexcept \{}
\DoxyCodeLine{07733         m\_moved = rhs.m\_moved;}
\DoxyCodeLine{07734         rhs.m\_moved = \textcolor{keyword}{true};}
\DoxyCodeLine{07735     \}}
\DoxyCodeLine{07736     Colour\& Colour::operator=( Colour\&\& rhs ) noexcept \{}
\DoxyCodeLine{07737         m\_moved = rhs.m\_moved;}
\DoxyCodeLine{07738         rhs.m\_moved  = \textcolor{keyword}{true};}
\DoxyCodeLine{07739         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{07740     \}}
\DoxyCodeLine{07741 }
\DoxyCodeLine{07742     Colour::~Colour()\{ \textcolor{keywordflow}{if}( !m\_moved ) use( None ); \}}
\DoxyCodeLine{07743 }
\DoxyCodeLine{07744     \textcolor{keywordtype}{void} Colour::use( Code \_colourCode ) \{}
\DoxyCodeLine{07745         \textcolor{keyword}{static} IColourImpl* impl = platformColourInstance();}
\DoxyCodeLine{07746         impl->use( \_colourCode );}
\DoxyCodeLine{07747     \}}
\DoxyCodeLine{07748 }
\DoxyCodeLine{07749     std::ostream\& operator << ( std::ostream\& os, Colour \textcolor{keyword}{const}\& ) \{}
\DoxyCodeLine{07750         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{07751     \}}
\DoxyCodeLine{07752 }
\DoxyCodeLine{07753 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{07754 }
\DoxyCodeLine{07755 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{07756 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{07757 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{07758 }
\DoxyCodeLine{07759 \textcolor{comment}{// end catch\_console\_colour.cpp}}
\DoxyCodeLine{07760 \textcolor{comment}{// start catch\_context.cpp}}
\DoxyCodeLine{07761 }
\DoxyCodeLine{07762 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07763 }
\DoxyCodeLine{07764     \textcolor{keyword}{class }Context : \textcolor{keyword}{public} IMutableContext, NonCopyable \{}
\DoxyCodeLine{07765 }
\DoxyCodeLine{07766     \textcolor{keyword}{public}: \textcolor{comment}{// IContext}}
\DoxyCodeLine{07767         \textcolor{keyword}{virtual} IResultCapture* getResultCapture()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{07768             \textcolor{keywordflow}{return} m\_resultCapture;}
\DoxyCodeLine{07769         \}}
\DoxyCodeLine{07770         \textcolor{keyword}{virtual} IRunner* getRunner()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{07771             \textcolor{keywordflow}{return} m\_runner;}
\DoxyCodeLine{07772         \}}
\DoxyCodeLine{07773 }
\DoxyCodeLine{07774         \textcolor{keyword}{virtual} IConfigPtr \textcolor{keyword}{const}\& getConfig()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{07775             \textcolor{keywordflow}{return} m\_config;}
\DoxyCodeLine{07776         \}}
\DoxyCodeLine{07777 }
\DoxyCodeLine{07778         \textcolor{keyword}{virtual} ~Context() \textcolor{keyword}{override};}
\DoxyCodeLine{07779 }
\DoxyCodeLine{07780     \textcolor{keyword}{public}: \textcolor{comment}{// IMutableContext}}
\DoxyCodeLine{07781         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setResultCapture( IResultCapture* resultCapture )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{07782             m\_resultCapture = resultCapture;}
\DoxyCodeLine{07783         \}}
\DoxyCodeLine{07784         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setRunner( IRunner* runner )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{07785             m\_runner = runner;}
\DoxyCodeLine{07786         \}}
\DoxyCodeLine{07787         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setConfig( IConfigPtr \textcolor{keyword}{const}\& config )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{07788             m\_config = config;}
\DoxyCodeLine{07789         \}}
\DoxyCodeLine{07790 }
\DoxyCodeLine{07791         \textcolor{keyword}{friend} IMutableContext\& getCurrentMutableContext();}
\DoxyCodeLine{07792 }
\DoxyCodeLine{07793     \textcolor{keyword}{private}:}
\DoxyCodeLine{07794         IConfigPtr m\_config;}
\DoxyCodeLine{07795         IRunner* m\_runner = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{07796         IResultCapture* m\_resultCapture = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{07797     \};}
\DoxyCodeLine{07798 }
\DoxyCodeLine{07799     IMutableContext *IMutableContext::currentContext = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{07800 }
\DoxyCodeLine{07801     \textcolor{keywordtype}{void} IMutableContext::createContext()}
\DoxyCodeLine{07802     \{}
\DoxyCodeLine{07803         currentContext = \textcolor{keyword}{new} Context();}
\DoxyCodeLine{07804     \}}
\DoxyCodeLine{07805 }
\DoxyCodeLine{07806     \textcolor{keywordtype}{void} cleanUpContext() \{}
\DoxyCodeLine{07807         \textcolor{keyword}{delete} IMutableContext::currentContext;}
\DoxyCodeLine{07808         IMutableContext::currentContext = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{07809     \}}
\DoxyCodeLine{07810     IContext::~IContext() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{07811     IMutableContext::~IMutableContext() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{07812     Context::~Context() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{07813 \}}
\DoxyCodeLine{07814 \textcolor{comment}{// end catch\_context.cpp}}
\DoxyCodeLine{07815 \textcolor{comment}{// start catch\_debug\_console.cpp}}
\DoxyCodeLine{07816 }
\DoxyCodeLine{07817 \textcolor{comment}{// start catch\_debug\_console.h}}
\DoxyCodeLine{07818 }
\DoxyCodeLine{07819 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{07820 }
\DoxyCodeLine{07821 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07822     \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text );}
\DoxyCodeLine{07823 \}}
\DoxyCodeLine{07824 }
\DoxyCodeLine{07825 \textcolor{comment}{// end catch\_debug\_console.h}}
\DoxyCodeLine{07826 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{07827 }
\DoxyCodeLine{07828     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07829         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{07830             ::OutputDebugStringA( text.c\_str() );}
\DoxyCodeLine{07831         \}}
\DoxyCodeLine{07832     \}}
\DoxyCodeLine{07833 }
\DoxyCodeLine{07834 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{07835 }
\DoxyCodeLine{07836     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07837         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{07838             \textcolor{comment}{// !TBD: Need a version for Mac/ XCode and other IDEs}}
\DoxyCodeLine{07839             Catch::cout() << text;}
\DoxyCodeLine{07840         \}}
\DoxyCodeLine{07841     \}}
\DoxyCodeLine{07842 }
\DoxyCodeLine{07843 \textcolor{preprocessor}{\#endif // Platform}}
\DoxyCodeLine{07844 \textcolor{comment}{// end catch\_debug\_console.cpp}}
\DoxyCodeLine{07845 \textcolor{comment}{// start catch\_debugger.cpp}}
\DoxyCodeLine{07846 }
\DoxyCodeLine{07847 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{07848 }
\DoxyCodeLine{07849 \textcolor{preprocessor}{\#  include <assert.h>}}
\DoxyCodeLine{07850 \textcolor{preprocessor}{\#  include <stdbool.h>}}
\DoxyCodeLine{07851 \textcolor{preprocessor}{\#  include <sys/types.h>}}
\DoxyCodeLine{07852 \textcolor{preprocessor}{\#  include <unistd.h>}}
\DoxyCodeLine{07853 \textcolor{preprocessor}{\#  include <sys/sysctl.h>}}
\DoxyCodeLine{07854 \textcolor{preprocessor}{\#  include <cstddef>}}
\DoxyCodeLine{07855 \textcolor{preprocessor}{\#  include <ostream>}}
\DoxyCodeLine{07856 }
\DoxyCodeLine{07857 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07858 }
\DoxyCodeLine{07859         \textcolor{comment}{// The following function is taken directly from the following technical note:}}
\DoxyCodeLine{07860         \textcolor{comment}{// http://developer.apple.com/library/mac/\#qa/qa2004/qa1361.html}}
\DoxyCodeLine{07861 }
\DoxyCodeLine{07862         \textcolor{comment}{// Returns true if the current process is being debugged (either}}
\DoxyCodeLine{07863         \textcolor{comment}{// running under the debugger or has a debugger attached post facto).}}
\DoxyCodeLine{07864         \textcolor{keywordtype}{bool} isDebuggerActive()\{}
\DoxyCodeLine{07865 }
\DoxyCodeLine{07866             \textcolor{keywordtype}{int}                 mib[4];}
\DoxyCodeLine{07867             \textcolor{keyword}{struct }kinfo\_proc   info;}
\DoxyCodeLine{07868             std::size\_t         size;}
\DoxyCodeLine{07869 }
\DoxyCodeLine{07870             \textcolor{comment}{// Initialize the flags so that, if sysctl fails for some bizarre}}
\DoxyCodeLine{07871             \textcolor{comment}{// reason, we get a predictable result.}}
\DoxyCodeLine{07872 }
\DoxyCodeLine{07873             info.kp\_proc.p\_flag = 0;}
\DoxyCodeLine{07874 }
\DoxyCodeLine{07875             \textcolor{comment}{// Initialize mib, which tells sysctl the info we want, in this case}}
\DoxyCodeLine{07876             \textcolor{comment}{// we're looking for information about a specific process ID.}}
\DoxyCodeLine{07877 }
\DoxyCodeLine{07878             mib[0] = CTL\_KERN;}
\DoxyCodeLine{07879             mib[1] = KERN\_PROC;}
\DoxyCodeLine{07880             mib[2] = KERN\_PROC\_PID;}
\DoxyCodeLine{07881             mib[3] = getpid();}
\DoxyCodeLine{07882 }
\DoxyCodeLine{07883             \textcolor{comment}{// Call sysctl.}}
\DoxyCodeLine{07884 }
\DoxyCodeLine{07885             size = \textcolor{keyword}{sizeof}(info);}
\DoxyCodeLine{07886             \textcolor{keywordflow}{if}( sysctl(mib, \textcolor{keyword}{sizeof}(mib) / \textcolor{keyword}{sizeof}(*mib), \&info, \&size, \textcolor{keyword}{nullptr}, 0) != 0 ) \{}
\DoxyCodeLine{07887                 Catch::cerr() << \textcolor{stringliteral}{"\(\backslash\)n** Call to sysctl failed - unable to determine if debugger is active **\(\backslash\)n"} << std::endl;}
\DoxyCodeLine{07888                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{07889             \}}
\DoxyCodeLine{07890 }
\DoxyCodeLine{07891             \textcolor{comment}{// We're being debugged if the P\_TRACED flag is set.}}
\DoxyCodeLine{07892 }
\DoxyCodeLine{07893             \textcolor{keywordflow}{return} ( (info.kp\_proc.p\_flag \& P\_TRACED) != 0 );}
\DoxyCodeLine{07894         \}}
\DoxyCodeLine{07895     \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{07896 }
\DoxyCodeLine{07897 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_LINUX)}}
\DoxyCodeLine{07898 \textcolor{preprocessor}{    \#include <fstream>}}
\DoxyCodeLine{07899 \textcolor{preprocessor}{    \#include <string>}}
\DoxyCodeLine{07900 }
\DoxyCodeLine{07901     \textcolor{keyword}{namespace }Catch\{}
\DoxyCodeLine{07902         \textcolor{comment}{// The standard POSIX way of detecting a debugger is to attempt to}}
\DoxyCodeLine{07903         \textcolor{comment}{// ptrace() the process, but this needs to be done from a child and not}}
\DoxyCodeLine{07904         \textcolor{comment}{// this process itself to still allow attaching to this process later}}
\DoxyCodeLine{07905         \textcolor{comment}{// if wanted, so is rather heavy. Under Linux we have the PID of the}}
\DoxyCodeLine{07906         \textcolor{comment}{// "debugger" (which doesn't need to be gdb, of course, it could also}}
\DoxyCodeLine{07907         \textcolor{comment}{// be strace, for example) in /proc/\$PID/status, so just get it from}}
\DoxyCodeLine{07908         \textcolor{comment}{// there instead.}}
\DoxyCodeLine{07909         \textcolor{keywordtype}{bool} isDebuggerActive()\{}
\DoxyCodeLine{07910             \textcolor{comment}{// Libstdc++ has a bug, where std::ifstream sets errno to 0}}
\DoxyCodeLine{07911             \textcolor{comment}{// This way our users can properly assert over errno values}}
\DoxyCodeLine{07912             ErrnoGuard guard;}
\DoxyCodeLine{07913             std::ifstream in(\textcolor{stringliteral}{"/proc/self/status"});}
\DoxyCodeLine{07914             \textcolor{keywordflow}{for}( std::string line; std::getline(in, line); ) \{}
\DoxyCodeLine{07915                 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PREFIX\_LEN = 11;}
\DoxyCodeLine{07916                 \textcolor{keywordflow}{if}( line.compare(0, PREFIX\_LEN, \textcolor{stringliteral}{"TracerPid:\(\backslash\)t"}) == 0 ) \{}
\DoxyCodeLine{07917                     \textcolor{comment}{// We're traced if the PID is not 0 and no other PID starts}}
\DoxyCodeLine{07918                     \textcolor{comment}{// with 0 digit, so it's enough to check for just a single}}
\DoxyCodeLine{07919                     \textcolor{comment}{// character.}}
\DoxyCodeLine{07920                     \textcolor{keywordflow}{return} line.length() > PREFIX\_LEN \&\& line[PREFIX\_LEN] != \textcolor{charliteral}{'0'};}
\DoxyCodeLine{07921                 \}}
\DoxyCodeLine{07922             \}}
\DoxyCodeLine{07923 }
\DoxyCodeLine{07924             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{07925         \}}
\DoxyCodeLine{07926     \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{07927 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{07928     \textcolor{keyword}{extern} \textcolor{stringliteral}{"C"} \_\_declspec(dllimport) \textcolor{keywordtype}{int} \_\_stdcall IsDebuggerPresent();}
\DoxyCodeLine{07929     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07930         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{07931             \textcolor{keywordflow}{return} IsDebuggerPresent() != 0;}
\DoxyCodeLine{07932         \}}
\DoxyCodeLine{07933     \}}
\DoxyCodeLine{07934 \textcolor{preprocessor}{\#elif defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{07935     \textcolor{keyword}{extern} \textcolor{stringliteral}{"C"} \_\_declspec(dllimport) \textcolor{keywordtype}{int} \_\_stdcall IsDebuggerPresent();}
\DoxyCodeLine{07936     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07937         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{07938             \textcolor{keywordflow}{return} IsDebuggerPresent() != 0;}
\DoxyCodeLine{07939         \}}
\DoxyCodeLine{07940     \}}
\DoxyCodeLine{07941 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{07942     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07943        \textcolor{keywordtype}{bool} isDebuggerActive() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{07944     \}}
\DoxyCodeLine{07945 \textcolor{preprocessor}{\#endif // Platform}}
\DoxyCodeLine{07946 \textcolor{comment}{// end catch\_debugger.cpp}}
\DoxyCodeLine{07947 \textcolor{comment}{// start catch\_decomposer.cpp}}
\DoxyCodeLine{07948 }
\DoxyCodeLine{07949 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07950 }
\DoxyCodeLine{07951     ITransientExpression::~ITransientExpression() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{07952 }
\DoxyCodeLine{07953     \textcolor{keywordtype}{void} formatReconstructedExpression( std::ostream \&os, std::string \textcolor{keyword}{const}\& lhs, StringRef op, std::string \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{07954         \textcolor{keywordflow}{if}( lhs.size() + rhs.size() < 40 \&\&}
\DoxyCodeLine{07955                 lhs.find('\(\backslash\)n') == std::string::npos \&\&}
\DoxyCodeLine{07956                 rhs.find('\(\backslash\)n') == std::string::npos )}
\DoxyCodeLine{07957             os << lhs << " " << op << " " << rhs;}
\DoxyCodeLine{07958         \textcolor{keywordflow}{else}}
\DoxyCodeLine{07959             os << lhs << \textcolor{stringliteral}{"\(\backslash\)n"} << op << \textcolor{stringliteral}{"\(\backslash\)n"} << rhs;}
\DoxyCodeLine{07960     \}}
\DoxyCodeLine{07961 \}}
\DoxyCodeLine{07962 \textcolor{comment}{// end catch\_decomposer.cpp}}
\DoxyCodeLine{07963 \textcolor{comment}{// start catch\_enforce.cpp}}
\DoxyCodeLine{07964 }
\DoxyCodeLine{07965 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07966 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS) \&\& !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS\_CUSTOM\_HANDLER)}}
\DoxyCodeLine{07967     [[noreturn]]}
\DoxyCodeLine{07968     \textcolor{keywordtype}{void} throw\_exception(std::exception \textcolor{keyword}{const}\& e) \{}
\DoxyCodeLine{07969         Catch::cerr() << \textcolor{stringliteral}{"Catch will terminate because it needed to throw an exception.\(\backslash\)n"}}
\DoxyCodeLine{07970                       << \textcolor{stringliteral}{"The message was: "} << e.what() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{07971         std::terminate();}
\DoxyCodeLine{07972     \}}
\DoxyCodeLine{07973 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{07974 \} \textcolor{comment}{// namespace Catch;}}
\DoxyCodeLine{07975 \textcolor{comment}{// end catch\_enforce.cpp}}
\DoxyCodeLine{07976 \textcolor{comment}{// start catch\_errno\_guard.cpp}}
\DoxyCodeLine{07977 }
\DoxyCodeLine{07978 \textcolor{preprocessor}{\#include <cerrno>}}
\DoxyCodeLine{07979 }
\DoxyCodeLine{07980 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07981         ErrnoGuard::ErrnoGuard():m\_oldErrno(errno)\{\}}
\DoxyCodeLine{07982         ErrnoGuard::~ErrnoGuard() \{ errno = m\_oldErrno; \}}
\DoxyCodeLine{07983 \}}
\DoxyCodeLine{07984 \textcolor{comment}{// end catch\_errno\_guard.cpp}}
\DoxyCodeLine{07985 \textcolor{comment}{// start catch\_exception\_translator\_registry.cpp}}
\DoxyCodeLine{07986 }
\DoxyCodeLine{07987 \textcolor{comment}{// start catch\_exception\_translator\_registry.h}}
\DoxyCodeLine{07988 }
\DoxyCodeLine{07989 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{07990 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{07991 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{07992 }
\DoxyCodeLine{07993 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{07994 }
\DoxyCodeLine{07995     \textcolor{keyword}{class }ExceptionTranslatorRegistry : \textcolor{keyword}{public} IExceptionTranslatorRegistry \{}
\DoxyCodeLine{07996     \textcolor{keyword}{public}:}
\DoxyCodeLine{07997         ~ExceptionTranslatorRegistry();}
\DoxyCodeLine{07998         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator );}
\DoxyCodeLine{07999         \textcolor{keyword}{virtual} std::string translateActiveException() \textcolor{keyword}{const override};}
\DoxyCodeLine{08000         std::string tryTranslators() \textcolor{keyword}{const};}
\DoxyCodeLine{08001 }
\DoxyCodeLine{08002     \textcolor{keyword}{private}:}
\DoxyCodeLine{08003         std::vector<std::unique\_ptr<IExceptionTranslator const>> m\_translators;}
\DoxyCodeLine{08004     \};}
\DoxyCodeLine{08005 \}}
\DoxyCodeLine{08006 }
\DoxyCodeLine{08007 \textcolor{comment}{// end catch\_exception\_translator\_registry.h}}
\DoxyCodeLine{08008 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{08009 \textcolor{preprocessor}{\#import "Foundation/Foundation.h"}}
\DoxyCodeLine{08010 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{08011 }
\DoxyCodeLine{08012 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08013 }
\DoxyCodeLine{08014     ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() \{}
\DoxyCodeLine{08015     \}}
\DoxyCodeLine{08016 }
\DoxyCodeLine{08017     \textcolor{keywordtype}{void} ExceptionTranslatorRegistry::registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator ) \{}
\DoxyCodeLine{08018         m\_translators.push\_back( std::unique\_ptr<const IExceptionTranslator>( translator ) );}
\DoxyCodeLine{08019     \}}
\DoxyCodeLine{08020 }
\DoxyCodeLine{08021 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{08022     std::string ExceptionTranslatorRegistry::translateActiveException()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08023         \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{08024 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{08025             \textcolor{comment}{// In Objective-C try objective-c exceptions first}}
\DoxyCodeLine{08026             \textcolor{keywordflow}{@try} \{}
\DoxyCodeLine{08027                 \textcolor{keywordflow}{return} tryTranslators();}
\DoxyCodeLine{08028             \}}
\DoxyCodeLine{08029             \textcolor{keywordflow}{@catch} (NSException *exception) \{}
\DoxyCodeLine{08030                 \textcolor{keywordflow}{return} Catch::Detail::stringify( [exception description] );}
\DoxyCodeLine{08031             \}}
\DoxyCodeLine{08032 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{08033             \textcolor{comment}{// Compiling a mixed mode project with MSVC means that CLR}}
\DoxyCodeLine{08034             \textcolor{comment}{// exceptions will be caught in (...) as well. However, these}}
\DoxyCodeLine{08035             \textcolor{comment}{// do not fill-in std::current\_exception and thus lead to crash}}
\DoxyCodeLine{08036             \textcolor{comment}{// when attempting rethrow.}}
\DoxyCodeLine{08037             \textcolor{comment}{// /EHa switch also causes structured exceptions to be caught}}
\DoxyCodeLine{08038             \textcolor{comment}{// here, but they fill-in current\_exception properly, so}}
\DoxyCodeLine{08039             \textcolor{comment}{// at worst the output should be a little weird, instead of}}
\DoxyCodeLine{08040             \textcolor{comment}{// causing a crash.}}
\DoxyCodeLine{08041             \textcolor{keywordflow}{if} (std::current\_exception() == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{08042                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Non C++ exception. Possibly a CLR exception."};}
\DoxyCodeLine{08043             \}}
\DoxyCodeLine{08044             \textcolor{keywordflow}{return} tryTranslators();}
\DoxyCodeLine{08045 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{08046         \}}
\DoxyCodeLine{08047         \textcolor{keywordflow}{catch}( TestFailureException\& ) \{}
\DoxyCodeLine{08048             std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{08049         \}}
\DoxyCodeLine{08050         \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{08051             \textcolor{keywordflow}{return} ex.what();}
\DoxyCodeLine{08052         \}}
\DoxyCodeLine{08053         \textcolor{keywordflow}{catch}( std::string\& msg ) \{}
\DoxyCodeLine{08054             \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{08055         \}}
\DoxyCodeLine{08056         \textcolor{keywordflow}{catch}( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* msg ) \{}
\DoxyCodeLine{08057             \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{08058         \}}
\DoxyCodeLine{08059         \textcolor{keywordflow}{catch}(...) \{}
\DoxyCodeLine{08060             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Unknown exception"};}
\DoxyCodeLine{08061         \}}
\DoxyCodeLine{08062     \}}
\DoxyCodeLine{08063 }
\DoxyCodeLine{08064 \textcolor{preprocessor}{\#else // \string^\string^ Exceptions are enabled // Exceptions are disabled vv}}
\DoxyCodeLine{08065     std::string ExceptionTranslatorRegistry::translateActiveException()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08066         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"Attempted to translate active exception under CATCH\_CONFIG\_DISABLE\_EXCEPTIONS!"});}
\DoxyCodeLine{08067     \}}
\DoxyCodeLine{08068 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{08069 }
\DoxyCodeLine{08070     std::string ExceptionTranslatorRegistry::tryTranslators()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08071         \textcolor{keywordflow}{if}( m\_translators.empty() )}
\DoxyCodeLine{08072             std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{08073         \textcolor{keywordflow}{else}}
\DoxyCodeLine{08074             \textcolor{keywordflow}{return} m\_translators[0]->translate( m\_translators.begin()+1, m\_translators.end() );}
\DoxyCodeLine{08075     \}}
\DoxyCodeLine{08076 \}}
\DoxyCodeLine{08077 \textcolor{comment}{// end catch\_exception\_translator\_registry.cpp}}
\DoxyCodeLine{08078 \textcolor{comment}{// start catch\_fatal\_condition.cpp}}
\DoxyCodeLine{08079 }
\DoxyCodeLine{08080 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{08081 \textcolor{preprocessor}{\#    pragma GCC diagnostic push}}
\DoxyCodeLine{08082 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "-Wmissing-field-initializers"}}
\DoxyCodeLine{08083 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{08084 }
\DoxyCodeLine{08085 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH ) || defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{08086 }
\DoxyCodeLine{08087 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{08088     \textcolor{comment}{// Report the error condition}}
\DoxyCodeLine{08089     \textcolor{keywordtype}{void} reportFatal( \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} message ) \{}
\DoxyCodeLine{08090         Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );}
\DoxyCodeLine{08091     \}}
\DoxyCodeLine{08092 \}}
\DoxyCodeLine{08093 }
\DoxyCodeLine{08094 \textcolor{preprocessor}{\#endif // signals/SEH handling}}
\DoxyCodeLine{08095 }
\DoxyCodeLine{08096 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH )}}
\DoxyCodeLine{08097 }
\DoxyCodeLine{08098 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08099     \textcolor{keyword}{struct }SignalDefs \{ DWORD id; \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name; \};}
\DoxyCodeLine{08100 }
\DoxyCodeLine{08101     \textcolor{comment}{// There is no 1-1 mapping between signals and windows exceptions.}}
\DoxyCodeLine{08102     \textcolor{comment}{// Windows can easily distinguish between SO and SigSegV,}}
\DoxyCodeLine{08103     \textcolor{comment}{// but SigInt, SigTerm, etc are handled differently.}}
\DoxyCodeLine{08104     \textcolor{keyword}{static} SignalDefs signalDefs[] = \{}
\DoxyCodeLine{08105         \{ EXCEPTION\_ILLEGAL\_INSTRUCTION,  \textcolor{stringliteral}{"SIGILL - Illegal instruction signal"} \},}
\DoxyCodeLine{08106         \{ EXCEPTION\_STACK\_OVERFLOW, \textcolor{stringliteral}{"SIGSEGV - Stack overflow"} \},}
\DoxyCodeLine{08107         \{ EXCEPTION\_ACCESS\_VIOLATION, \textcolor{stringliteral}{"SIGSEGV - Segmentation violation signal"} \},}
\DoxyCodeLine{08108         \{ EXCEPTION\_INT\_DIVIDE\_BY\_ZERO, \textcolor{stringliteral}{"Divide by zero error"} \},}
\DoxyCodeLine{08109     \};}
\DoxyCodeLine{08110 }
\DoxyCodeLine{08111     LONG CALLBACK FatalConditionHandler::handleVectoredException(PEXCEPTION\_POINTERS ExceptionInfo) \{}
\DoxyCodeLine{08112         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& def : signalDefs) \{}
\DoxyCodeLine{08113             \textcolor{keywordflow}{if} (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) \{}
\DoxyCodeLine{08114                 reportFatal(def.name);}
\DoxyCodeLine{08115             \}}
\DoxyCodeLine{08116         \}}
\DoxyCodeLine{08117         \textcolor{comment}{// If its not an exception we care about, pass it along.}}
\DoxyCodeLine{08118         \textcolor{comment}{// This stops us from eating debugger breaks etc.}}
\DoxyCodeLine{08119         \textcolor{keywordflow}{return} EXCEPTION\_CONTINUE\_SEARCH;}
\DoxyCodeLine{08120     \}}
\DoxyCodeLine{08121 }
\DoxyCodeLine{08122     FatalConditionHandler::FatalConditionHandler() \{}
\DoxyCodeLine{08123         isSet = \textcolor{keyword}{true};}
\DoxyCodeLine{08124         \textcolor{comment}{// 32k seems enough for Catch to handle stack overflow,}}
\DoxyCodeLine{08125         \textcolor{comment}{// but the value was found experimentally, so there is no strong guarantee}}
\DoxyCodeLine{08126         guaranteeSize = 32 * 1024;}
\DoxyCodeLine{08127         exceptionHandlerHandle = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{08128         \textcolor{comment}{// Register as first handler in current chain}}
\DoxyCodeLine{08129         exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);}
\DoxyCodeLine{08130         \textcolor{comment}{// Pass in guarantee size to be filled}}
\DoxyCodeLine{08131         SetThreadStackGuarantee(\&guaranteeSize);}
\DoxyCodeLine{08132     \}}
\DoxyCodeLine{08133 }
\DoxyCodeLine{08134     \textcolor{keywordtype}{void} FatalConditionHandler::reset() \{}
\DoxyCodeLine{08135         \textcolor{keywordflow}{if} (isSet) \{}
\DoxyCodeLine{08136             RemoveVectoredExceptionHandler(exceptionHandlerHandle);}
\DoxyCodeLine{08137             SetThreadStackGuarantee(\&guaranteeSize);}
\DoxyCodeLine{08138             exceptionHandlerHandle = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{08139             isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{08140         \}}
\DoxyCodeLine{08141     \}}
\DoxyCodeLine{08142 }
\DoxyCodeLine{08143     FatalConditionHandler::~FatalConditionHandler() \{}
\DoxyCodeLine{08144         reset();}
\DoxyCodeLine{08145     \}}
\DoxyCodeLine{08146 }
\DoxyCodeLine{08147 \textcolor{keywordtype}{bool} FatalConditionHandler::isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{08148 ULONG FatalConditionHandler::guaranteeSize = 0;}
\DoxyCodeLine{08149 PVOID FatalConditionHandler::exceptionHandlerHandle = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{08150 }
\DoxyCodeLine{08151 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{08152 }
\DoxyCodeLine{08153 \textcolor{preprocessor}{\#elif defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{08154 }
\DoxyCodeLine{08155 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08156 }
\DoxyCodeLine{08157     \textcolor{keyword}{struct }SignalDefs \{}
\DoxyCodeLine{08158         \textcolor{keywordtype}{int} id;}
\DoxyCodeLine{08159         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name;}
\DoxyCodeLine{08160     \};}
\DoxyCodeLine{08161 }
\DoxyCodeLine{08162     \textcolor{comment}{// 32kb for the alternate stack seems to be sufficient. However, this value}}
\DoxyCodeLine{08163     \textcolor{comment}{// is experimentally determined, so that's not guaranteed.}}
\DoxyCodeLine{08164     constexpr \textcolor{keyword}{static} std::size\_t sigStackSize = 32768 >= MINSIGSTKSZ ? 32768 : MINSIGSTKSZ;}
\DoxyCodeLine{08165 }
\DoxyCodeLine{08166     \textcolor{keyword}{static} SignalDefs signalDefs[] = \{}
\DoxyCodeLine{08167         \{ SIGINT,  \textcolor{stringliteral}{"SIGINT - Terminal interrupt signal"} \},}
\DoxyCodeLine{08168         \{ SIGILL,  \textcolor{stringliteral}{"SIGILL - Illegal instruction signal"} \},}
\DoxyCodeLine{08169         \{ SIGFPE,  \textcolor{stringliteral}{"SIGFPE - Floating point error signal"} \},}
\DoxyCodeLine{08170         \{ SIGSEGV, \textcolor{stringliteral}{"SIGSEGV - Segmentation violation signal"} \},}
\DoxyCodeLine{08171         \{ SIGTERM, \textcolor{stringliteral}{"SIGTERM - Termination request signal"} \},}
\DoxyCodeLine{08172         \{ SIGABRT, \textcolor{stringliteral}{"SIGABRT - Abort (abnormal termination) signal"} \}}
\DoxyCodeLine{08173     \};}
\DoxyCodeLine{08174 }
\DoxyCodeLine{08175     \textcolor{keywordtype}{void} FatalConditionHandler::handleSignal( \textcolor{keywordtype}{int} sig ) \{}
\DoxyCodeLine{08176         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * name = \textcolor{stringliteral}{"<unknown signal>"};}
\DoxyCodeLine{08177         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& def : signalDefs) \{}
\DoxyCodeLine{08178             \textcolor{keywordflow}{if} (sig == def.id) \{}
\DoxyCodeLine{08179                 name = def.name;}
\DoxyCodeLine{08180                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{08181             \}}
\DoxyCodeLine{08182         \}}
\DoxyCodeLine{08183         reset();}
\DoxyCodeLine{08184         reportFatal(name);}
\DoxyCodeLine{08185         \textcolor{keyword}{raise}( sig );}
\DoxyCodeLine{08186     \}}
\DoxyCodeLine{08187 }
\DoxyCodeLine{08188     FatalConditionHandler::FatalConditionHandler() \{}
\DoxyCodeLine{08189         isSet = \textcolor{keyword}{true};}
\DoxyCodeLine{08190         stack\_t sigStack;}
\DoxyCodeLine{08191         sigStack.ss\_sp = altStackMem;}
\DoxyCodeLine{08192         sigStack.ss\_size = sigStackSize;}
\DoxyCodeLine{08193         sigStack.ss\_flags = 0;}
\DoxyCodeLine{08194         sigaltstack(\&sigStack, \&oldSigStack);}
\DoxyCodeLine{08195         \textcolor{keyword}{struct }sigaction sa = \{ \};}
\DoxyCodeLine{08196 }
\DoxyCodeLine{08197         sa.sa\_handler = handleSignal;}
\DoxyCodeLine{08198         sa.sa\_flags = SA\_ONSTACK;}
\DoxyCodeLine{08199         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(signalDefs)/\textcolor{keyword}{sizeof}(SignalDefs); ++i) \{}
\DoxyCodeLine{08200             sigaction(signalDefs[i].\textcolor{keywordtype}{id}, \&sa, \&oldSigActions[i]);}
\DoxyCodeLine{08201         \}}
\DoxyCodeLine{08202     \}}
\DoxyCodeLine{08203 }
\DoxyCodeLine{08204     FatalConditionHandler::~FatalConditionHandler() \{}
\DoxyCodeLine{08205         reset();}
\DoxyCodeLine{08206     \}}
\DoxyCodeLine{08207 }
\DoxyCodeLine{08208     \textcolor{keywordtype}{void} FatalConditionHandler::reset() \{}
\DoxyCodeLine{08209         \textcolor{keywordflow}{if}( isSet ) \{}
\DoxyCodeLine{08210             \textcolor{comment}{// Set signals back to previous values -- hopefully nobody overwrote them in the meantime}}
\DoxyCodeLine{08211             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(signalDefs)/\textcolor{keyword}{sizeof}(SignalDefs); ++i ) \{}
\DoxyCodeLine{08212                 sigaction(signalDefs[i].\textcolor{keywordtype}{id}, \&oldSigActions[i], \textcolor{keyword}{nullptr});}
\DoxyCodeLine{08213             \}}
\DoxyCodeLine{08214             \textcolor{comment}{// Return the old stack}}
\DoxyCodeLine{08215             sigaltstack(\&oldSigStack, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{08216             isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{08217         \}}
\DoxyCodeLine{08218     \}}
\DoxyCodeLine{08219 }
\DoxyCodeLine{08220     \textcolor{keywordtype}{bool} FatalConditionHandler::isSet = \textcolor{keyword}{false};}
\DoxyCodeLine{08221     \textcolor{keyword}{struct }sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = \{\};}
\DoxyCodeLine{08222     stack\_t FatalConditionHandler::oldSigStack = \{\};}
\DoxyCodeLine{08223     \textcolor{keywordtype}{char} FatalConditionHandler::altStackMem[sigStackSize] = \{\};}
\DoxyCodeLine{08224 }
\DoxyCodeLine{08225 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{08226 }
\DoxyCodeLine{08227 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{08228 }
\DoxyCodeLine{08229 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08230     \textcolor{keywordtype}{void} FatalConditionHandler::reset() \{\}}
\DoxyCodeLine{08231 \}}
\DoxyCodeLine{08232 }
\DoxyCodeLine{08233 \textcolor{preprocessor}{\#endif // signals/SEH handling}}
\DoxyCodeLine{08234 }
\DoxyCodeLine{08235 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{08236 \textcolor{preprocessor}{\#    pragma GCC diagnostic pop}}
\DoxyCodeLine{08237 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{08238 \textcolor{comment}{// end catch\_fatal\_condition.cpp}}
\DoxyCodeLine{08239 \textcolor{comment}{// start catch\_generators.cpp}}
\DoxyCodeLine{08240 }
\DoxyCodeLine{08241 \textcolor{comment}{// start catch\_random\_number\_generator.h}}
\DoxyCodeLine{08242 }
\DoxyCodeLine{08243 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{08244 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{08245 }
\DoxyCodeLine{08246 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08247 }
\DoxyCodeLine{08248     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{08249 }
\DoxyCodeLine{08250     std::mt19937\& rng();}
\DoxyCodeLine{08251     \textcolor{keywordtype}{void} seedRng( IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{08252     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed();}
\DoxyCodeLine{08253 }
\DoxyCodeLine{08254 \}}
\DoxyCodeLine{08255 }
\DoxyCodeLine{08256 \textcolor{comment}{// end catch\_random\_number\_generator.h}}
\DoxyCodeLine{08257 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{08258 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{08259 }
\DoxyCodeLine{08260 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08261 }
\DoxyCodeLine{08262 IGeneratorTracker::~IGeneratorTracker() \{\}}
\DoxyCodeLine{08263 }
\DoxyCodeLine{08264 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{08265 }
\DoxyCodeLine{08266     GeneratorBase::~GeneratorBase() \{\}}
\DoxyCodeLine{08267 }
\DoxyCodeLine{08268     std::vector<size\_t> randomiseIndices( \textcolor{keywordtype}{size\_t} selectionSize, \textcolor{keywordtype}{size\_t} sourceSize ) \{}
\DoxyCodeLine{08269 }
\DoxyCodeLine{08270         assert( selectionSize <= sourceSize );}
\DoxyCodeLine{08271         std::vector<size\_t> indices;}
\DoxyCodeLine{08272         indices.reserve( selectionSize );}
\DoxyCodeLine{08273         std::uniform\_int\_distribution<size\_t> uid( 0, sourceSize-1 );}
\DoxyCodeLine{08274 }
\DoxyCodeLine{08275         std::set<size\_t> seen;}
\DoxyCodeLine{08276         \textcolor{comment}{// !TBD: improve this algorithm}}
\DoxyCodeLine{08277         \textcolor{keywordflow}{while}( indices.size() < selectionSize ) \{}
\DoxyCodeLine{08278             \textcolor{keyword}{auto} index = uid( rng() );}
\DoxyCodeLine{08279             \textcolor{keywordflow}{if}( seen.insert( index ).second )}
\DoxyCodeLine{08280                 indices.push\_back( index );}
\DoxyCodeLine{08281         \}}
\DoxyCodeLine{08282         \textcolor{keywordflow}{return} indices;}
\DoxyCodeLine{08283     \}}
\DoxyCodeLine{08284 }
\DoxyCodeLine{08285     \textcolor{keyword}{auto} acquireGeneratorTracker( SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -> IGeneratorTracker\& \{}
\DoxyCodeLine{08286         \textcolor{keywordflow}{return} getResultCapture().acquireGeneratorTracker( lineInfo );}
\DoxyCodeLine{08287     \}}
\DoxyCodeLine{08288 }
\DoxyCodeLine{08289     \textcolor{keyword}{template}<>}
\DoxyCodeLine{08290     \textcolor{keyword}{auto} all<int>() -> Generator<int> \{}
\DoxyCodeLine{08291         \textcolor{keywordflow}{return} range( std::numeric\_limits<int>::min(), std::numeric\_limits<int>::max() );}
\DoxyCodeLine{08292     \}}
\DoxyCodeLine{08293 }
\DoxyCodeLine{08294 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{08295 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{08296 \textcolor{comment}{// end catch\_generators.cpp}}
\DoxyCodeLine{08297 \textcolor{comment}{// start catch\_interfaces\_capture.cpp}}
\DoxyCodeLine{08298 }
\DoxyCodeLine{08299 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08300     IResultCapture::~IResultCapture() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08301 \}}
\DoxyCodeLine{08302 \textcolor{comment}{// end catch\_interfaces\_capture.cpp}}
\DoxyCodeLine{08303 \textcolor{comment}{// start catch\_interfaces\_config.cpp}}
\DoxyCodeLine{08304 }
\DoxyCodeLine{08305 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08306     IConfig::~IConfig() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08307 \}}
\DoxyCodeLine{08308 \textcolor{comment}{// end catch\_interfaces\_config.cpp}}
\DoxyCodeLine{08309 \textcolor{comment}{// start catch\_interfaces\_exception.cpp}}
\DoxyCodeLine{08310 }
\DoxyCodeLine{08311 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08312     IExceptionTranslator::~IExceptionTranslator() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08313     IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08314 \}}
\DoxyCodeLine{08315 \textcolor{comment}{// end catch\_interfaces\_exception.cpp}}
\DoxyCodeLine{08316 \textcolor{comment}{// start catch\_interfaces\_registry\_hub.cpp}}
\DoxyCodeLine{08317 }
\DoxyCodeLine{08318 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08319     IRegistryHub::~IRegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08320     IMutableRegistryHub::~IMutableRegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08321 \}}
\DoxyCodeLine{08322 \textcolor{comment}{// end catch\_interfaces\_registry\_hub.cpp}}
\DoxyCodeLine{08323 \textcolor{comment}{// start catch\_interfaces\_reporter.cpp}}
\DoxyCodeLine{08324 }
\DoxyCodeLine{08325 \textcolor{comment}{// start catch\_reporter\_listening.h}}
\DoxyCodeLine{08326 }
\DoxyCodeLine{08327 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08328 }
\DoxyCodeLine{08329     \textcolor{keyword}{class }ListeningReporter : \textcolor{keyword}{public} IStreamingReporter \{}
\DoxyCodeLine{08330         \textcolor{keyword}{using} Reporters = std::vector<IStreamingReporterPtr>;}
\DoxyCodeLine{08331         Reporters m\_listeners;}
\DoxyCodeLine{08332         IStreamingReporterPtr m\_reporter = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{08333         ReporterPreferences m\_preferences;}
\DoxyCodeLine{08334 }
\DoxyCodeLine{08335     \textcolor{keyword}{public}:}
\DoxyCodeLine{08336         ListeningReporter();}
\DoxyCodeLine{08337 }
\DoxyCodeLine{08338         \textcolor{keywordtype}{void} addListener( IStreamingReporterPtr\&\& listener );}
\DoxyCodeLine{08339         \textcolor{keywordtype}{void} addReporter( IStreamingReporterPtr\&\& reporter );}
\DoxyCodeLine{08340 }
\DoxyCodeLine{08341     \textcolor{keyword}{public}: \textcolor{comment}{// IStreamingReporter}}
\DoxyCodeLine{08342 }
\DoxyCodeLine{08343         ReporterPreferences getPreferences() \textcolor{keyword}{const override};}
\DoxyCodeLine{08344 }
\DoxyCodeLine{08345         \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) \textcolor{keyword}{override};}
\DoxyCodeLine{08346 }
\DoxyCodeLine{08347         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities();}
\DoxyCodeLine{08348 }
\DoxyCodeLine{08349         \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& benchmarkInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{08350         \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats \textcolor{keyword}{const}\& benchmarkStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{08351 }
\DoxyCodeLine{08352         \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{08353         \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{08354         \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{08355         \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{08356         \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{08357 }
\DoxyCodeLine{08358         \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{08359         \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{08360         \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{08361         \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{08362         \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{08363         \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{08364 }
\DoxyCodeLine{08365         \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{08366         \textcolor{keywordtype}{bool} isMulti() \textcolor{keyword}{const override};}
\DoxyCodeLine{08367 }
\DoxyCodeLine{08368     \};}
\DoxyCodeLine{08369 }
\DoxyCodeLine{08370 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{08371 }
\DoxyCodeLine{08372 \textcolor{comment}{// end catch\_reporter\_listening.h}}
\DoxyCodeLine{08373 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08374 }
\DoxyCodeLine{08375     ReporterConfig::ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig )}
\DoxyCodeLine{08376     :   m\_stream( \&\_fullConfig->stream() ), m\_fullConfig( \_fullConfig ) \{\}}
\DoxyCodeLine{08377 }
\DoxyCodeLine{08378     ReporterConfig::ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig, std::ostream\& \_stream )}
\DoxyCodeLine{08379     :   m\_stream( \&\_stream ), m\_fullConfig( \_fullConfig ) \{\}}
\DoxyCodeLine{08380 }
\DoxyCodeLine{08381     std::ostream\& ReporterConfig::stream()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *m\_stream; \}}
\DoxyCodeLine{08382     IConfigPtr ReporterConfig::fullConfig()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_fullConfig; \}}
\DoxyCodeLine{08383 }
\DoxyCodeLine{08384     TestRunInfo::TestRunInfo( std::string \textcolor{keyword}{const}\& \_name ) : name( \_name ) \{\}}
\DoxyCodeLine{08385 }
\DoxyCodeLine{08386     GroupInfo::GroupInfo(  std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{08387                            std::size\_t \_groupIndex,}
\DoxyCodeLine{08388                            std::size\_t \_groupsCount )}
\DoxyCodeLine{08389     :   name( \_name ),}
\DoxyCodeLine{08390         groupIndex( \_groupIndex ),}
\DoxyCodeLine{08391         groupsCounts( \_groupsCount )}
\DoxyCodeLine{08392     \{\}}
\DoxyCodeLine{08393 }
\DoxyCodeLine{08394      AssertionStats::AssertionStats( AssertionResult \textcolor{keyword}{const}\& \_assertionResult,}
\DoxyCodeLine{08395                                      std::vector<MessageInfo> \textcolor{keyword}{const}\& \_infoMessages,}
\DoxyCodeLine{08396                                      Totals \textcolor{keyword}{const}\& \_totals )}
\DoxyCodeLine{08397     :   assertionResult( \_assertionResult ),}
\DoxyCodeLine{08398         infoMessages( \_infoMessages ),}
\DoxyCodeLine{08399         totals( \_totals )}
\DoxyCodeLine{08400     \{}
\DoxyCodeLine{08401         assertionResult.m\_resultData.lazyExpression.m\_transientExpression = \_assertionResult.m\_resultData.lazyExpression.m\_transientExpression;}
\DoxyCodeLine{08402 }
\DoxyCodeLine{08403         \textcolor{keywordflow}{if}( assertionResult.hasMessage() ) \{}
\DoxyCodeLine{08404             \textcolor{comment}{// Copy message into messages list.}}
\DoxyCodeLine{08405             \textcolor{comment}{// !TBD This should have been done earlier, somewhere}}
\DoxyCodeLine{08406             MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );}
\DoxyCodeLine{08407             builder << assertionResult.getMessage();}
\DoxyCodeLine{08408             builder.m\_info.message = builder.m\_stream.str();}
\DoxyCodeLine{08409 }
\DoxyCodeLine{08410             infoMessages.push\_back( builder.m\_info );}
\DoxyCodeLine{08411         \}}
\DoxyCodeLine{08412     \}}
\DoxyCodeLine{08413 }
\DoxyCodeLine{08414      AssertionStats::~AssertionStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08415 }
\DoxyCodeLine{08416     SectionStats::SectionStats(  SectionInfo \textcolor{keyword}{const}\& \_sectionInfo,}
\DoxyCodeLine{08417                                  Counts \textcolor{keyword}{const}\& \_assertions,}
\DoxyCodeLine{08418                                  \textcolor{keywordtype}{double} \_durationInSeconds,}
\DoxyCodeLine{08419                                  \textcolor{keywordtype}{bool} \_missingAssertions )}
\DoxyCodeLine{08420     :   sectionInfo( \_sectionInfo ),}
\DoxyCodeLine{08421         assertions( \_assertions ),}
\DoxyCodeLine{08422         durationInSeconds( \_durationInSeconds ),}
\DoxyCodeLine{08423         missingAssertions( \_missingAssertions )}
\DoxyCodeLine{08424     \{\}}
\DoxyCodeLine{08425 }
\DoxyCodeLine{08426     SectionStats::~SectionStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08427 }
\DoxyCodeLine{08428     TestCaseStats::TestCaseStats(  TestCaseInfo \textcolor{keyword}{const}\& \_testInfo,}
\DoxyCodeLine{08429                                    Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{08430                                    std::string \textcolor{keyword}{const}\& \_stdOut,}
\DoxyCodeLine{08431                                    std::string \textcolor{keyword}{const}\& \_stdErr,}
\DoxyCodeLine{08432                                    \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{08433     : testInfo( \_testInfo ),}
\DoxyCodeLine{08434         totals( \_totals ),}
\DoxyCodeLine{08435         stdOut( \_stdOut ),}
\DoxyCodeLine{08436         stdErr( \_stdErr ),}
\DoxyCodeLine{08437         aborting( \_aborting )}
\DoxyCodeLine{08438     \{\}}
\DoxyCodeLine{08439 }
\DoxyCodeLine{08440     TestCaseStats::~TestCaseStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08441 }
\DoxyCodeLine{08442     TestGroupStats::TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo,}
\DoxyCodeLine{08443                                     Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{08444                                     \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{08445     :   groupInfo( \_groupInfo ),}
\DoxyCodeLine{08446         totals( \_totals ),}
\DoxyCodeLine{08447         aborting( \_aborting )}
\DoxyCodeLine{08448     \{\}}
\DoxyCodeLine{08449 }
\DoxyCodeLine{08450     TestGroupStats::TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo )}
\DoxyCodeLine{08451     :   groupInfo( \_groupInfo ),}
\DoxyCodeLine{08452         aborting( false )}
\DoxyCodeLine{08453     \{\}}
\DoxyCodeLine{08454 }
\DoxyCodeLine{08455     TestGroupStats::~TestGroupStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08456 }
\DoxyCodeLine{08457     TestRunStats::TestRunStats(   TestRunInfo \textcolor{keyword}{const}\& \_runInfo,}
\DoxyCodeLine{08458                     Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{08459                     \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{08460     :   runInfo( \_runInfo ),}
\DoxyCodeLine{08461         totals( \_totals ),}
\DoxyCodeLine{08462         aborting( \_aborting )}
\DoxyCodeLine{08463     \{\}}
\DoxyCodeLine{08464 }
\DoxyCodeLine{08465     TestRunStats::~TestRunStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08466 }
\DoxyCodeLine{08467     \textcolor{keywordtype}{void} IStreamingReporter::fatalErrorEncountered( StringRef ) \{\}}
\DoxyCodeLine{08468     \textcolor{keywordtype}{bool} IStreamingReporter::isMulti()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{08469 }
\DoxyCodeLine{08470     IReporterFactory::~IReporterFactory() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08471     IReporterRegistry::~IReporterRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08472 }
\DoxyCodeLine{08473 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{08474 \textcolor{comment}{// end catch\_interfaces\_reporter.cpp}}
\DoxyCodeLine{08475 \textcolor{comment}{// start catch\_interfaces\_runner.cpp}}
\DoxyCodeLine{08476 }
\DoxyCodeLine{08477 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08478     IRunner::~IRunner() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08479 \}}
\DoxyCodeLine{08480 \textcolor{comment}{// end catch\_interfaces\_runner.cpp}}
\DoxyCodeLine{08481 \textcolor{comment}{// start catch\_interfaces\_testcase.cpp}}
\DoxyCodeLine{08482 }
\DoxyCodeLine{08483 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08484     ITestInvoker::~ITestInvoker() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08485     ITestCaseRegistry::~ITestCaseRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08486 \}}
\DoxyCodeLine{08487 \textcolor{comment}{// end catch\_interfaces\_testcase.cpp}}
\DoxyCodeLine{08488 \textcolor{comment}{// start catch\_leak\_detector.cpp}}
\DoxyCodeLine{08489 }
\DoxyCodeLine{08490 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WINDOWS\_CRTDBG}}
\DoxyCodeLine{08491 \textcolor{preprocessor}{\#include <crtdbg.h>}}
\DoxyCodeLine{08492 }
\DoxyCodeLine{08493 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08494 }
\DoxyCodeLine{08495     LeakDetector::LeakDetector() \{}
\DoxyCodeLine{08496         \textcolor{keywordtype}{int} flag = \_CrtSetDbgFlag(\_CRTDBG\_REPORT\_FLAG);}
\DoxyCodeLine{08497         flag |= \_CRTDBG\_LEAK\_CHECK\_DF;}
\DoxyCodeLine{08498         flag |= \_CRTDBG\_ALLOC\_MEM\_DF;}
\DoxyCodeLine{08499         \_CrtSetDbgFlag(flag);}
\DoxyCodeLine{08500         \_CrtSetReportMode(\_CRT\_WARN, \_CRTDBG\_MODE\_FILE | \_CRTDBG\_MODE\_DEBUG);}
\DoxyCodeLine{08501         \_CrtSetReportFile(\_CRT\_WARN, \_CRTDBG\_FILE\_STDERR);}
\DoxyCodeLine{08502         \textcolor{comment}{// Change this to leaking allocation's number to break there}}
\DoxyCodeLine{08503         \_CrtSetBreakAlloc(-1);}
\DoxyCodeLine{08504     \}}
\DoxyCodeLine{08505 \}}
\DoxyCodeLine{08506 }
\DoxyCodeLine{08507 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{08508 }
\DoxyCodeLine{08509     Catch::LeakDetector::LeakDetector() \{\}}
\DoxyCodeLine{08510 }
\DoxyCodeLine{08511 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{08512 }
\DoxyCodeLine{08513 Catch::LeakDetector::~LeakDetector() \{}
\DoxyCodeLine{08514     Catch::cleanUp();}
\DoxyCodeLine{08515 \}}
\DoxyCodeLine{08516 \textcolor{comment}{// end catch\_leak\_detector.cpp}}
\DoxyCodeLine{08517 \textcolor{comment}{// start catch\_list.cpp}}
\DoxyCodeLine{08518 }
\DoxyCodeLine{08519 \textcolor{comment}{// start catch\_list.h}}
\DoxyCodeLine{08520 }
\DoxyCodeLine{08521 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{08522 }
\DoxyCodeLine{08523 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08524 }
\DoxyCodeLine{08525     std::size\_t listTests( Config \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{08526 }
\DoxyCodeLine{08527     std::size\_t listTestsNamesOnly( Config \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{08528 }
\DoxyCodeLine{08529     \textcolor{keyword}{struct }TagInfo \{}
\DoxyCodeLine{08530         \textcolor{keywordtype}{void} add( std::string \textcolor{keyword}{const}\& spelling );}
\DoxyCodeLine{08531         std::string all() \textcolor{keyword}{const};}
\DoxyCodeLine{08532 }
\DoxyCodeLine{08533         std::set<std::string> spellings;}
\DoxyCodeLine{08534         std::size\_t count = 0;}
\DoxyCodeLine{08535     \};}
\DoxyCodeLine{08536 }
\DoxyCodeLine{08537     std::size\_t listTags( Config \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{08538 }
\DoxyCodeLine{08539     std::size\_t listReporters();}
\DoxyCodeLine{08540 }
\DoxyCodeLine{08541     Option<std::size\_t> list( Config \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{08542 }
\DoxyCodeLine{08543 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{08544 }
\DoxyCodeLine{08545 \textcolor{comment}{// end catch\_list.h}}
\DoxyCodeLine{08546 \textcolor{comment}{// start catch\_text.h}}
\DoxyCodeLine{08547 }
\DoxyCodeLine{08548 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08549     \textcolor{keyword}{using namespace }clara::TextFlow;}
\DoxyCodeLine{08550 \}}
\DoxyCodeLine{08551 }
\DoxyCodeLine{08552 \textcolor{comment}{// end catch\_text.h}}
\DoxyCodeLine{08553 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{08554 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{08555 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{08556 }
\DoxyCodeLine{08557 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08558 }
\DoxyCodeLine{08559     std::size\_t listTests( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{08560         TestSpec testSpec = config.testSpec();}
\DoxyCodeLine{08561         \textcolor{keywordflow}{if}( config.hasTestFilters() )}
\DoxyCodeLine{08562             Catch::cout() << \textcolor{stringliteral}{"Matching test cases:\(\backslash\)n"};}
\DoxyCodeLine{08563         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{08564             Catch::cout() << \textcolor{stringliteral}{"All available test cases:\(\backslash\)n"};}
\DoxyCodeLine{08565         \}}
\DoxyCodeLine{08566 }
\DoxyCodeLine{08567         \textcolor{keyword}{auto} matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{08568         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo : matchedTestCases ) \{}
\DoxyCodeLine{08569             Colour::Code colour = testCaseInfo.isHidden()}
\DoxyCodeLine{08570                 ? Colour::SecondaryText}
\DoxyCodeLine{08571                 : Colour::None;}
\DoxyCodeLine{08572             Colour colourGuard( colour );}
\DoxyCodeLine{08573 }
\DoxyCodeLine{08574             Catch::cout() << Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{08575             \textcolor{keywordflow}{if}( config.verbosity() >= Verbosity::High ) \{}
\DoxyCodeLine{08576                 Catch::cout() << Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) << std::endl;}
\DoxyCodeLine{08577                 std::string description = testCaseInfo.description;}
\DoxyCodeLine{08578                 \textcolor{keywordflow}{if}( description.empty() )}
\DoxyCodeLine{08579                     description = \textcolor{stringliteral}{"(NO DESCRIPTION)"};}
\DoxyCodeLine{08580                 Catch::cout() << Column( description ).indent(4) << std::endl;}
\DoxyCodeLine{08581             \}}
\DoxyCodeLine{08582             \textcolor{keywordflow}{if}( !testCaseInfo.tags.empty() )}
\DoxyCodeLine{08583                 Catch::cout() << Column( testCaseInfo.tagsAsString() ).indent( 6 ) << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{08584         \}}
\DoxyCodeLine{08585 }
\DoxyCodeLine{08586         \textcolor{keywordflow}{if}( !config.hasTestFilters() )}
\DoxyCodeLine{08587             Catch::cout() << pluralise( matchedTestCases.size(), \textcolor{stringliteral}{"test case"} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{08588         \textcolor{keywordflow}{else}}
\DoxyCodeLine{08589             Catch::cout() << pluralise( matchedTestCases.size(), \textcolor{stringliteral}{"matching test case"} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{08590         \textcolor{keywordflow}{return} matchedTestCases.size();}
\DoxyCodeLine{08591     \}}
\DoxyCodeLine{08592 }
\DoxyCodeLine{08593     std::size\_t listTestsNamesOnly( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{08594         TestSpec testSpec = config.testSpec();}
\DoxyCodeLine{08595         std::size\_t matchedTests = 0;}
\DoxyCodeLine{08596         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{08597         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo : matchedTestCases ) \{}
\DoxyCodeLine{08598             matchedTests++;}
\DoxyCodeLine{08599             \textcolor{keywordflow}{if}( startsWith( testCaseInfo.name, \textcolor{charliteral}{'\#'} ) )}
\DoxyCodeLine{08600                Catch::cout() << \textcolor{charliteral}{'"'} << testCaseInfo.name << \textcolor{charliteral}{'"'};}
\DoxyCodeLine{08601             \textcolor{keywordflow}{else}}
\DoxyCodeLine{08602                Catch::cout() << testCaseInfo.name;}
\DoxyCodeLine{08603             \textcolor{keywordflow}{if} ( config.verbosity() >= Verbosity::High )}
\DoxyCodeLine{08604                 Catch::cout() << \textcolor{stringliteral}{"\(\backslash\)t@"} << testCaseInfo.lineInfo;}
\DoxyCodeLine{08605             Catch::cout() << std::endl;}
\DoxyCodeLine{08606         \}}
\DoxyCodeLine{08607         \textcolor{keywordflow}{return} matchedTests;}
\DoxyCodeLine{08608     \}}
\DoxyCodeLine{08609 }
\DoxyCodeLine{08610     \textcolor{keywordtype}{void} TagInfo::add( std::string \textcolor{keyword}{const}\& spelling ) \{}
\DoxyCodeLine{08611         ++count;}
\DoxyCodeLine{08612         spellings.insert( spelling );}
\DoxyCodeLine{08613     \}}
\DoxyCodeLine{08614 }
\DoxyCodeLine{08615     std::string TagInfo::all()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08616         std::string out;}
\DoxyCodeLine{08617         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& spelling : spellings )}
\DoxyCodeLine{08618             out += "[" + spelling + "]";}
\DoxyCodeLine{08619         \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{08620     \}}
\DoxyCodeLine{08621 }
\DoxyCodeLine{08622     std::size\_t listTags( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{08623         TestSpec testSpec = config.testSpec();}
\DoxyCodeLine{08624         \textcolor{keywordflow}{if}( config.hasTestFilters() )}
\DoxyCodeLine{08625             Catch::cout() << \textcolor{stringliteral}{"Tags for matching test cases:\(\backslash\)n"};}
\DoxyCodeLine{08626         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{08627             Catch::cout() << \textcolor{stringliteral}{"All available tags:\(\backslash\)n"};}
\DoxyCodeLine{08628         \}}
\DoxyCodeLine{08629 }
\DoxyCodeLine{08630         std::map<std::string, TagInfo> tagCounts;}
\DoxyCodeLine{08631 }
\DoxyCodeLine{08632         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{08633         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : matchedTestCases ) \{}
\DoxyCodeLine{08634             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tagName : testCase.getTestCaseInfo().tags ) \{}
\DoxyCodeLine{08635                 std::string lcaseTagName = toLower( tagName );}
\DoxyCodeLine{08636                 \textcolor{keyword}{auto} countIt = tagCounts.find( lcaseTagName );}
\DoxyCodeLine{08637                 \textcolor{keywordflow}{if}( countIt == tagCounts.end() )}
\DoxyCodeLine{08638                     countIt = tagCounts.insert( std::make\_pair( lcaseTagName, TagInfo() ) ).first;}
\DoxyCodeLine{08639                 countIt->second.add( tagName );}
\DoxyCodeLine{08640             \}}
\DoxyCodeLine{08641         \}}
\DoxyCodeLine{08642 }
\DoxyCodeLine{08643         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tagCount : tagCounts ) \{}
\DoxyCodeLine{08644             ReusableStringStream rss;}
\DoxyCodeLine{08645             rss << \textcolor{stringliteral}{"  "} << std::setw(2) << tagCount.second.count << \textcolor{stringliteral}{"  "};}
\DoxyCodeLine{08646             \textcolor{keyword}{auto} str = rss.str();}
\DoxyCodeLine{08647             \textcolor{keyword}{auto} wrapper = Column( tagCount.second.all() )}
\DoxyCodeLine{08648                                                     .initialIndent( 0 )}
\DoxyCodeLine{08649                                                     .indent( str.size() )}
\DoxyCodeLine{08650                                                     .width( CATCH\_CONFIG\_CONSOLE\_WIDTH-10 );}
\DoxyCodeLine{08651             Catch::cout() << str << wrapper << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{08652         \}}
\DoxyCodeLine{08653         Catch::cout() << pluralise( tagCounts.size(), \textcolor{stringliteral}{"tag"} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{08654         \textcolor{keywordflow}{return} tagCounts.size();}
\DoxyCodeLine{08655     \}}
\DoxyCodeLine{08656 }
\DoxyCodeLine{08657     std::size\_t listReporters() \{}
\DoxyCodeLine{08658         Catch::cout() << \textcolor{stringliteral}{"Available reporters:\(\backslash\)n"};}
\DoxyCodeLine{08659         IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& factories = getRegistryHub().getReporterRegistry().getFactories();}
\DoxyCodeLine{08660         std::size\_t maxNameLen = 0;}
\DoxyCodeLine{08661         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& factoryKvp : factories )}
\DoxyCodeLine{08662             maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );}
\DoxyCodeLine{08663 }
\DoxyCodeLine{08664         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& factoryKvp : factories ) \{}
\DoxyCodeLine{08665             Catch::cout()}
\DoxyCodeLine{08666                     << Column( factoryKvp.first + \textcolor{stringliteral}{":"} )}
\DoxyCodeLine{08667                             .indent(2)}
\DoxyCodeLine{08668                             .width( 5+maxNameLen )}
\DoxyCodeLine{08669                     +  Column( factoryKvp.second->getDescription() )}
\DoxyCodeLine{08670                             .initialIndent(0)}
\DoxyCodeLine{08671                             .indent(2)}
\DoxyCodeLine{08672                             .width( CATCH\_CONFIG\_CONSOLE\_WIDTH - maxNameLen-8 )}
\DoxyCodeLine{08673                     << "\(\backslash\)n";}
\DoxyCodeLine{08674         \}}
\DoxyCodeLine{08675         Catch::cout() << std::endl;}
\DoxyCodeLine{08676         \textcolor{keywordflow}{return} factories.size();}
\DoxyCodeLine{08677     \}}
\DoxyCodeLine{08678 }
\DoxyCodeLine{08679     Option<std::size\_t> list( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{08680         Option<std::size\_t> listedCount;}
\DoxyCodeLine{08681         \textcolor{keywordflow}{if}( config.listTests() )}
\DoxyCodeLine{08682             listedCount = listedCount.valueOr(0) + listTests( config );}
\DoxyCodeLine{08683         \textcolor{keywordflow}{if}( config.listTestNamesOnly() )}
\DoxyCodeLine{08684             listedCount = listedCount.valueOr(0) + listTestsNamesOnly( config );}
\DoxyCodeLine{08685         \textcolor{keywordflow}{if}( config.listTags() )}
\DoxyCodeLine{08686             listedCount = listedCount.valueOr(0) + listTags( config );}
\DoxyCodeLine{08687         \textcolor{keywordflow}{if}( config.listReporters() )}
\DoxyCodeLine{08688             listedCount = listedCount.valueOr(0) + listReporters();}
\DoxyCodeLine{08689         \textcolor{keywordflow}{return} listedCount;}
\DoxyCodeLine{08690     \}}
\DoxyCodeLine{08691 }
\DoxyCodeLine{08692 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{08693 \textcolor{comment}{// end catch\_list.cpp}}
\DoxyCodeLine{08694 \textcolor{comment}{// start catch\_matchers.cpp}}
\DoxyCodeLine{08695 }
\DoxyCodeLine{08696 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08697 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{08698     \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{08699 }
\DoxyCodeLine{08700         std::string MatcherUntypedBase::toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08701             \textcolor{keywordflow}{if}( m\_cachedToString.empty() )}
\DoxyCodeLine{08702                 m\_cachedToString = describe();}
\DoxyCodeLine{08703             \textcolor{keywordflow}{return} m\_cachedToString;}
\DoxyCodeLine{08704         \}}
\DoxyCodeLine{08705 }
\DoxyCodeLine{08706         MatcherUntypedBase::~MatcherUntypedBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{08707 }
\DoxyCodeLine{08708     \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{08709 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{08710 }
\DoxyCodeLine{08711 \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{08712 \textcolor{keyword}{using} Matchers::Impl::MatcherBase;}
\DoxyCodeLine{08713 }
\DoxyCodeLine{08714 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{08715 \textcolor{comment}{// end catch\_matchers.cpp}}
\DoxyCodeLine{08716 \textcolor{comment}{// start catch\_matchers\_floating.cpp}}
\DoxyCodeLine{08717 }
\DoxyCodeLine{08718 \textcolor{comment}{// start catch\_polyfills.hpp}}
\DoxyCodeLine{08719 }
\DoxyCodeLine{08720 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08721     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f);}
\DoxyCodeLine{08722     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d);}
\DoxyCodeLine{08723 \}}
\DoxyCodeLine{08724 }
\DoxyCodeLine{08725 \textcolor{comment}{// end catch\_polyfills.hpp}}
\DoxyCodeLine{08726 \textcolor{comment}{// start catch\_to\_string.hpp}}
\DoxyCodeLine{08727 }
\DoxyCodeLine{08728 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{08729 }
\DoxyCodeLine{08730 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08731     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{08732     std::string to\_string(T \textcolor{keyword}{const}\& t) \{}
\DoxyCodeLine{08733 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP11\_TO\_STRING)}}
\DoxyCodeLine{08734         \textcolor{keywordflow}{return} std::to\_string(t);}
\DoxyCodeLine{08735 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{08736         ReusableStringStream rss;}
\DoxyCodeLine{08737         rss << t;}
\DoxyCodeLine{08738         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{08739 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{08740     \}}
\DoxyCodeLine{08741 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{08742 }
\DoxyCodeLine{08743 \textcolor{comment}{// end catch\_to\_string.hpp}}
\DoxyCodeLine{08744 \textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{08745 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{08746 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{08747 }
\DoxyCodeLine{08748 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08749 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{08750 \textcolor{keyword}{namespace }Floating \{}
\DoxyCodeLine{08751 \textcolor{keyword}{enum class} FloatingPointKind : uint8\_t \{}
\DoxyCodeLine{08752     Float,}
\DoxyCodeLine{08753     Double}
\DoxyCodeLine{08754 \};}
\DoxyCodeLine{08755 \}}
\DoxyCodeLine{08756 \}}
\DoxyCodeLine{08757 \}}
\DoxyCodeLine{08758 }
\DoxyCodeLine{08759 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{08760 }
\DoxyCodeLine{08761 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{08762 \textcolor{keyword}{struct }Converter;}
\DoxyCodeLine{08763 }
\DoxyCodeLine{08764 \textcolor{keyword}{template} <>}
\DoxyCodeLine{08765 \textcolor{keyword}{struct }Converter<float> \{}
\DoxyCodeLine{08766     static\_assert(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}) == \textcolor{keyword}{sizeof}(int32\_t), \textcolor{stringliteral}{"Important ULP matcher assumption violated"});}
\DoxyCodeLine{08767     Converter(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{08768         std::memcpy(\&i, \&f, \textcolor{keyword}{sizeof}(f));}
\DoxyCodeLine{08769     \}}
\DoxyCodeLine{08770     int32\_t i;}
\DoxyCodeLine{08771 \};}
\DoxyCodeLine{08772 }
\DoxyCodeLine{08773 \textcolor{keyword}{template} <>}
\DoxyCodeLine{08774 \textcolor{keyword}{struct }Converter<double> \{}
\DoxyCodeLine{08775     static\_assert(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double}) == \textcolor{keyword}{sizeof}(int64\_t), \textcolor{stringliteral}{"Important ULP matcher assumption violated"});}
\DoxyCodeLine{08776     Converter(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{08777         std::memcpy(\&i, \&d, \textcolor{keyword}{sizeof}(d));}
\DoxyCodeLine{08778     \}}
\DoxyCodeLine{08779     int64\_t i;}
\DoxyCodeLine{08780 \};}
\DoxyCodeLine{08781 }
\DoxyCodeLine{08782 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{08783 \textcolor{keyword}{auto} convert(T t) -> Converter<T> \{}
\DoxyCodeLine{08784     \textcolor{keywordflow}{return} Converter<T>(t);}
\DoxyCodeLine{08785 \}}
\DoxyCodeLine{08786 }
\DoxyCodeLine{08787 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FP>}
\DoxyCodeLine{08788 \textcolor{keywordtype}{bool} almostEqualUlps(FP lhs, FP rhs, \textcolor{keywordtype}{int} maxUlpDiff) \{}
\DoxyCodeLine{08789     \textcolor{comment}{// Comparison with NaN should always be false.}}
\DoxyCodeLine{08790     \textcolor{comment}{// This way we can rule it out before getting into the ugly details}}
\DoxyCodeLine{08791     \textcolor{keywordflow}{if} (Catch::isnan(lhs) || Catch::isnan(rhs)) \{}
\DoxyCodeLine{08792         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{08793     \}}
\DoxyCodeLine{08794 }
\DoxyCodeLine{08795     \textcolor{keyword}{auto} lc = convert(lhs);}
\DoxyCodeLine{08796     \textcolor{keyword}{auto} rc = convert(rhs);}
\DoxyCodeLine{08797 }
\DoxyCodeLine{08798     \textcolor{keywordflow}{if} ((lc.i < 0) != (rc.i < 0)) \{}
\DoxyCodeLine{08799         \textcolor{comment}{// Potentially we can have +0 and -0}}
\DoxyCodeLine{08800         \textcolor{keywordflow}{return} lhs == rhs;}
\DoxyCodeLine{08801     \}}
\DoxyCodeLine{08802 }
\DoxyCodeLine{08803     \textcolor{keyword}{auto} ulpDiff = std::abs(lc.i - rc.i);}
\DoxyCodeLine{08804     \textcolor{keywordflow}{return} ulpDiff <= maxUlpDiff;}
\DoxyCodeLine{08805 \}}
\DoxyCodeLine{08806 }
\DoxyCodeLine{08807 \}}
\DoxyCodeLine{08808 }
\DoxyCodeLine{08809 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08810 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{08811 \textcolor{keyword}{namespace }Floating \{}
\DoxyCodeLine{08812     WithinAbsMatcher::WithinAbsMatcher(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin)}
\DoxyCodeLine{08813         :m\_target\{ target \}, m\_margin\{ margin \} \{}
\DoxyCodeLine{08814         CATCH\_ENFORCE(margin >= 0, \textcolor{stringliteral}{"Invalid margin: "} << margin << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{08815             << \textcolor{stringliteral}{" Margin has to be non-negative."});}
\DoxyCodeLine{08816     \}}
\DoxyCodeLine{08817 }
\DoxyCodeLine{08818     \textcolor{comment}{// Performs equivalent check of std::fabs(lhs - rhs) <= margin}}
\DoxyCodeLine{08819     \textcolor{comment}{// But without the subtraction to allow for INFINITY in comparison}}
\DoxyCodeLine{08820     \textcolor{keywordtype}{bool} WithinAbsMatcher::match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08821         \textcolor{keywordflow}{return} (matchee + m\_margin >= m\_target) \&\& (m\_target + m\_margin >= matchee);}
\DoxyCodeLine{08822     \}}
\DoxyCodeLine{08823 }
\DoxyCodeLine{08824     std::string WithinAbsMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08825         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"is within "} + ::Catch::Detail::stringify(m\_margin) + " of " + ::Catch::Detail::stringify(m\_target);}
\DoxyCodeLine{08826     \}}
\DoxyCodeLine{08827 }
\DoxyCodeLine{08828     WithinUlpsMatcher::WithinUlpsMatcher(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{int} ulps, FloatingPointKind baseType)}
\DoxyCodeLine{08829         :m\_target\{ target \}, m\_ulps\{ ulps \}, m\_type\{ baseType \} \{}
\DoxyCodeLine{08830         CATCH\_ENFORCE(ulps >= 0, \textcolor{stringliteral}{"Invalid ULP setting: "} << ulps << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{08831             << \textcolor{stringliteral}{" ULPs have to be non-negative."});}
\DoxyCodeLine{08832     \}}
\DoxyCodeLine{08833 }
\DoxyCodeLine{08834 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{08835 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{08836 \textcolor{comment}{// Clang <3.5 reports on the default branch in the switch below}}
\DoxyCodeLine{08837 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "-Wunreachable-code"}}
\DoxyCodeLine{08838 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{08839 }
\DoxyCodeLine{08840     \textcolor{keywordtype}{bool} WithinUlpsMatcher::match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08841         \textcolor{keywordflow}{switch} (m\_type) \{}
\DoxyCodeLine{08842         \textcolor{keywordflow}{case} FloatingPointKind::Float:}
\DoxyCodeLine{08843             \textcolor{keywordflow}{return} almostEqualUlps<float>(static\_cast<float>(matchee), static\_cast<float>(m\_target), m\_ulps);}
\DoxyCodeLine{08844         \textcolor{keywordflow}{case} FloatingPointKind::Double:}
\DoxyCodeLine{08845             \textcolor{keywordflow}{return} almostEqualUlps<double>(matchee, m\_target, m\_ulps);}
\DoxyCodeLine{08846         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{08847             CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"Unknown FloatingPointKind value"} );}
\DoxyCodeLine{08848         \}}
\DoxyCodeLine{08849     \}}
\DoxyCodeLine{08850 }
\DoxyCodeLine{08851 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{08852 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{08853 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{08854 }
\DoxyCodeLine{08855     std::string WithinUlpsMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08856         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"is within "} + Catch::to\_string(m\_ulps) + " ULPs of " + ::Catch::Detail::stringify(m\_target) + ((m\_type == FloatingPointKind::Float)? "f" : "");}
\DoxyCodeLine{08857     \}}
\DoxyCodeLine{08858 }
\DoxyCodeLine{08859 \}\textcolor{comment}{// namespace Floating}}
\DoxyCodeLine{08860 }
\DoxyCodeLine{08861 Floating::WithinUlpsMatcher WithinULP(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{int} maxUlpDiff) \{}
\DoxyCodeLine{08862     \textcolor{keywordflow}{return} Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);}
\DoxyCodeLine{08863 \}}
\DoxyCodeLine{08864 }
\DoxyCodeLine{08865 Floating::WithinUlpsMatcher WithinULP(\textcolor{keywordtype}{float} target, \textcolor{keywordtype}{int} maxUlpDiff) \{}
\DoxyCodeLine{08866     \textcolor{keywordflow}{return} Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);}
\DoxyCodeLine{08867 \}}
\DoxyCodeLine{08868 }
\DoxyCodeLine{08869 Floating::WithinAbsMatcher WithinAbs(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin) \{}
\DoxyCodeLine{08870     \textcolor{keywordflow}{return} Floating::WithinAbsMatcher(target, margin);}
\DoxyCodeLine{08871 \}}
\DoxyCodeLine{08872 }
\DoxyCodeLine{08873 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{08874 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{08875 }
\DoxyCodeLine{08876 \textcolor{comment}{// end catch\_matchers\_floating.cpp}}
\DoxyCodeLine{08877 \textcolor{comment}{// start catch\_matchers\_generic.cpp}}
\DoxyCodeLine{08878 }
\DoxyCodeLine{08879 std::string Catch::Matchers::Generic::Detail::finalizeDescription(\textcolor{keyword}{const} std::string\& desc) \{}
\DoxyCodeLine{08880     \textcolor{keywordflow}{if} (desc.empty()) \{}
\DoxyCodeLine{08881         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"matches undescribed predicate"};}
\DoxyCodeLine{08882     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{08883         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"matches predicate: \(\backslash\)""} + desc + '"';}
\DoxyCodeLine{08884     \}}
\DoxyCodeLine{08885 \}}
\DoxyCodeLine{08886 \textcolor{comment}{// end catch\_matchers\_generic.cpp}}
\DoxyCodeLine{08887 \textcolor{comment}{// start catch\_matchers\_string.cpp}}
\DoxyCodeLine{08888 }
\DoxyCodeLine{08889 \textcolor{preprocessor}{\#include <regex>}}
\DoxyCodeLine{08890 }
\DoxyCodeLine{08891 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08892 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{08893 }
\DoxyCodeLine{08894     \textcolor{keyword}{namespace }StdString \{}
\DoxyCodeLine{08895 }
\DoxyCodeLine{08896         CasedString::CasedString( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity )}
\DoxyCodeLine{08897         :   m\_caseSensitivity( caseSensitivity ),}
\DoxyCodeLine{08898             m\_str( adjustString( str ) )}
\DoxyCodeLine{08899         \{\}}
\DoxyCodeLine{08900         std::string CasedString::adjustString( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08901             \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No}
\DoxyCodeLine{08902                    ? toLower( str )}
\DoxyCodeLine{08903                    : str;}
\DoxyCodeLine{08904         \}}
\DoxyCodeLine{08905         std::string CasedString::caseSensitivitySuffix()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08906             \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No}
\DoxyCodeLine{08907                    ? \textcolor{stringliteral}{" (case insensitive)"}}
\DoxyCodeLine{08908                    : std::string();}
\DoxyCodeLine{08909         \}}
\DoxyCodeLine{08910 }
\DoxyCodeLine{08911         StringMatcherBase::StringMatcherBase( std::string \textcolor{keyword}{const}\& operation, CasedString \textcolor{keyword}{const}\& comparator )}
\DoxyCodeLine{08912         : m\_comparator( comparator ),}
\DoxyCodeLine{08913           m\_operation( operation ) \{}
\DoxyCodeLine{08914         \}}
\DoxyCodeLine{08915 }
\DoxyCodeLine{08916         std::string StringMatcherBase::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08917             std::string description;}
\DoxyCodeLine{08918             description.reserve(5 + m\_operation.size() + m\_comparator.m\_str.size() +}
\DoxyCodeLine{08919                                         m\_comparator.caseSensitivitySuffix().size());}
\DoxyCodeLine{08920             description += m\_operation;}
\DoxyCodeLine{08921             description += ": \(\backslash\)"";}
\DoxyCodeLine{08922             description += m\_comparator.m\_str;}
\DoxyCodeLine{08923             description += "\(\backslash\)"";}
\DoxyCodeLine{08924             description += m\_comparator.caseSensitivitySuffix();}
\DoxyCodeLine{08925             \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{08926         \}}
\DoxyCodeLine{08927 }
\DoxyCodeLine{08928         EqualsMatcher::EqualsMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"equals"}, comparator ) \{\}}
\DoxyCodeLine{08929 }
\DoxyCodeLine{08930         \textcolor{keywordtype}{bool} EqualsMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08931             \textcolor{keywordflow}{return} m\_comparator.adjustString( source ) == m\_comparator.m\_str;}
\DoxyCodeLine{08932         \}}
\DoxyCodeLine{08933 }
\DoxyCodeLine{08934         ContainsMatcher::ContainsMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"contains"}, comparator ) \{\}}
\DoxyCodeLine{08935 }
\DoxyCodeLine{08936         \textcolor{keywordtype}{bool} ContainsMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08937             \textcolor{keywordflow}{return} contains( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{08938         \}}
\DoxyCodeLine{08939 }
\DoxyCodeLine{08940         StartsWithMatcher::StartsWithMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"starts with"}, comparator ) \{\}}
\DoxyCodeLine{08941 }
\DoxyCodeLine{08942         \textcolor{keywordtype}{bool} StartsWithMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08943             \textcolor{keywordflow}{return} startsWith( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{08944         \}}
\DoxyCodeLine{08945 }
\DoxyCodeLine{08946         EndsWithMatcher::EndsWithMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"ends with"}, comparator ) \{\}}
\DoxyCodeLine{08947 }
\DoxyCodeLine{08948         \textcolor{keywordtype}{bool} EndsWithMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08949             \textcolor{keywordflow}{return} endsWith( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{08950         \}}
\DoxyCodeLine{08951 }
\DoxyCodeLine{08952         RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m\_regex(std::move(regex)), m\_caseSensitivity(caseSensitivity) \{\}}
\DoxyCodeLine{08953 }
\DoxyCodeLine{08954         \textcolor{keywordtype}{bool} RegexMatcher::match(std::string \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08955             \textcolor{keyword}{auto} flags = std::regex::ECMAScript; \textcolor{comment}{// ECMAScript is the default syntax option anyway}}
\DoxyCodeLine{08956             \textcolor{keywordflow}{if} (m\_caseSensitivity == CaseSensitive::Choice::No) \{}
\DoxyCodeLine{08957                 flags |= std::regex::icase;}
\DoxyCodeLine{08958             \}}
\DoxyCodeLine{08959             \textcolor{keyword}{auto} reg = std::regex(m\_regex, flags);}
\DoxyCodeLine{08960             \textcolor{keywordflow}{return} std::regex\_match(matchee, reg);}
\DoxyCodeLine{08961         \}}
\DoxyCodeLine{08962 }
\DoxyCodeLine{08963         std::string RegexMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{08964             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"matches "} + ::Catch::Detail::stringify(m\_regex) + ((m\_caseSensitivity == CaseSensitive::Choice::Yes)? " case sensitively" : " case insensitively");}
\DoxyCodeLine{08965         \}}
\DoxyCodeLine{08966 }
\DoxyCodeLine{08967     \} \textcolor{comment}{// namespace StdString}}
\DoxyCodeLine{08968 }
\DoxyCodeLine{08969     StdString::EqualsMatcher Equals( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{08970         \textcolor{keywordflow}{return} StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{08971     \}}
\DoxyCodeLine{08972     StdString::ContainsMatcher Contains( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{08973         \textcolor{keywordflow}{return} StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{08974     \}}
\DoxyCodeLine{08975     StdString::EndsWithMatcher EndsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{08976         \textcolor{keywordflow}{return} StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{08977     \}}
\DoxyCodeLine{08978     StdString::StartsWithMatcher StartsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{08979         \textcolor{keywordflow}{return} StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{08980     \}}
\DoxyCodeLine{08981 }
\DoxyCodeLine{08982     StdString::RegexMatcher Matches(std::string \textcolor{keyword}{const}\& regex, CaseSensitive::Choice caseSensitivity) \{}
\DoxyCodeLine{08983         \textcolor{keywordflow}{return} StdString::RegexMatcher(regex, caseSensitivity);}
\DoxyCodeLine{08984     \}}
\DoxyCodeLine{08985 }
\DoxyCodeLine{08986 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{08987 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{08988 \textcolor{comment}{// end catch\_matchers\_string.cpp}}
\DoxyCodeLine{08989 \textcolor{comment}{// start catch\_message.cpp}}
\DoxyCodeLine{08990 }
\DoxyCodeLine{08991 \textcolor{comment}{// start catch\_uncaught\_exceptions.h}}
\DoxyCodeLine{08992 }
\DoxyCodeLine{08993 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{08994     \textcolor{keywordtype}{bool} uncaught\_exceptions();}
\DoxyCodeLine{08995 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{08996 }
\DoxyCodeLine{08997 \textcolor{comment}{// end catch\_uncaught\_exceptions.h}}
\DoxyCodeLine{08998 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{08999 \textcolor{preprocessor}{\#include <stack>}}
\DoxyCodeLine{09000 }
\DoxyCodeLine{09001 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09002 }
\DoxyCodeLine{09003     MessageInfo::MessageInfo(   StringRef \textcolor{keyword}{const}\& \_macroName,}
\DoxyCodeLine{09004                                 SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{09005                                 ResultWas::OfType \_type )}
\DoxyCodeLine{09006     :   macroName( \_macroName ),}
\DoxyCodeLine{09007         lineInfo( \_lineInfo ),}
\DoxyCodeLine{09008         type( \_type ),}
\DoxyCodeLine{09009         sequence( ++globalCount )}
\DoxyCodeLine{09010     \{\}}
\DoxyCodeLine{09011 }
\DoxyCodeLine{09012     \textcolor{keywordtype}{bool} MessageInfo::operator==( MessageInfo \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{09013         \textcolor{keywordflow}{return} sequence == other.sequence;}
\DoxyCodeLine{09014     \}}
\DoxyCodeLine{09015 }
\DoxyCodeLine{09016     \textcolor{keywordtype}{bool} MessageInfo::operator<( MessageInfo \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{09017         \textcolor{keywordflow}{return} sequence < other.sequence;}
\DoxyCodeLine{09018     \}}
\DoxyCodeLine{09019 }
\DoxyCodeLine{09020     \textcolor{comment}{// This may need protecting if threading support is added}}
\DoxyCodeLine{09021     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} MessageInfo::globalCount = 0;}
\DoxyCodeLine{09022 }
\DoxyCodeLine{09024 }
\DoxyCodeLine{09025     Catch::MessageBuilder::MessageBuilder( StringRef \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{09026                                            SourceLineInfo \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{09027                                            ResultWas::OfType type )}
\DoxyCodeLine{09028         :m\_info(macroName, lineInfo, type) \{\}}
\DoxyCodeLine{09029 }
\DoxyCodeLine{09031 }
\DoxyCodeLine{09032     ScopedMessage::ScopedMessage( MessageBuilder \textcolor{keyword}{const}\& builder )}
\DoxyCodeLine{09033     : m\_info( builder.m\_info )}
\DoxyCodeLine{09034     \{}
\DoxyCodeLine{09035         m\_info.message = builder.m\_stream.str();}
\DoxyCodeLine{09036         getResultCapture().pushScopedMessage( m\_info );}
\DoxyCodeLine{09037     \}}
\DoxyCodeLine{09038 }
\DoxyCodeLine{09039     ScopedMessage::~ScopedMessage() \{}
\DoxyCodeLine{09040         \textcolor{keywordflow}{if} ( !uncaught\_exceptions() )\{}
\DoxyCodeLine{09041             getResultCapture().popScopedMessage(m\_info);}
\DoxyCodeLine{09042         \}}
\DoxyCodeLine{09043     \}}
\DoxyCodeLine{09044 }
\DoxyCodeLine{09045     Capturer::Capturer( StringRef macroName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo, ResultWas::OfType resultType, StringRef names ) \{}
\DoxyCodeLine{09046         \textcolor{keyword}{auto} trimmed = [\&] (\textcolor{keywordtype}{size\_t} start, \textcolor{keywordtype}{size\_t} end) \{}
\DoxyCodeLine{09047             \textcolor{keywordflow}{while} (names[start] == \textcolor{charliteral}{','} || isspace(names[start])) \{}
\DoxyCodeLine{09048                 ++start;}
\DoxyCodeLine{09049             \}}
\DoxyCodeLine{09050             \textcolor{keywordflow}{while} (names[end] == \textcolor{charliteral}{','} || isspace(names[end])) \{}
\DoxyCodeLine{09051                 --end;}
\DoxyCodeLine{09052             \}}
\DoxyCodeLine{09053             \textcolor{keywordflow}{return} names.substr(start, end - start + 1);}
\DoxyCodeLine{09054         \};}
\DoxyCodeLine{09055 }
\DoxyCodeLine{09056         \textcolor{keywordtype}{size\_t} start = 0;}
\DoxyCodeLine{09057         std::stack<char> openings;}
\DoxyCodeLine{09058         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} pos = 0; pos < names.size(); ++pos) \{}
\DoxyCodeLine{09059             \textcolor{keywordtype}{char} c = names[pos];}
\DoxyCodeLine{09060             \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{09061             \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:}
\DoxyCodeLine{09062             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\{'}:}
\DoxyCodeLine{09063             \textcolor{keywordflow}{case} \textcolor{charliteral}{'('}:}
\DoxyCodeLine{09064             \textcolor{comment}{// It is basically impossible to disambiguate between}}
\DoxyCodeLine{09065             \textcolor{comment}{// comparison and start of template args in this context}}
\DoxyCodeLine{09066 \textcolor{comment}{//            case '<':}}
\DoxyCodeLine{09067                 openings.push(c);}
\DoxyCodeLine{09068                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{09069             \textcolor{keywordflow}{case} \textcolor{charliteral}{']'}:}
\DoxyCodeLine{09070             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\}'}:}
\DoxyCodeLine{09071             \textcolor{keywordflow}{case} \textcolor{charliteral}{')'}:}
\DoxyCodeLine{09072 \textcolor{comment}{//           case '>':}}
\DoxyCodeLine{09073                 openings.pop();}
\DoxyCodeLine{09074                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{09075             \textcolor{keywordflow}{case} \textcolor{charliteral}{','}:}
\DoxyCodeLine{09076                 \textcolor{keywordflow}{if} (start != pos \&\& openings.size() == 0) \{}
\DoxyCodeLine{09077                     m\_messages.emplace\_back(macroName, lineInfo, resultType);}
\DoxyCodeLine{09078                     m\_messages.back().message = trimmed(start, pos);}
\DoxyCodeLine{09079                     m\_messages.back().message += " := ";}
\DoxyCodeLine{09080                     start = pos;}
\DoxyCodeLine{09081                 \}}
\DoxyCodeLine{09082             \}}
\DoxyCodeLine{09083         \}}
\DoxyCodeLine{09084         assert(openings.size() == 0 \&\& \textcolor{stringliteral}{"Mismatched openings"});}
\DoxyCodeLine{09085         m\_messages.emplace\_back(macroName, lineInfo, resultType);}
\DoxyCodeLine{09086         m\_messages.back().message = trimmed(start, names.size() - 1);}
\DoxyCodeLine{09087         m\_messages.back().message += " := ";}
\DoxyCodeLine{09088     \}}
\DoxyCodeLine{09089     Capturer::~Capturer() \{}
\DoxyCodeLine{09090         \textcolor{keywordflow}{if} ( !uncaught\_exceptions() )\{}
\DoxyCodeLine{09091             assert( m\_captured == m\_messages.size() );}
\DoxyCodeLine{09092             \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 0; i < m\_captured; ++i  )}
\DoxyCodeLine{09093                 m\_resultCapture.popScopedMessage( m\_messages[i] );}
\DoxyCodeLine{09094         \}}
\DoxyCodeLine{09095     \}}
\DoxyCodeLine{09096 }
\DoxyCodeLine{09097     \textcolor{keywordtype}{void} Capturer::captureValue( \textcolor{keywordtype}{size\_t} index, std::string \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{09098         assert( index < m\_messages.size() );}
\DoxyCodeLine{09099         m\_messages[index].message += value;}
\DoxyCodeLine{09100         m\_resultCapture.pushScopedMessage( m\_messages[index] );}
\DoxyCodeLine{09101         m\_captured++;}
\DoxyCodeLine{09102     \}}
\DoxyCodeLine{09103 }
\DoxyCodeLine{09104 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{09105 \textcolor{comment}{// end catch\_message.cpp}}
\DoxyCodeLine{09106 \textcolor{comment}{// start catch\_output\_redirect.cpp}}
\DoxyCodeLine{09107 }
\DoxyCodeLine{09108 \textcolor{comment}{// start catch\_output\_redirect.h}}
\DoxyCodeLine{09109 \textcolor{preprocessor}{\#ifndef TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{09110 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{09111 }
\DoxyCodeLine{09112 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{09113 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{09114 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{09115 }
\DoxyCodeLine{09116 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09117 }
\DoxyCodeLine{09118     \textcolor{keyword}{class }RedirectedStream \{}
\DoxyCodeLine{09119         std::ostream\& m\_originalStream;}
\DoxyCodeLine{09120         std::ostream\& m\_redirectionStream;}
\DoxyCodeLine{09121         std::streambuf* m\_prevBuf;}
\DoxyCodeLine{09122 }
\DoxyCodeLine{09123     \textcolor{keyword}{public}:}
\DoxyCodeLine{09124         RedirectedStream( std::ostream\& originalStream, std::ostream\& redirectionStream );}
\DoxyCodeLine{09125         ~RedirectedStream();}
\DoxyCodeLine{09126     \};}
\DoxyCodeLine{09127 }
\DoxyCodeLine{09128     \textcolor{keyword}{class }RedirectedStdOut \{}
\DoxyCodeLine{09129         ReusableStringStream m\_rss;}
\DoxyCodeLine{09130         RedirectedStream m\_cout;}
\DoxyCodeLine{09131     \textcolor{keyword}{public}:}
\DoxyCodeLine{09132         RedirectedStdOut();}
\DoxyCodeLine{09133         \textcolor{keyword}{auto} str() const -> std::\textcolor{keywordtype}{string};}
\DoxyCodeLine{09134     \};}
\DoxyCodeLine{09135 }
\DoxyCodeLine{09136     \textcolor{comment}{// StdErr has two constituent streams in C++, std::cerr and std::clog}}
\DoxyCodeLine{09137     \textcolor{comment}{// This means that we need to redirect 2 streams into 1 to keep proper}}
\DoxyCodeLine{09138     \textcolor{comment}{// order of writes}}
\DoxyCodeLine{09139     class RedirectedStdErr \{}
\DoxyCodeLine{09140         ReusableStringStream m\_rss;}
\DoxyCodeLine{09141         RedirectedStream m\_cerr;}
\DoxyCodeLine{09142         RedirectedStream m\_clog;}
\DoxyCodeLine{09143     \textcolor{keyword}{public}:}
\DoxyCodeLine{09144         RedirectedStdErr();}
\DoxyCodeLine{09145         \textcolor{keyword}{auto} str() const -> std::\textcolor{keywordtype}{string};}
\DoxyCodeLine{09146     \};}
\DoxyCodeLine{09147 }
\DoxyCodeLine{09148 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{09149 }
\DoxyCodeLine{09150     \textcolor{comment}{// Windows's implementation of std::tmpfile is terrible (it tries}}
\DoxyCodeLine{09151     \textcolor{comment}{// to create a file inside system folder, thus requiring elevated}}
\DoxyCodeLine{09152     \textcolor{comment}{// privileges for the binary), so we have to use tmpnam(\_s) and}}
\DoxyCodeLine{09153     \textcolor{comment}{// create the file ourselves there.}}
\DoxyCodeLine{09154     \textcolor{keyword}{class }TempFile \{}
\DoxyCodeLine{09155     \textcolor{keyword}{public}:}
\DoxyCodeLine{09156         TempFile(TempFile \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{09157         TempFile\& operator=(TempFile \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{09158         TempFile(TempFile\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{09159         TempFile\& operator=(TempFile\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{09160 }
\DoxyCodeLine{09161         TempFile();}
\DoxyCodeLine{09162         ~TempFile();}
\DoxyCodeLine{09163 }
\DoxyCodeLine{09164         std::FILE* getFile();}
\DoxyCodeLine{09165         std::string getContents();}
\DoxyCodeLine{09166 }
\DoxyCodeLine{09167     \textcolor{keyword}{private}:}
\DoxyCodeLine{09168         std::FILE* m\_file = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{09169 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{09170         \textcolor{keywordtype}{char} m\_buffer[L\_tmpnam] = \{ 0 \};}
\DoxyCodeLine{09171 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{09172     \};}
\DoxyCodeLine{09173 }
\DoxyCodeLine{09174     \textcolor{keyword}{class }OutputRedirect \{}
\DoxyCodeLine{09175     \textcolor{keyword}{public}:}
\DoxyCodeLine{09176         OutputRedirect(OutputRedirect \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{09177         OutputRedirect\& operator=(OutputRedirect \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{09178         OutputRedirect(OutputRedirect\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{09179         OutputRedirect\& operator=(OutputRedirect\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{09180 }
\DoxyCodeLine{09181         OutputRedirect(std::string\& stdout\_dest, std::string\& stderr\_dest);}
\DoxyCodeLine{09182         ~OutputRedirect();}
\DoxyCodeLine{09183 }
\DoxyCodeLine{09184     \textcolor{keyword}{private}:}
\DoxyCodeLine{09185         \textcolor{keywordtype}{int} m\_originalStdout = -1;}
\DoxyCodeLine{09186         \textcolor{keywordtype}{int} m\_originalStderr = -1;}
\DoxyCodeLine{09187         TempFile m\_stdoutFile;}
\DoxyCodeLine{09188         TempFile m\_stderrFile;}
\DoxyCodeLine{09189         std::string\& m\_stdoutDest;}
\DoxyCodeLine{09190         std::string\& m\_stderrDest;}
\DoxyCodeLine{09191     \};}
\DoxyCodeLine{09192 }
\DoxyCodeLine{09193 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{09194 }
\DoxyCodeLine{09195 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{09196 }
\DoxyCodeLine{09197 \textcolor{preprocessor}{\#endif // TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{09198 \textcolor{comment}{// end catch\_output\_redirect.h}}
\DoxyCodeLine{09199 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{09200 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{09201 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{09202 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{09203 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{09204 }
\DoxyCodeLine{09205 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{09206 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{09207 \textcolor{preprocessor}{    \#include <io.h>}      \textcolor{comment}{//\_dup and \_dup2}}
\DoxyCodeLine{09208 \textcolor{preprocessor}{    \#define dup \_dup}}
\DoxyCodeLine{09209 \textcolor{preprocessor}{    \#define dup2 \_dup2}}
\DoxyCodeLine{09210 \textcolor{preprocessor}{    \#define fileno \_fileno}}
\DoxyCodeLine{09211 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{09212 \textcolor{preprocessor}{    \#include <unistd.h>}  \textcolor{comment}{// dup and dup2}}
\DoxyCodeLine{09213 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{09214 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{09215 }
\DoxyCodeLine{09216 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09217 }
\DoxyCodeLine{09218     RedirectedStream::RedirectedStream( std::ostream\& originalStream, std::ostream\& redirectionStream )}
\DoxyCodeLine{09219     :   m\_originalStream( originalStream ),}
\DoxyCodeLine{09220         m\_redirectionStream( redirectionStream ),}
\DoxyCodeLine{09221         m\_prevBuf( m\_originalStream.rdbuf() )}
\DoxyCodeLine{09222     \{}
\DoxyCodeLine{09223         m\_originalStream.rdbuf( m\_redirectionStream.rdbuf() );}
\DoxyCodeLine{09224     \}}
\DoxyCodeLine{09225 }
\DoxyCodeLine{09226     RedirectedStream::~RedirectedStream() \{}
\DoxyCodeLine{09227         m\_originalStream.rdbuf( m\_prevBuf );}
\DoxyCodeLine{09228     \}}
\DoxyCodeLine{09229 }
\DoxyCodeLine{09230     RedirectedStdOut::RedirectedStdOut() : m\_cout( Catch::cout(), m\_rss.get() ) \{\}}
\DoxyCodeLine{09231     \textcolor{keyword}{auto} RedirectedStdOut::str() const -> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_rss.str(); \}}
\DoxyCodeLine{09232 }
\DoxyCodeLine{09233     RedirectedStdErr::RedirectedStdErr()}
\DoxyCodeLine{09234     :   m\_cerr( Catch::cerr(), m\_rss.get() ),}
\DoxyCodeLine{09235         m\_clog( Catch::clog(), m\_rss.get() )}
\DoxyCodeLine{09236     \{\}}
\DoxyCodeLine{09237     \textcolor{keyword}{auto} RedirectedStdErr::str() const -> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_rss.str(); \}}
\DoxyCodeLine{09238 }
\DoxyCodeLine{09239 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{09240 }
\DoxyCodeLine{09241 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{09242     TempFile::TempFile() \{}
\DoxyCodeLine{09243         \textcolor{keywordflow}{if} (tmpnam\_s(m\_buffer)) \{}
\DoxyCodeLine{09244             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"Could not get a temp filename"});}
\DoxyCodeLine{09245         \}}
\DoxyCodeLine{09246         \textcolor{keywordflow}{if} (fopen\_s(\&m\_file, m\_buffer, \textcolor{stringliteral}{"w"})) \{}
\DoxyCodeLine{09247             \textcolor{keywordtype}{char} buffer[100];}
\DoxyCodeLine{09248             \textcolor{keywordflow}{if} (strerror\_s(buffer, errno)) \{}
\DoxyCodeLine{09249                 CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"Could not translate errno to a string"});}
\DoxyCodeLine{09250             \}}
\DoxyCodeLine{09251             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"Coul dnot open the temp file: '"} << m\_buffer << \textcolor{stringliteral}{"' because: "} << buffer);}
\DoxyCodeLine{09252         \}}
\DoxyCodeLine{09253     \}}
\DoxyCodeLine{09254 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{09255     TempFile::TempFile() \{}
\DoxyCodeLine{09256         m\_file = std::tmpfile();}
\DoxyCodeLine{09257         \textcolor{keywordflow}{if} (!m\_file) \{}
\DoxyCodeLine{09258             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"Could not create a temp file."});}
\DoxyCodeLine{09259         \}}
\DoxyCodeLine{09260     \}}
\DoxyCodeLine{09261 }
\DoxyCodeLine{09262 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{09263 }
\DoxyCodeLine{09264     TempFile::~TempFile() \{}
\DoxyCodeLine{09265          \textcolor{comment}{// TBD: What to do about errors here?}}
\DoxyCodeLine{09266          std::fclose(m\_file);}
\DoxyCodeLine{09267          \textcolor{comment}{// We manually create the file on Windows only, on Linux}}
\DoxyCodeLine{09268          \textcolor{comment}{// it will be autodeleted}}
\DoxyCodeLine{09269 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{09270          std::remove(m\_buffer);}
\DoxyCodeLine{09271 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{09272     \}}
\DoxyCodeLine{09273 }
\DoxyCodeLine{09274     FILE* TempFile::getFile() \{}
\DoxyCodeLine{09275         \textcolor{keywordflow}{return} m\_file;}
\DoxyCodeLine{09276     \}}
\DoxyCodeLine{09277 }
\DoxyCodeLine{09278     std::string TempFile::getContents() \{}
\DoxyCodeLine{09279         std::stringstream sstr;}
\DoxyCodeLine{09280         \textcolor{keywordtype}{char} buffer[100] = \{\};}
\DoxyCodeLine{09281         std::rewind(m\_file);}
\DoxyCodeLine{09282         \textcolor{keywordflow}{while} (std::fgets(buffer, \textcolor{keyword}{sizeof}(buffer), m\_file)) \{}
\DoxyCodeLine{09283             sstr << buffer;}
\DoxyCodeLine{09284         \}}
\DoxyCodeLine{09285         \textcolor{keywordflow}{return} sstr.str();}
\DoxyCodeLine{09286     \}}
\DoxyCodeLine{09287 }
\DoxyCodeLine{09288     OutputRedirect::OutputRedirect(std::string\& stdout\_dest, std::string\& stderr\_dest) :}
\DoxyCodeLine{09289         m\_originalStdout(dup(1)),}
\DoxyCodeLine{09290         m\_originalStderr(dup(2)),}
\DoxyCodeLine{09291         m\_stdoutDest(stdout\_dest),}
\DoxyCodeLine{09292         m\_stderrDest(stderr\_dest) \{}
\DoxyCodeLine{09293         dup2(fileno(m\_stdoutFile.getFile()), 1);}
\DoxyCodeLine{09294         dup2(fileno(m\_stderrFile.getFile()), 2);}
\DoxyCodeLine{09295     \}}
\DoxyCodeLine{09296 }
\DoxyCodeLine{09297     OutputRedirect::~OutputRedirect() \{}
\DoxyCodeLine{09298         Catch::cout() << std::flush;}
\DoxyCodeLine{09299         fflush(stdout);}
\DoxyCodeLine{09300         \textcolor{comment}{// Since we support overriding these streams, we flush cerr}}
\DoxyCodeLine{09301         \textcolor{comment}{// even though std::cerr is unbuffered}}
\DoxyCodeLine{09302         Catch::cerr() << std::flush;}
\DoxyCodeLine{09303         Catch::clog() << std::flush;}
\DoxyCodeLine{09304         fflush(stderr);}
\DoxyCodeLine{09305 }
\DoxyCodeLine{09306         dup2(m\_originalStdout, 1);}
\DoxyCodeLine{09307         dup2(m\_originalStderr, 2);}
\DoxyCodeLine{09308 }
\DoxyCodeLine{09309         m\_stdoutDest += m\_stdoutFile.getContents();}
\DoxyCodeLine{09310         m\_stderrDest += m\_stderrFile.getContents();}
\DoxyCodeLine{09311     \}}
\DoxyCodeLine{09312 }
\DoxyCodeLine{09313 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{09314 }
\DoxyCodeLine{09315 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{09316 }
\DoxyCodeLine{09317 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{09318 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{09319 \textcolor{preprocessor}{    \#undef dup}}
\DoxyCodeLine{09320 \textcolor{preprocessor}{    \#undef dup2}}
\DoxyCodeLine{09321 \textcolor{preprocessor}{    \#undef fileno}}
\DoxyCodeLine{09322 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{09323 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{09324 \textcolor{comment}{// end catch\_output\_redirect.cpp}}
\DoxyCodeLine{09325 \textcolor{comment}{// start catch\_polyfills.cpp}}
\DoxyCodeLine{09326 }
\DoxyCodeLine{09327 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{09328 }
\DoxyCodeLine{09329 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09330 }
\DoxyCodeLine{09331 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_POLYFILL\_ISNAN)}}
\DoxyCodeLine{09332     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{09333         \textcolor{keywordflow}{return} std::isnan(f);}
\DoxyCodeLine{09334     \}}
\DoxyCodeLine{09335     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{09336         \textcolor{keywordflow}{return} std::isnan(d);}
\DoxyCodeLine{09337     \}}
\DoxyCodeLine{09338 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{09339     \textcolor{comment}{// For now we only use this for embarcadero}}
\DoxyCodeLine{09340     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{09341         \textcolor{keywordflow}{return} std::\_isnan(f);}
\DoxyCodeLine{09342     \}}
\DoxyCodeLine{09343     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{09344         \textcolor{keywordflow}{return} std::\_isnan(d);}
\DoxyCodeLine{09345     \}}
\DoxyCodeLine{09346 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{09347 }
\DoxyCodeLine{09348 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{09349 \textcolor{comment}{// end catch\_polyfills.cpp}}
\DoxyCodeLine{09350 \textcolor{comment}{// start catch\_random\_number\_generator.cpp}}
\DoxyCodeLine{09351 }
\DoxyCodeLine{09352 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09353 }
\DoxyCodeLine{09354     std::mt19937\& rng() \{}
\DoxyCodeLine{09355         \textcolor{keyword}{static} std::mt19937 s\_rng;}
\DoxyCodeLine{09356         \textcolor{keywordflow}{return} s\_rng;}
\DoxyCodeLine{09357     \}}
\DoxyCodeLine{09358 }
\DoxyCodeLine{09359     \textcolor{keywordtype}{void} seedRng( IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{09360         \textcolor{keywordflow}{if}( config.rngSeed() != 0 ) \{}
\DoxyCodeLine{09361             std::srand( config.rngSeed() );}
\DoxyCodeLine{09362             rng().seed( config.rngSeed() );}
\DoxyCodeLine{09363         \}}
\DoxyCodeLine{09364     \}}
\DoxyCodeLine{09365 }
\DoxyCodeLine{09366     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \{}
\DoxyCodeLine{09367         \textcolor{keywordflow}{return} getCurrentContext().getConfig()->rngSeed();}
\DoxyCodeLine{09368     \}}
\DoxyCodeLine{09369 \}}
\DoxyCodeLine{09370 \textcolor{comment}{// end catch\_random\_number\_generator.cpp}}
\DoxyCodeLine{09371 \textcolor{comment}{// start catch\_registry\_hub.cpp}}
\DoxyCodeLine{09372 }
\DoxyCodeLine{09373 \textcolor{comment}{// start catch\_test\_case\_registry\_impl.h}}
\DoxyCodeLine{09374 }
\DoxyCodeLine{09375 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{09376 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{09377 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{09378 \textcolor{preprocessor}{\#include <ios>}}
\DoxyCodeLine{09379 }
\DoxyCodeLine{09380 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09381 }
\DoxyCodeLine{09382     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{09383     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{09384 }
\DoxyCodeLine{09385     std::vector<TestCase> sortTests( IConfig \textcolor{keyword}{const}\& config, std::vector<TestCase> \textcolor{keyword}{const}\& unsortedTestCases );}
\DoxyCodeLine{09386     \textcolor{keywordtype}{bool} matchTest( TestCase \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{09387 }
\DoxyCodeLine{09388     \textcolor{keywordtype}{void} enforceNoDuplicateTestCases( std::vector<TestCase> \textcolor{keyword}{const}\& functions );}
\DoxyCodeLine{09389 }
\DoxyCodeLine{09390     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{09391     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{09392 }
\DoxyCodeLine{09393     \textcolor{keyword}{class }TestRegistry : \textcolor{keyword}{public} ITestCaseRegistry \{}
\DoxyCodeLine{09394     \textcolor{keyword}{public}:}
\DoxyCodeLine{09395         \textcolor{keyword}{virtual} ~TestRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{09396 }
\DoxyCodeLine{09397         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTest( TestCase \textcolor{keyword}{const}\& testCase );}
\DoxyCodeLine{09398 }
\DoxyCodeLine{09399         std::vector<TestCase> \textcolor{keyword}{const}\& getAllTests() \textcolor{keyword}{const override};}
\DoxyCodeLine{09400         std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestsSorted( IConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const override};}
\DoxyCodeLine{09401 }
\DoxyCodeLine{09402     \textcolor{keyword}{private}:}
\DoxyCodeLine{09403         std::vector<TestCase> m\_functions;}
\DoxyCodeLine{09404         \textcolor{keyword}{mutable} RunTests::InWhatOrder m\_currentSortOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{09405         \textcolor{keyword}{mutable} std::vector<TestCase> m\_sortedFunctions;}
\DoxyCodeLine{09406         std::size\_t m\_unnamedCount = 0;}
\DoxyCodeLine{09407         std::ios\_base::Init m\_ostreamInit; \textcolor{comment}{// Forces cout/ cerr to be initialised}}
\DoxyCodeLine{09408     \};}
\DoxyCodeLine{09409 }
\DoxyCodeLine{09411 }
\DoxyCodeLine{09412     \textcolor{keyword}{class }TestInvokerAsFunction : \textcolor{keyword}{public} ITestInvoker \{}
\DoxyCodeLine{09413         void(*m\_testAsFunction)();}
\DoxyCodeLine{09414     \textcolor{keyword}{public}:}
\DoxyCodeLine{09415         TestInvokerAsFunction( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept;}
\DoxyCodeLine{09416 }
\DoxyCodeLine{09417         \textcolor{keywordtype}{void} invoke() const override;}
\DoxyCodeLine{09418     \};}
\DoxyCodeLine{09419 }
\DoxyCodeLine{09420     std::\textcolor{keywordtype}{string} extractClassName( StringRef const\& classOrQualifiedMethodName );}
\DoxyCodeLine{09421 }
\DoxyCodeLine{09423 }
\DoxyCodeLine{09424 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{09425 }
\DoxyCodeLine{09426 \textcolor{comment}{// end catch\_test\_case\_registry\_impl.h}}
\DoxyCodeLine{09427 \textcolor{comment}{// start catch\_reporter\_registry.h}}
\DoxyCodeLine{09428 }
\DoxyCodeLine{09429 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{09430 }
\DoxyCodeLine{09431 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09432 }
\DoxyCodeLine{09433     \textcolor{keyword}{class }ReporterRegistry : \textcolor{keyword}{public} IReporterRegistry \{}
\DoxyCodeLine{09434 }
\DoxyCodeLine{09435     \textcolor{keyword}{public}:}
\DoxyCodeLine{09436 }
\DoxyCodeLine{09437         ~ReporterRegistry() \textcolor{keyword}{override};}
\DoxyCodeLine{09438 }
\DoxyCodeLine{09439         IStreamingReporterPtr create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const override};}
\DoxyCodeLine{09440 }
\DoxyCodeLine{09441         \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory );}
\DoxyCodeLine{09442         \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory );}
\DoxyCodeLine{09443 }
\DoxyCodeLine{09444         FactoryMap \textcolor{keyword}{const}\& getFactories() \textcolor{keyword}{const override};}
\DoxyCodeLine{09445         Listeners \textcolor{keyword}{const}\& getListeners() \textcolor{keyword}{const override};}
\DoxyCodeLine{09446 }
\DoxyCodeLine{09447     \textcolor{keyword}{private}:}
\DoxyCodeLine{09448         FactoryMap m\_factories;}
\DoxyCodeLine{09449         Listeners m\_listeners;}
\DoxyCodeLine{09450     \};}
\DoxyCodeLine{09451 \}}
\DoxyCodeLine{09452 }
\DoxyCodeLine{09453 \textcolor{comment}{// end catch\_reporter\_registry.h}}
\DoxyCodeLine{09454 \textcolor{comment}{// start catch\_tag\_alias\_registry.h}}
\DoxyCodeLine{09455 }
\DoxyCodeLine{09456 \textcolor{comment}{// start catch\_tag\_alias.h}}
\DoxyCodeLine{09457 }
\DoxyCodeLine{09458 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{09459 }
\DoxyCodeLine{09460 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09461 }
\DoxyCodeLine{09462     \textcolor{keyword}{struct }TagAlias \{}
\DoxyCodeLine{09463         TagAlias(std::string \textcolor{keyword}{const}\& \_tag, SourceLineInfo \_lineInfo);}
\DoxyCodeLine{09464 }
\DoxyCodeLine{09465         std::string tag;}
\DoxyCodeLine{09466         SourceLineInfo lineInfo;}
\DoxyCodeLine{09467     \};}
\DoxyCodeLine{09468 }
\DoxyCodeLine{09469 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{09470 }
\DoxyCodeLine{09471 \textcolor{comment}{// end catch\_tag\_alias.h}}
\DoxyCodeLine{09472 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{09473 }
\DoxyCodeLine{09474 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09475 }
\DoxyCodeLine{09476     \textcolor{keyword}{class }TagAliasRegistry : \textcolor{keyword}{public} ITagAliasRegistry \{}
\DoxyCodeLine{09477     \textcolor{keyword}{public}:}
\DoxyCodeLine{09478         ~TagAliasRegistry() \textcolor{keyword}{override};}
\DoxyCodeLine{09479         TagAlias \textcolor{keyword}{const}* find( std::string \textcolor{keyword}{const}\& alias ) \textcolor{keyword}{const override};}
\DoxyCodeLine{09480         std::string expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec ) \textcolor{keyword}{const override};}
\DoxyCodeLine{09481         \textcolor{keywordtype}{void} add( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{09482 }
\DoxyCodeLine{09483     \textcolor{keyword}{private}:}
\DoxyCodeLine{09484         std::map<std::string, TagAlias> m\_registry;}
\DoxyCodeLine{09485     \};}
\DoxyCodeLine{09486 }
\DoxyCodeLine{09487 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{09488 }
\DoxyCodeLine{09489 \textcolor{comment}{// end catch\_tag\_alias\_registry.h}}
\DoxyCodeLine{09490 \textcolor{comment}{// start catch\_startup\_exception\_registry.h}}
\DoxyCodeLine{09491 }
\DoxyCodeLine{09492 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{09493 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{09494 }
\DoxyCodeLine{09495 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09496 }
\DoxyCodeLine{09497     \textcolor{keyword}{class }StartupExceptionRegistry \{}
\DoxyCodeLine{09498     \textcolor{keyword}{public}:}
\DoxyCodeLine{09499         \textcolor{keywordtype}{void} add(std::exception\_ptr \textcolor{keyword}{const}\& exception) noexcept;}
\DoxyCodeLine{09500         std::vector<std::exception\_ptr> \textcolor{keyword}{const}\& getExceptions() const noexcept;}
\DoxyCodeLine{09501     private:}
\DoxyCodeLine{09502         std::vector<std::exception\_ptr> m\_exceptions;}
\DoxyCodeLine{09503     \};}
\DoxyCodeLine{09504 }
\DoxyCodeLine{09505 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{09506 }
\DoxyCodeLine{09507 \textcolor{comment}{// end catch\_startup\_exception\_registry.h}}
\DoxyCodeLine{09508 \textcolor{comment}{// start catch\_singletons.hpp}}
\DoxyCodeLine{09509 }
\DoxyCodeLine{09510 namespace Catch \{}
\DoxyCodeLine{09511 }
\DoxyCodeLine{09512     \textcolor{keyword}{struct }ISingleton \{}
\DoxyCodeLine{09513         \textcolor{keyword}{virtual} ~ISingleton();}
\DoxyCodeLine{09514     \};}
\DoxyCodeLine{09515 }
\DoxyCodeLine{09516     \textcolor{keywordtype}{void} addSingleton( ISingleton* singleton );}
\DoxyCodeLine{09517     \textcolor{keywordtype}{void} cleanupSingletons();}
\DoxyCodeLine{09518 }
\DoxyCodeLine{09519     \textcolor{keyword}{template}<\textcolor{keyword}{typename} SingletonImplT, \textcolor{keyword}{typename} InterfaceT = SingletonImplT, \textcolor{keyword}{typename} MutableInterfaceT = InterfaceT>}
\DoxyCodeLine{09520     \textcolor{keyword}{class }Singleton : SingletonImplT, \textcolor{keyword}{public} ISingleton \{}
\DoxyCodeLine{09521 }
\DoxyCodeLine{09522         \textcolor{keyword}{static} \textcolor{keyword}{auto} getInternal() -> Singleton* \{}
\DoxyCodeLine{09523             \textcolor{keyword}{static} Singleton* s\_instance = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{09524             \textcolor{keywordflow}{if}( !s\_instance ) \{}
\DoxyCodeLine{09525                 s\_instance = \textcolor{keyword}{new} Singleton;}
\DoxyCodeLine{09526                 addSingleton( s\_instance );}
\DoxyCodeLine{09527             \}}
\DoxyCodeLine{09528             \textcolor{keywordflow}{return} s\_instance;}
\DoxyCodeLine{09529         \}}
\DoxyCodeLine{09530 }
\DoxyCodeLine{09531     \textcolor{keyword}{public}:}
\DoxyCodeLine{09532         \textcolor{keyword}{static} \textcolor{keyword}{auto} get() -> InterfaceT \textcolor{keyword}{const}\& \{}
\DoxyCodeLine{09533             \textcolor{keywordflow}{return} *getInternal();}
\DoxyCodeLine{09534         \}}
\DoxyCodeLine{09535         \textcolor{keyword}{static} \textcolor{keyword}{auto} getMutable() -> MutableInterfaceT\& \{}
\DoxyCodeLine{09536             \textcolor{keywordflow}{return} *getInternal();}
\DoxyCodeLine{09537         \}}
\DoxyCodeLine{09538     \};}
\DoxyCodeLine{09539 }
\DoxyCodeLine{09540 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{09541 }
\DoxyCodeLine{09542 \textcolor{comment}{// end catch\_singletons.hpp}}
\DoxyCodeLine{09543 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09544 }
\DoxyCodeLine{09545     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{09546 }
\DoxyCodeLine{09547         \textcolor{keyword}{class }RegistryHub : \textcolor{keyword}{public} IRegistryHub, \textcolor{keyword}{public} IMutableRegistryHub,}
\DoxyCodeLine{09548                             \textcolor{keyword}{private} NonCopyable \{}
\DoxyCodeLine{09549 }
\DoxyCodeLine{09550         \textcolor{keyword}{public}: \textcolor{comment}{// IRegistryHub}}
\DoxyCodeLine{09551             RegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{09552             IReporterRegistry \textcolor{keyword}{const}\& getReporterRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{09553                 \textcolor{keywordflow}{return} m\_reporterRegistry;}
\DoxyCodeLine{09554             \}}
\DoxyCodeLine{09555             ITestCaseRegistry \textcolor{keyword}{const}\& getTestCaseRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{09556                 \textcolor{keywordflow}{return} m\_testCaseRegistry;}
\DoxyCodeLine{09557             \}}
\DoxyCodeLine{09558             IExceptionTranslatorRegistry \textcolor{keyword}{const}\& getExceptionTranslatorRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{09559                 \textcolor{keywordflow}{return} m\_exceptionTranslatorRegistry;}
\DoxyCodeLine{09560             \}}
\DoxyCodeLine{09561             ITagAliasRegistry \textcolor{keyword}{const}\& getTagAliasRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{09562                 \textcolor{keywordflow}{return} m\_tagAliasRegistry;}
\DoxyCodeLine{09563             \}}
\DoxyCodeLine{09564             StartupExceptionRegistry \textcolor{keyword}{const}\& getStartupExceptionRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{09565                 \textcolor{keywordflow}{return} m\_exceptionRegistry;}
\DoxyCodeLine{09566             \}}
\DoxyCodeLine{09567 }
\DoxyCodeLine{09568         \textcolor{keyword}{public}: \textcolor{comment}{// IMutableRegistryHub}}
\DoxyCodeLine{09569             \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{09570                 m\_reporterRegistry.registerReporter( name, factory );}
\DoxyCodeLine{09571             \}}
\DoxyCodeLine{09572             \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{09573                 m\_reporterRegistry.registerListener( factory );}
\DoxyCodeLine{09574             \}}
\DoxyCodeLine{09575             \textcolor{keywordtype}{void} registerTest( TestCase \textcolor{keyword}{const}\& testInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{09576                 m\_testCaseRegistry.registerTest( testInfo );}
\DoxyCodeLine{09577             \}}
\DoxyCodeLine{09578             \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{09579                 m\_exceptionTranslatorRegistry.registerTranslator( translator );}
\DoxyCodeLine{09580             \}}
\DoxyCodeLine{09581             \textcolor{keywordtype}{void} registerTagAlias( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{09582                 m\_tagAliasRegistry.add( alias, tag, lineInfo );}
\DoxyCodeLine{09583             \}}
\DoxyCodeLine{09584             \textcolor{keywordtype}{void} registerStartupException() noexcept\textcolor{keyword}{ override }\{}
\DoxyCodeLine{09585                 m\_exceptionRegistry.add(std::current\_exception());}
\DoxyCodeLine{09586             \}}
\DoxyCodeLine{09587 }
\DoxyCodeLine{09588         \textcolor{keyword}{private}:}
\DoxyCodeLine{09589             TestRegistry m\_testCaseRegistry;}
\DoxyCodeLine{09590             ReporterRegistry m\_reporterRegistry;}
\DoxyCodeLine{09591             ExceptionTranslatorRegistry m\_exceptionTranslatorRegistry;}
\DoxyCodeLine{09592             TagAliasRegistry m\_tagAliasRegistry;}
\DoxyCodeLine{09593             StartupExceptionRegistry m\_exceptionRegistry;}
\DoxyCodeLine{09594         \};}
\DoxyCodeLine{09595     \}}
\DoxyCodeLine{09596 }
\DoxyCodeLine{09597     \textcolor{keyword}{using} RegistryHubSingleton = Singleton<RegistryHub, IRegistryHub, IMutableRegistryHub>;}
\DoxyCodeLine{09598 }
\DoxyCodeLine{09599     IRegistryHub \textcolor{keyword}{const}\& getRegistryHub() \{}
\DoxyCodeLine{09600         \textcolor{keywordflow}{return} RegistryHubSingleton::get();}
\DoxyCodeLine{09601     \}}
\DoxyCodeLine{09602     IMutableRegistryHub\& getMutableRegistryHub() \{}
\DoxyCodeLine{09603         \textcolor{keywordflow}{return} RegistryHubSingleton::getMutable();}
\DoxyCodeLine{09604     \}}
\DoxyCodeLine{09605     \textcolor{keywordtype}{void} cleanUp() \{}
\DoxyCodeLine{09606         cleanupSingletons();}
\DoxyCodeLine{09607         cleanUpContext();}
\DoxyCodeLine{09608     \}}
\DoxyCodeLine{09609     std::string translateActiveException() \{}
\DoxyCodeLine{09610         \textcolor{keywordflow}{return} getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();}
\DoxyCodeLine{09611     \}}
\DoxyCodeLine{09612 }
\DoxyCodeLine{09613 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{09614 \textcolor{comment}{// end catch\_registry\_hub.cpp}}
\DoxyCodeLine{09615 \textcolor{comment}{// start catch\_reporter\_registry.cpp}}
\DoxyCodeLine{09616 }
\DoxyCodeLine{09617 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09618 }
\DoxyCodeLine{09619     ReporterRegistry::~ReporterRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{09620 }
\DoxyCodeLine{09621     IStreamingReporterPtr ReporterRegistry::create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{09622         \textcolor{keyword}{auto} it =  m\_factories.find( name );}
\DoxyCodeLine{09623         \textcolor{keywordflow}{if}( it == m\_factories.end() )}
\DoxyCodeLine{09624             \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{09625         \textcolor{keywordflow}{return} it->second->create( ReporterConfig( config ) );}
\DoxyCodeLine{09626     \}}
\DoxyCodeLine{09627 }
\DoxyCodeLine{09628     \textcolor{keywordtype}{void} ReporterRegistry::registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) \{}
\DoxyCodeLine{09629         m\_factories.emplace(name, factory);}
\DoxyCodeLine{09630     \}}
\DoxyCodeLine{09631     \textcolor{keywordtype}{void} ReporterRegistry::registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) \{}
\DoxyCodeLine{09632         m\_listeners.push\_back( factory );}
\DoxyCodeLine{09633     \}}
\DoxyCodeLine{09634 }
\DoxyCodeLine{09635     IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& ReporterRegistry::getFactories()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{09636         \textcolor{keywordflow}{return} m\_factories;}
\DoxyCodeLine{09637     \}}
\DoxyCodeLine{09638     IReporterRegistry::Listeners \textcolor{keyword}{const}\& ReporterRegistry::getListeners()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{09639         \textcolor{keywordflow}{return} m\_listeners;}
\DoxyCodeLine{09640     \}}
\DoxyCodeLine{09641 }
\DoxyCodeLine{09642 \}}
\DoxyCodeLine{09643 \textcolor{comment}{// end catch\_reporter\_registry.cpp}}
\DoxyCodeLine{09644 \textcolor{comment}{// start catch\_result\_type.cpp}}
\DoxyCodeLine{09645 }
\DoxyCodeLine{09646 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09647 }
\DoxyCodeLine{09648     \textcolor{keywordtype}{bool} isOk( ResultWas::OfType resultType ) \{}
\DoxyCodeLine{09649         \textcolor{keywordflow}{return} ( resultType \& ResultWas::FailureBit ) == 0;}
\DoxyCodeLine{09650     \}}
\DoxyCodeLine{09651     \textcolor{keywordtype}{bool} isJustInfo( \textcolor{keywordtype}{int} flags ) \{}
\DoxyCodeLine{09652         \textcolor{keywordflow}{return} flags == ResultWas::Info;}
\DoxyCodeLine{09653     \}}
\DoxyCodeLine{09654 }
\DoxyCodeLine{09655     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) \{}
\DoxyCodeLine{09656         \textcolor{keywordflow}{return} static\_cast<ResultDisposition::Flags>( static\_cast<int>( lhs ) | static\_cast<int>( rhs ) );}
\DoxyCodeLine{09657     \}}
\DoxyCodeLine{09658 }
\DoxyCodeLine{09659     \textcolor{keywordtype}{bool} shouldContinueOnFailure( \textcolor{keywordtype}{int} flags )    \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::ContinueOnFailure ) != 0; \}}
\DoxyCodeLine{09660     \textcolor{keywordtype}{bool} shouldSuppressFailure( \textcolor{keywordtype}{int} flags )      \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::SuppressFail ) != 0; \}}
\DoxyCodeLine{09661 }
\DoxyCodeLine{09662 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{09663 \textcolor{comment}{// end catch\_result\_type.cpp}}
\DoxyCodeLine{09664 \textcolor{comment}{// start catch\_run\_context.cpp}}
\DoxyCodeLine{09665 }
\DoxyCodeLine{09666 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{09667 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{09668 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{09669 }
\DoxyCodeLine{09670 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{09671 }
\DoxyCodeLine{09672     \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{09673         \textcolor{keyword}{struct }GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker \{}
\DoxyCodeLine{09674             \textcolor{keywordtype}{size\_t} m\_index = static\_cast<size\_t>( -1 );}
\DoxyCodeLine{09675             GeneratorBasePtr m\_generator;}
\DoxyCodeLine{09676 }
\DoxyCodeLine{09677             GeneratorTracker( TestCaseTracking::NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent )}
\DoxyCodeLine{09678             :   TrackerBase( nameAndLocation, ctx, parent )}
\DoxyCodeLine{09679             \{\}}
\DoxyCodeLine{09680             ~GeneratorTracker();}
\DoxyCodeLine{09681 }
\DoxyCodeLine{09682             \textcolor{keyword}{static} GeneratorTracker\& acquire( TrackerContext\& ctx, TestCaseTracking::NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{09683                 std::shared\_ptr<GeneratorTracker> tracker;}
\DoxyCodeLine{09684 }
\DoxyCodeLine{09685                 ITracker\& currentTracker = ctx.currentTracker();}
\DoxyCodeLine{09686                 \textcolor{keywordflow}{if}( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) \{}
\DoxyCodeLine{09687                     assert( childTracker );}
\DoxyCodeLine{09688                     assert( childTracker->isIndexTracker() );}
\DoxyCodeLine{09689                     tracker = std::static\_pointer\_cast<GeneratorTracker>( childTracker );}
\DoxyCodeLine{09690                 \}}
\DoxyCodeLine{09691                 \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{09692                     tracker = std::make\_shared<GeneratorTracker>( nameAndLocation, ctx, \&currentTracker );}
\DoxyCodeLine{09693                     currentTracker.addChild( tracker );}
\DoxyCodeLine{09694                 \}}
\DoxyCodeLine{09695 }
\DoxyCodeLine{09696                 \textcolor{keywordflow}{if}( !ctx.completedCycle() \&\& !tracker->isComplete() ) \{}
\DoxyCodeLine{09697                     \textcolor{keywordflow}{if}( tracker->m\_runState != ExecutingChildren \&\& tracker->m\_runState != NeedsAnotherRun )}
\DoxyCodeLine{09698                         tracker->moveNext();}
\DoxyCodeLine{09699                     tracker->open();}
\DoxyCodeLine{09700                 \}}
\DoxyCodeLine{09701 }
\DoxyCodeLine{09702                 \textcolor{keywordflow}{return} *tracker;}
\DoxyCodeLine{09703             \}}
\DoxyCodeLine{09704 }
\DoxyCodeLine{09705             \textcolor{keywordtype}{void} moveNext() \{}
\DoxyCodeLine{09706                 m\_index++;}
\DoxyCodeLine{09707                 m\_children.clear();}
\DoxyCodeLine{09708             \}}
\DoxyCodeLine{09709 }
\DoxyCodeLine{09710             \textcolor{comment}{// TrackerBase interface}}
\DoxyCodeLine{09711             \textcolor{keywordtype}{bool} isIndexTracker()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{09712             \textcolor{keyword}{auto} hasGenerator() const -> \textcolor{keywordtype}{bool}\textcolor{keyword}{ override }\{}
\DoxyCodeLine{09713                 \textcolor{keywordflow}{return} !!m\_generator;}
\DoxyCodeLine{09714             \}}
\DoxyCodeLine{09715             \textcolor{keywordtype}{void} close()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{09716                 TrackerBase::close();}
\DoxyCodeLine{09717                 \textcolor{keywordflow}{if}( m\_runState == CompletedSuccessfully \&\& m\_index < m\_generator->size()-1 )}
\DoxyCodeLine{09718                     m\_runState = Executing;}
\DoxyCodeLine{09719             \}}
\DoxyCodeLine{09720 }
\DoxyCodeLine{09721             \textcolor{comment}{// IGeneratorTracker interface}}
\DoxyCodeLine{09722             \textcolor{keyword}{auto} getGenerator() const -> GeneratorBasePtr const\&\textcolor{keyword}{ override }\{}
\DoxyCodeLine{09723                 \textcolor{keywordflow}{return} m\_generator;}
\DoxyCodeLine{09724             \}}
\DoxyCodeLine{09725             \textcolor{keywordtype}{void} setGenerator( GeneratorBasePtr\&\& generator )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{09726                 m\_generator = std::move( generator );}
\DoxyCodeLine{09727             \}}
\DoxyCodeLine{09728             \textcolor{keyword}{auto} getIndex() const -> \textcolor{keywordtype}{size\_t}\textcolor{keyword}{ override }\{}
\DoxyCodeLine{09729                 \textcolor{keywordflow}{return} m\_index;}
\DoxyCodeLine{09730             \}}
\DoxyCodeLine{09731         \};}
\DoxyCodeLine{09732         GeneratorTracker::~GeneratorTracker() \{\}}
\DoxyCodeLine{09733     \}}
\DoxyCodeLine{09734 }
\DoxyCodeLine{09735     RunContext::RunContext(IConfigPtr \textcolor{keyword}{const}\& \_config, IStreamingReporterPtr\&\& reporter)}
\DoxyCodeLine{09736     :   m\_runInfo(\_config->name()),}
\DoxyCodeLine{09737         m\_context(getCurrentMutableContext()),}
\DoxyCodeLine{09738         m\_config(\_config),}
\DoxyCodeLine{09739         m\_reporter(std::move(reporter)),}
\DoxyCodeLine{09740         m\_lastAssertionInfo\{ StringRef(), SourceLineInfo(\textcolor{stringliteral}{""},0), StringRef(), ResultDisposition::Normal \},}
\DoxyCodeLine{09741         m\_includeSuccessfulResults( m\_config->includeSuccessfulResults() || m\_reporter->getPreferences().shouldReportAllAssertions )}
\DoxyCodeLine{09742     \{}
\DoxyCodeLine{09743         m\_context.setRunner(\textcolor{keyword}{this});}
\DoxyCodeLine{09744         m\_context.setConfig(m\_config);}
\DoxyCodeLine{09745         m\_context.setResultCapture(\textcolor{keyword}{this});}
\DoxyCodeLine{09746         m\_reporter->testRunStarting(m\_runInfo);}
\DoxyCodeLine{09747     \}}
\DoxyCodeLine{09748 }
\DoxyCodeLine{09749     RunContext::~RunContext() \{}
\DoxyCodeLine{09750         m\_reporter->testRunEnded(TestRunStats(m\_runInfo, m\_totals, aborting()));}
\DoxyCodeLine{09751     \}}
\DoxyCodeLine{09752 }
\DoxyCodeLine{09753     \textcolor{keywordtype}{void} RunContext::testGroupStarting(std::string \textcolor{keyword}{const}\& testSpec, std::size\_t groupIndex, std::size\_t groupsCount) \{}
\DoxyCodeLine{09754         m\_reporter->testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));}
\DoxyCodeLine{09755     \}}
\DoxyCodeLine{09756 }
\DoxyCodeLine{09757     \textcolor{keywordtype}{void} RunContext::testGroupEnded(std::string \textcolor{keyword}{const}\& testSpec, Totals \textcolor{keyword}{const}\& totals, std::size\_t groupIndex, std::size\_t groupsCount) \{}
\DoxyCodeLine{09758         m\_reporter->testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));}
\DoxyCodeLine{09759     \}}
\DoxyCodeLine{09760 }
\DoxyCodeLine{09761     Totals RunContext::runTest(TestCase \textcolor{keyword}{const}\& testCase) \{}
\DoxyCodeLine{09762         Totals prevTotals = m\_totals;}
\DoxyCodeLine{09763 }
\DoxyCodeLine{09764         std::string redirectedCout;}
\DoxyCodeLine{09765         std::string redirectedCerr;}
\DoxyCodeLine{09766 }
\DoxyCodeLine{09767         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testInfo = testCase.getTestCaseInfo();}
\DoxyCodeLine{09768 }
\DoxyCodeLine{09769         m\_reporter->testCaseStarting(testInfo);}
\DoxyCodeLine{09770 }
\DoxyCodeLine{09771         m\_activeTestCase = \&testCase;}
\DoxyCodeLine{09772 }
\DoxyCodeLine{09773         ITracker\& rootTracker = m\_trackerContext.startRun();}
\DoxyCodeLine{09774         assert(rootTracker.isSectionTracker());}
\DoxyCodeLine{09775         static\_cast<SectionTracker\&>(rootTracker).addInitialFilters(m\_config->getSectionsToRun());}
\DoxyCodeLine{09776         \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{09777             m\_trackerContext.startCycle();}
\DoxyCodeLine{09778             m\_testCaseTracker = \&SectionTracker::acquire(m\_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));}
\DoxyCodeLine{09779             runCurrentTest(redirectedCout, redirectedCerr);}
\DoxyCodeLine{09780         \} \textcolor{keywordflow}{while} (!m\_testCaseTracker->isSuccessfullyCompleted() \&\& !aborting());}
\DoxyCodeLine{09781 }
\DoxyCodeLine{09782         Totals deltaTotals = m\_totals.delta(prevTotals);}
\DoxyCodeLine{09783         \textcolor{keywordflow}{if} (testInfo.expectedToFail() \&\& deltaTotals.testCases.passed > 0) \{}
\DoxyCodeLine{09784             deltaTotals.assertions.failed++;}
\DoxyCodeLine{09785             deltaTotals.testCases.passed--;}
\DoxyCodeLine{09786             deltaTotals.testCases.failed++;}
\DoxyCodeLine{09787         \}}
\DoxyCodeLine{09788         m\_totals.testCases += deltaTotals.testCases;}
\DoxyCodeLine{09789         m\_reporter->testCaseEnded(TestCaseStats(testInfo,}
\DoxyCodeLine{09790                                   deltaTotals,}
\DoxyCodeLine{09791                                   redirectedCout,}
\DoxyCodeLine{09792                                   redirectedCerr,}
\DoxyCodeLine{09793                                   aborting()));}
\DoxyCodeLine{09794 }
\DoxyCodeLine{09795         m\_activeTestCase = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{09796         m\_testCaseTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{09797 }
\DoxyCodeLine{09798         \textcolor{keywordflow}{return} deltaTotals;}
\DoxyCodeLine{09799     \}}
\DoxyCodeLine{09800 }
\DoxyCodeLine{09801     IConfigPtr RunContext::config()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{09802         \textcolor{keywordflow}{return} m\_config;}
\DoxyCodeLine{09803     \}}
\DoxyCodeLine{09804 }
\DoxyCodeLine{09805     IStreamingReporter\& RunContext::reporter()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{09806         \textcolor{keywordflow}{return} *m\_reporter;}
\DoxyCodeLine{09807     \}}
\DoxyCodeLine{09808 }
\DoxyCodeLine{09809     \textcolor{keywordtype}{void} RunContext::assertionEnded(AssertionResult \textcolor{keyword}{const} \& result) \{}
\DoxyCodeLine{09810         \textcolor{keywordflow}{if} (result.getResultType() == ResultWas::Ok) \{}
\DoxyCodeLine{09811             m\_totals.assertions.passed++;}
\DoxyCodeLine{09812             m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{09813         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!result.isOk()) \{}
\DoxyCodeLine{09814             m\_lastAssertionPassed = \textcolor{keyword}{false};}
\DoxyCodeLine{09815             \textcolor{keywordflow}{if}( m\_activeTestCase->getTestCaseInfo().okToFail() )}
\DoxyCodeLine{09816                 m\_totals.assertions.failedButOk++;}
\DoxyCodeLine{09817             \textcolor{keywordflow}{else}}
\DoxyCodeLine{09818                 m\_totals.assertions.failed++;}
\DoxyCodeLine{09819         \}}
\DoxyCodeLine{09820         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{09821             m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{09822         \}}
\DoxyCodeLine{09823 }
\DoxyCodeLine{09824         \textcolor{comment}{// We have no use for the return value (whether messages should be cleared), because messages were made scoped}}
\DoxyCodeLine{09825         \textcolor{comment}{// and should be let to clear themselves out.}}
\DoxyCodeLine{09826         static\_cast<void>(m\_reporter->assertionEnded(AssertionStats(result, m\_messages, m\_totals)));}
\DoxyCodeLine{09827 }
\DoxyCodeLine{09828         \textcolor{comment}{// Reset working state}}
\DoxyCodeLine{09829         resetAssertionInfo();}
\DoxyCodeLine{09830         m\_lastResult = result;}
\DoxyCodeLine{09831     \}}
\DoxyCodeLine{09832     \textcolor{keywordtype}{void} RunContext::resetAssertionInfo() \{}
\DoxyCodeLine{09833         m\_lastAssertionInfo.macroName = StringRef();}
\DoxyCodeLine{09834         m\_lastAssertionInfo.capturedExpression = \textcolor{stringliteral}{"\{Unknown expression after the reported line\}"}\_sr;}
\DoxyCodeLine{09835     \}}
\DoxyCodeLine{09836 }
\DoxyCodeLine{09837     \textcolor{keywordtype}{bool} RunContext::sectionStarted(SectionInfo \textcolor{keyword}{const} \& sectionInfo, Counts \& assertions) \{}
\DoxyCodeLine{09838         ITracker\& sectionTracker = SectionTracker::acquire(m\_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));}
\DoxyCodeLine{09839         \textcolor{keywordflow}{if} (!sectionTracker.isOpen())}
\DoxyCodeLine{09840             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{09841         m\_activeSections.push\_back(\&sectionTracker);}
\DoxyCodeLine{09842 }
\DoxyCodeLine{09843         m\_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;}
\DoxyCodeLine{09844 }
\DoxyCodeLine{09845         m\_reporter->sectionStarting(sectionInfo);}
\DoxyCodeLine{09846 }
\DoxyCodeLine{09847         assertions = m\_totals.assertions;}
\DoxyCodeLine{09848 }
\DoxyCodeLine{09849         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{09850     \}}
\DoxyCodeLine{09851     \textcolor{keyword}{auto} RunContext::acquireGeneratorTracker( SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -> IGeneratorTracker\& \{}
\DoxyCodeLine{09852         \textcolor{keyword}{using namespace }Generators;}
\DoxyCodeLine{09853         GeneratorTracker\& tracker = GeneratorTracker::acquire( m\_trackerContext, TestCaseTracking::NameAndLocation( \textcolor{stringliteral}{"generator"}, lineInfo ) );}
\DoxyCodeLine{09854         assert( tracker.isOpen() );}
\DoxyCodeLine{09855         m\_lastAssertionInfo.lineInfo = lineInfo;}
\DoxyCodeLine{09856         \textcolor{keywordflow}{return} tracker;}
\DoxyCodeLine{09857     \}}
\DoxyCodeLine{09858 }
\DoxyCodeLine{09859     \textcolor{keywordtype}{bool} RunContext::testForMissingAssertions(Counts\& assertions) \{}
\DoxyCodeLine{09860         \textcolor{keywordflow}{if} (assertions.total() != 0)}
\DoxyCodeLine{09861             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{09862         \textcolor{keywordflow}{if} (!m\_config->warnAboutMissingAssertions())}
\DoxyCodeLine{09863             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{09864         \textcolor{keywordflow}{if} (m\_trackerContext.currentTracker().hasChildren())}
\DoxyCodeLine{09865             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{09866         m\_totals.assertions.failed++;}
\DoxyCodeLine{09867         assertions.failed++;}
\DoxyCodeLine{09868         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{09869     \}}
\DoxyCodeLine{09870 }
\DoxyCodeLine{09871     \textcolor{keywordtype}{void} RunContext::sectionEnded(SectionEndInfo \textcolor{keyword}{const} \& endInfo) \{}
\DoxyCodeLine{09872         Counts assertions = m\_totals.assertions - endInfo.prevAssertions;}
\DoxyCodeLine{09873         \textcolor{keywordtype}{bool} missingAssertions = testForMissingAssertions(assertions);}
\DoxyCodeLine{09874 }
\DoxyCodeLine{09875         \textcolor{keywordflow}{if} (!m\_activeSections.empty()) \{}
\DoxyCodeLine{09876             m\_activeSections.back()->close();}
\DoxyCodeLine{09877             m\_activeSections.pop\_back();}
\DoxyCodeLine{09878         \}}
\DoxyCodeLine{09879 }
\DoxyCodeLine{09880         m\_reporter->sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));}
\DoxyCodeLine{09881         m\_messages.clear();}
\DoxyCodeLine{09882     \}}
\DoxyCodeLine{09883 }
\DoxyCodeLine{09884     \textcolor{keywordtype}{void} RunContext::sectionEndedEarly(SectionEndInfo \textcolor{keyword}{const} \& endInfo) \{}
\DoxyCodeLine{09885         \textcolor{keywordflow}{if} (m\_unfinishedSections.empty())}
\DoxyCodeLine{09886             m\_activeSections.back()->fail();}
\DoxyCodeLine{09887         \textcolor{keywordflow}{else}}
\DoxyCodeLine{09888             m\_activeSections.back()->close();}
\DoxyCodeLine{09889         m\_activeSections.pop\_back();}
\DoxyCodeLine{09890 }
\DoxyCodeLine{09891         m\_unfinishedSections.push\_back(endInfo);}
\DoxyCodeLine{09892     \}}
\DoxyCodeLine{09893     \textcolor{keywordtype}{void} RunContext::benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) \{}
\DoxyCodeLine{09894         m\_reporter->benchmarkStarting( info );}
\DoxyCodeLine{09895     \}}
\DoxyCodeLine{09896     \textcolor{keywordtype}{void} RunContext::benchmarkEnded( BenchmarkStats \textcolor{keyword}{const}\& stats ) \{}
\DoxyCodeLine{09897         m\_reporter->benchmarkEnded( stats );}
\DoxyCodeLine{09898     \}}
\DoxyCodeLine{09899 }
\DoxyCodeLine{09900     \textcolor{keywordtype}{void} RunContext::pushScopedMessage(MessageInfo \textcolor{keyword}{const} \& message) \{}
\DoxyCodeLine{09901         m\_messages.push\_back(message);}
\DoxyCodeLine{09902     \}}
\DoxyCodeLine{09903 }
\DoxyCodeLine{09904     \textcolor{keywordtype}{void} RunContext::popScopedMessage(MessageInfo \textcolor{keyword}{const} \& message) \{}
\DoxyCodeLine{09905         m\_messages.erase(std::remove(m\_messages.begin(), m\_messages.end(), message), m\_messages.end());}
\DoxyCodeLine{09906     \}}
\DoxyCodeLine{09907 }
\DoxyCodeLine{09908     std::string RunContext::getCurrentTestName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{09909         \textcolor{keywordflow}{return} m\_activeTestCase}
\DoxyCodeLine{09910             ? m\_activeTestCase->getTestCaseInfo().name}
\DoxyCodeLine{09911             : std::string();}
\DoxyCodeLine{09912     \}}
\DoxyCodeLine{09913 }
\DoxyCodeLine{09914     \textcolor{keyword}{const} AssertionResult * RunContext::getLastResult()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{09915         \textcolor{keywordflow}{return} \&(*m\_lastResult);}
\DoxyCodeLine{09916     \}}
\DoxyCodeLine{09917 }
\DoxyCodeLine{09918     \textcolor{keywordtype}{void} RunContext::exceptionEarlyReported() \{}
\DoxyCodeLine{09919         m\_shouldReportUnexpected = \textcolor{keyword}{false};}
\DoxyCodeLine{09920     \}}
\DoxyCodeLine{09921 }
\DoxyCodeLine{09922     \textcolor{keywordtype}{void} RunContext::handleFatalErrorCondition( StringRef message ) \{}
\DoxyCodeLine{09923         \textcolor{comment}{// First notify reporter that bad things happened}}
\DoxyCodeLine{09924         m\_reporter->fatalErrorEncountered(message);}
\DoxyCodeLine{09925 }
\DoxyCodeLine{09926         \textcolor{comment}{// Don't rebuild the result -- the stringification itself can cause more fatal errors}}
\DoxyCodeLine{09927         \textcolor{comment}{// Instead, fake a result data.}}
\DoxyCodeLine{09928         AssertionResultData tempResult( ResultWas::FatalErrorCondition, \{ \textcolor{keyword}{false} \} );}
\DoxyCodeLine{09929         tempResult.message = message;}
\DoxyCodeLine{09930         AssertionResult result(m\_lastAssertionInfo, tempResult);}
\DoxyCodeLine{09931 }
\DoxyCodeLine{09932         assertionEnded(result);}
\DoxyCodeLine{09933 }
\DoxyCodeLine{09934         handleUnfinishedSections();}
\DoxyCodeLine{09935 }
\DoxyCodeLine{09936         \textcolor{comment}{// Recreate section for test case (as we will lose the one that was in scope)}}
\DoxyCodeLine{09937         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo = m\_activeTestCase->getTestCaseInfo();}
\DoxyCodeLine{09938         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);}
\DoxyCodeLine{09939 }
\DoxyCodeLine{09940         Counts assertions;}
\DoxyCodeLine{09941         assertions.failed = 1;}
\DoxyCodeLine{09942         SectionStats testCaseSectionStats(testCaseSection, assertions, 0, \textcolor{keyword}{false});}
\DoxyCodeLine{09943         m\_reporter->sectionEnded(testCaseSectionStats);}
\DoxyCodeLine{09944 }
\DoxyCodeLine{09945         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testInfo = m\_activeTestCase->getTestCaseInfo();}
\DoxyCodeLine{09946 }
\DoxyCodeLine{09947         Totals deltaTotals;}
\DoxyCodeLine{09948         deltaTotals.testCases.failed = 1;}
\DoxyCodeLine{09949         deltaTotals.assertions.failed = 1;}
\DoxyCodeLine{09950         m\_reporter->testCaseEnded(TestCaseStats(testInfo,}
\DoxyCodeLine{09951                                   deltaTotals,}
\DoxyCodeLine{09952                                   std::string(),}
\DoxyCodeLine{09953                                   std::string(),}
\DoxyCodeLine{09954                                   \textcolor{keyword}{false}));}
\DoxyCodeLine{09955         m\_totals.testCases.failed++;}
\DoxyCodeLine{09956         testGroupEnded(std::string(), m\_totals, 1, 1);}
\DoxyCodeLine{09957         m\_reporter->testRunEnded(TestRunStats(m\_runInfo, m\_totals, \textcolor{keyword}{false}));}
\DoxyCodeLine{09958     \}}
\DoxyCodeLine{09959 }
\DoxyCodeLine{09960     \textcolor{keywordtype}{bool} RunContext::lastAssertionPassed() \{}
\DoxyCodeLine{09961          \textcolor{keywordflow}{return} m\_lastAssertionPassed;}
\DoxyCodeLine{09962     \}}
\DoxyCodeLine{09963 }
\DoxyCodeLine{09964     \textcolor{keywordtype}{void} RunContext::assertionPassed() \{}
\DoxyCodeLine{09965         m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{09966         ++m\_totals.assertions.passed;}
\DoxyCodeLine{09967         resetAssertionInfo();}
\DoxyCodeLine{09968     \}}
\DoxyCodeLine{09969 }
\DoxyCodeLine{09970     \textcolor{keywordtype}{bool} RunContext::aborting()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{09971         \textcolor{keywordflow}{return} m\_totals.assertions.failed >= static\_cast<std::size\_t>(m\_config->abortAfter());}
\DoxyCodeLine{09972     \}}
\DoxyCodeLine{09973 }
\DoxyCodeLine{09974     \textcolor{keywordtype}{void} RunContext::runCurrentTest(std::string \& redirectedCout, std::string \& redirectedCerr) \{}
\DoxyCodeLine{09975         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo = m\_activeTestCase->getTestCaseInfo();}
\DoxyCodeLine{09976         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);}
\DoxyCodeLine{09977         m\_reporter->sectionStarting(testCaseSection);}
\DoxyCodeLine{09978         Counts prevAssertions = m\_totals.assertions;}
\DoxyCodeLine{09979         \textcolor{keywordtype}{double} duration = 0;}
\DoxyCodeLine{09980         m\_shouldReportUnexpected = \textcolor{keyword}{true};}
\DoxyCodeLine{09981         m\_lastAssertionInfo = \{ \textcolor{stringliteral}{"TEST\_CASE"}\_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal \};}
\DoxyCodeLine{09982 }
\DoxyCodeLine{09983         seedRng(*m\_config);}
\DoxyCodeLine{09984 }
\DoxyCodeLine{09985         Timer timer;}
\DoxyCodeLine{09986         CATCH\_TRY \{}
\DoxyCodeLine{09987             \textcolor{keywordflow}{if} (m\_reporter->getPreferences().shouldRedirectStdOut) \{}
\DoxyCodeLine{09988 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_EXPERIMENTAL\_REDIRECT)}}
\DoxyCodeLine{09989                 RedirectedStdOut redirectedStdOut;}
\DoxyCodeLine{09990                 RedirectedStdErr redirectedStdErr;}
\DoxyCodeLine{09991 }
\DoxyCodeLine{09992                 timer.start();}
\DoxyCodeLine{09993                 invokeActiveTestCase();}
\DoxyCodeLine{09994                 redirectedCout += redirectedStdOut.str();}
\DoxyCodeLine{09995                 redirectedCerr += redirectedStdErr.str();}
\DoxyCodeLine{09996 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{09997                 OutputRedirect r(redirectedCout, redirectedCerr);}
\DoxyCodeLine{09998                 timer.start();}
\DoxyCodeLine{09999                 invokeActiveTestCase();}
\DoxyCodeLine{10000 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10001             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{10002                 timer.start();}
\DoxyCodeLine{10003                 invokeActiveTestCase();}
\DoxyCodeLine{10004             \}}
\DoxyCodeLine{10005             duration = timer.getElapsedSeconds();}
\DoxyCodeLine{10006         \} CATCH\_CATCH\_ANON (TestFailureException\&) \{}
\DoxyCodeLine{10007             \textcolor{comment}{// This just means the test was aborted due to failure}}
\DoxyCodeLine{10008         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{10009             \textcolor{comment}{// Under CATCH\_CONFIG\_FAST\_COMPILE, unexpected exceptions under REQUIRE assertions}}
\DoxyCodeLine{10010             \textcolor{comment}{// are reported without translation at the point of origin.}}
\DoxyCodeLine{10011             \textcolor{keywordflow}{if}( m\_shouldReportUnexpected ) \{}
\DoxyCodeLine{10012                 AssertionReaction dummyReaction;}
\DoxyCodeLine{10013                 handleUnexpectedInflightException( m\_lastAssertionInfo, translateActiveException(), dummyReaction );}
\DoxyCodeLine{10014             \}}
\DoxyCodeLine{10015         \}}
\DoxyCodeLine{10016         Counts assertions = m\_totals.assertions - prevAssertions;}
\DoxyCodeLine{10017         \textcolor{keywordtype}{bool} missingAssertions = testForMissingAssertions(assertions);}
\DoxyCodeLine{10018 }
\DoxyCodeLine{10019         m\_testCaseTracker->close();}
\DoxyCodeLine{10020         handleUnfinishedSections();}
\DoxyCodeLine{10021         m\_messages.clear();}
\DoxyCodeLine{10022 }
\DoxyCodeLine{10023         SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);}
\DoxyCodeLine{10024         m\_reporter->sectionEnded(testCaseSectionStats);}
\DoxyCodeLine{10025     \}}
\DoxyCodeLine{10026 }
\DoxyCodeLine{10027     \textcolor{keywordtype}{void} RunContext::invokeActiveTestCase() \{}
\DoxyCodeLine{10028         FatalConditionHandler fatalConditionHandler; \textcolor{comment}{// Handle signals}}
\DoxyCodeLine{10029         m\_activeTestCase->invoke();}
\DoxyCodeLine{10030         fatalConditionHandler.reset();}
\DoxyCodeLine{10031     \}}
\DoxyCodeLine{10032 }
\DoxyCodeLine{10033     \textcolor{keywordtype}{void} RunContext::handleUnfinishedSections() \{}
\DoxyCodeLine{10034         \textcolor{comment}{// If sections ended prematurely due to an exception we stored their}}
\DoxyCodeLine{10035         \textcolor{comment}{// infos here so we can tear them down outside the unwind process.}}
\DoxyCodeLine{10036         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = m\_unfinishedSections.rbegin(),}
\DoxyCodeLine{10037              itEnd = m\_unfinishedSections.rend();}
\DoxyCodeLine{10038              it != itEnd;}
\DoxyCodeLine{10039              ++it)}
\DoxyCodeLine{10040             sectionEnded(*it);}
\DoxyCodeLine{10041         m\_unfinishedSections.clear();}
\DoxyCodeLine{10042     \}}
\DoxyCodeLine{10043 }
\DoxyCodeLine{10044     \textcolor{keywordtype}{void} RunContext::handleExpr(}
\DoxyCodeLine{10045         AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{10046         ITransientExpression \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{10047         AssertionReaction\& reaction}
\DoxyCodeLine{10048     ) \{}
\DoxyCodeLine{10049         m\_reporter->assertionStarting( info );}
\DoxyCodeLine{10050 }
\DoxyCodeLine{10051         \textcolor{keywordtype}{bool} negated = isFalseTest( info.resultDisposition );}
\DoxyCodeLine{10052         \textcolor{keywordtype}{bool} result = expr.getResult() != negated;}
\DoxyCodeLine{10053 }
\DoxyCodeLine{10054         \textcolor{keywordflow}{if}( result ) \{}
\DoxyCodeLine{10055             \textcolor{keywordflow}{if} (!m\_includeSuccessfulResults) \{}
\DoxyCodeLine{10056                 assertionPassed();}
\DoxyCodeLine{10057             \}}
\DoxyCodeLine{10058             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{10059                 reportExpr(info, ResultWas::Ok, \&expr, negated);}
\DoxyCodeLine{10060             \}}
\DoxyCodeLine{10061         \}}
\DoxyCodeLine{10062         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{10063             reportExpr(info, ResultWas::ExpressionFailed, \&expr, negated );}
\DoxyCodeLine{10064             populateReaction( reaction );}
\DoxyCodeLine{10065         \}}
\DoxyCodeLine{10066     \}}
\DoxyCodeLine{10067     \textcolor{keywordtype}{void} RunContext::reportExpr(}
\DoxyCodeLine{10068             AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{10069             ResultWas::OfType resultType,}
\DoxyCodeLine{10070             ITransientExpression \textcolor{keyword}{const} *expr,}
\DoxyCodeLine{10071             \textcolor{keywordtype}{bool} negated ) \{}
\DoxyCodeLine{10072 }
\DoxyCodeLine{10073         m\_lastAssertionInfo = info;}
\DoxyCodeLine{10074         AssertionResultData data( resultType, LazyExpression( negated ) );}
\DoxyCodeLine{10075 }
\DoxyCodeLine{10076         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{10077         assertionResult.m\_resultData.lazyExpression.m\_transientExpression = expr;}
\DoxyCodeLine{10078 }
\DoxyCodeLine{10079         assertionEnded( assertionResult );}
\DoxyCodeLine{10080     \}}
\DoxyCodeLine{10081 }
\DoxyCodeLine{10082     \textcolor{keywordtype}{void} RunContext::handleMessage(}
\DoxyCodeLine{10083             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{10084             ResultWas::OfType resultType,}
\DoxyCodeLine{10085             StringRef \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{10086             AssertionReaction\& reaction}
\DoxyCodeLine{10087     ) \{}
\DoxyCodeLine{10088         m\_reporter->assertionStarting( info );}
\DoxyCodeLine{10089 }
\DoxyCodeLine{10090         m\_lastAssertionInfo = info;}
\DoxyCodeLine{10091 }
\DoxyCodeLine{10092         AssertionResultData data( resultType, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{10093         data.message = message;}
\DoxyCodeLine{10094         AssertionResult assertionResult\{ m\_lastAssertionInfo, data \};}
\DoxyCodeLine{10095         assertionEnded( assertionResult );}
\DoxyCodeLine{10096         \textcolor{keywordflow}{if}( !assertionResult.isOk() )}
\DoxyCodeLine{10097             populateReaction( reaction );}
\DoxyCodeLine{10098     \}}
\DoxyCodeLine{10099     \textcolor{keywordtype}{void} RunContext::handleUnexpectedExceptionNotThrown(}
\DoxyCodeLine{10100             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{10101             AssertionReaction\& reaction}
\DoxyCodeLine{10102     ) \{}
\DoxyCodeLine{10103         handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);}
\DoxyCodeLine{10104     \}}
\DoxyCodeLine{10105 }
\DoxyCodeLine{10106     \textcolor{keywordtype}{void} RunContext::handleUnexpectedInflightException(}
\DoxyCodeLine{10107             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{10108             std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{10109             AssertionReaction\& reaction}
\DoxyCodeLine{10110     ) \{}
\DoxyCodeLine{10111         m\_lastAssertionInfo = info;}
\DoxyCodeLine{10112 }
\DoxyCodeLine{10113         AssertionResultData data( ResultWas::ThrewException, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{10114         data.message = message;}
\DoxyCodeLine{10115         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{10116         assertionEnded( assertionResult );}
\DoxyCodeLine{10117         populateReaction( reaction );}
\DoxyCodeLine{10118     \}}
\DoxyCodeLine{10119 }
\DoxyCodeLine{10120     \textcolor{keywordtype}{void} RunContext::populateReaction( AssertionReaction\& reaction ) \{}
\DoxyCodeLine{10121         reaction.shouldDebugBreak = m\_config->shouldDebugBreak();}
\DoxyCodeLine{10122         reaction.shouldThrow = aborting() || (m\_lastAssertionInfo.resultDisposition \& ResultDisposition::Normal);}
\DoxyCodeLine{10123     \}}
\DoxyCodeLine{10124 }
\DoxyCodeLine{10125     \textcolor{keywordtype}{void} RunContext::handleIncomplete(}
\DoxyCodeLine{10126             AssertionInfo \textcolor{keyword}{const}\& info}
\DoxyCodeLine{10127     ) \{}
\DoxyCodeLine{10128         m\_lastAssertionInfo = info;}
\DoxyCodeLine{10129 }
\DoxyCodeLine{10130         AssertionResultData data( ResultWas::ThrewException, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{10131         data.message = \textcolor{stringliteral}{"Exception translation was disabled by CATCH\_CONFIG\_FAST\_COMPILE"};}
\DoxyCodeLine{10132         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{10133         assertionEnded( assertionResult );}
\DoxyCodeLine{10134     \}}
\DoxyCodeLine{10135     \textcolor{keywordtype}{void} RunContext::handleNonExpr(}
\DoxyCodeLine{10136             AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{10137             ResultWas::OfType resultType,}
\DoxyCodeLine{10138             AssertionReaction \&reaction}
\DoxyCodeLine{10139     ) \{}
\DoxyCodeLine{10140         m\_lastAssertionInfo = info;}
\DoxyCodeLine{10141 }
\DoxyCodeLine{10142         AssertionResultData data( resultType, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{10143         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{10144         assertionEnded( assertionResult );}
\DoxyCodeLine{10145 }
\DoxyCodeLine{10146         \textcolor{keywordflow}{if}( !assertionResult.isOk() )}
\DoxyCodeLine{10147             populateReaction( reaction );}
\DoxyCodeLine{10148     \}}
\DoxyCodeLine{10149 }
\DoxyCodeLine{10150     IResultCapture\& getResultCapture() \{}
\DoxyCodeLine{10151         \textcolor{keywordflow}{if} (\textcolor{keyword}{auto}* capture = getCurrentContext().getResultCapture())}
\DoxyCodeLine{10152             \textcolor{keywordflow}{return} *capture;}
\DoxyCodeLine{10153         \textcolor{keywordflow}{else}}
\DoxyCodeLine{10154             CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"No result capture instance"});}
\DoxyCodeLine{10155     \}}
\DoxyCodeLine{10156 \}}
\DoxyCodeLine{10157 \textcolor{comment}{// end catch\_run\_context.cpp}}
\DoxyCodeLine{10158 \textcolor{comment}{// start catch\_section.cpp}}
\DoxyCodeLine{10159 }
\DoxyCodeLine{10160 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10161 }
\DoxyCodeLine{10162     Section::Section( SectionInfo \textcolor{keyword}{const}\& info )}
\DoxyCodeLine{10163     :   m\_info( info ),}
\DoxyCodeLine{10164         m\_sectionIncluded( getResultCapture().sectionStarted( m\_info, m\_assertions ) )}
\DoxyCodeLine{10165     \{}
\DoxyCodeLine{10166         m\_timer.start();}
\DoxyCodeLine{10167     \}}
\DoxyCodeLine{10168 }
\DoxyCodeLine{10169     Section::~Section() \{}
\DoxyCodeLine{10170         \textcolor{keywordflow}{if}( m\_sectionIncluded ) \{}
\DoxyCodeLine{10171             SectionEndInfo endInfo\{ m\_info, m\_assertions, m\_timer.getElapsedSeconds() \};}
\DoxyCodeLine{10172             \textcolor{keywordflow}{if}( uncaught\_exceptions() )}
\DoxyCodeLine{10173                 getResultCapture().sectionEndedEarly( endInfo );}
\DoxyCodeLine{10174             \textcolor{keywordflow}{else}}
\DoxyCodeLine{10175                 getResultCapture().sectionEnded( endInfo );}
\DoxyCodeLine{10176         \}}
\DoxyCodeLine{10177     \}}
\DoxyCodeLine{10178 }
\DoxyCodeLine{10179     \textcolor{comment}{// This indicates whether the section should be executed or not}}
\DoxyCodeLine{10180     Section::operator bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10181         \textcolor{keywordflow}{return} m\_sectionIncluded;}
\DoxyCodeLine{10182     \}}
\DoxyCodeLine{10183 }
\DoxyCodeLine{10184 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10185 \textcolor{comment}{// end catch\_section.cpp}}
\DoxyCodeLine{10186 \textcolor{comment}{// start catch\_section\_info.cpp}}
\DoxyCodeLine{10187 }
\DoxyCodeLine{10188 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10189 }
\DoxyCodeLine{10190     SectionInfo::SectionInfo}
\DoxyCodeLine{10191         (   SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{10192             std::string \textcolor{keyword}{const}\& \_name )}
\DoxyCodeLine{10193     :   name( \_name ),}
\DoxyCodeLine{10194         lineInfo( \_lineInfo )}
\DoxyCodeLine{10195     \{\}}
\DoxyCodeLine{10196 }
\DoxyCodeLine{10197 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10198 \textcolor{comment}{// end catch\_section\_info.cpp}}
\DoxyCodeLine{10199 \textcolor{comment}{// start catch\_session.cpp}}
\DoxyCodeLine{10200 }
\DoxyCodeLine{10201 \textcolor{comment}{// start catch\_session.h}}
\DoxyCodeLine{10202 }
\DoxyCodeLine{10203 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{10204 }
\DoxyCodeLine{10205 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10206 }
\DoxyCodeLine{10207     \textcolor{keyword}{class }Session : NonCopyable \{}
\DoxyCodeLine{10208     \textcolor{keyword}{public}:}
\DoxyCodeLine{10209 }
\DoxyCodeLine{10210         Session();}
\DoxyCodeLine{10211         ~Session() \textcolor{keyword}{override};}
\DoxyCodeLine{10212 }
\DoxyCodeLine{10213         \textcolor{keywordtype}{void} showHelp() \textcolor{keyword}{const};}
\DoxyCodeLine{10214         \textcolor{keywordtype}{void} libIdentify();}
\DoxyCodeLine{10215 }
\DoxyCodeLine{10216         \textcolor{keywordtype}{int} applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv );}
\DoxyCodeLine{10217 \textcolor{preprocessor}{    \#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(WIN32) \&\& defined(UNICODE)}}
\DoxyCodeLine{10218         \textcolor{keywordtype}{int} applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv );}
\DoxyCodeLine{10219 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{10220 }
\DoxyCodeLine{10221         \textcolor{keywordtype}{void} useConfigData( ConfigData \textcolor{keyword}{const}\& configData );}
\DoxyCodeLine{10222 }
\DoxyCodeLine{10223         \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharT>}
\DoxyCodeLine{10224         \textcolor{keywordtype}{int} run(\textcolor{keywordtype}{int} argc, CharT \textcolor{keyword}{const} * \textcolor{keyword}{const} argv[]) \{}
\DoxyCodeLine{10225             \textcolor{keywordflow}{if} (m\_startupExceptions)}
\DoxyCodeLine{10226                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{10227             \textcolor{keywordtype}{int} returnCode = applyCommandLine(argc, argv);}
\DoxyCodeLine{10228             \textcolor{keywordflow}{if} (returnCode == 0)}
\DoxyCodeLine{10229                 returnCode = run();}
\DoxyCodeLine{10230             \textcolor{keywordflow}{return} returnCode;}
\DoxyCodeLine{10231         \}}
\DoxyCodeLine{10232 }
\DoxyCodeLine{10233         \textcolor{keywordtype}{int} run();}
\DoxyCodeLine{10234 }
\DoxyCodeLine{10235         clara::Parser \textcolor{keyword}{const}\& cli() \textcolor{keyword}{const};}
\DoxyCodeLine{10236         \textcolor{keywordtype}{void} cli( clara::Parser \textcolor{keyword}{const}\& newParser );}
\DoxyCodeLine{10237         ConfigData\& configData();}
\DoxyCodeLine{10238         Config\& config();}
\DoxyCodeLine{10239     \textcolor{keyword}{private}:}
\DoxyCodeLine{10240         \textcolor{keywordtype}{int} runInternal();}
\DoxyCodeLine{10241 }
\DoxyCodeLine{10242         clara::Parser m\_cli;}
\DoxyCodeLine{10243         ConfigData m\_configData;}
\DoxyCodeLine{10244         std::shared\_ptr<Config> m\_config;}
\DoxyCodeLine{10245         \textcolor{keywordtype}{bool} m\_startupExceptions = \textcolor{keyword}{false};}
\DoxyCodeLine{10246     \};}
\DoxyCodeLine{10247 }
\DoxyCodeLine{10248 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10249 }
\DoxyCodeLine{10250 \textcolor{comment}{// end catch\_session.h}}
\DoxyCodeLine{10251 \textcolor{comment}{// start catch\_version.h}}
\DoxyCodeLine{10252 }
\DoxyCodeLine{10253 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{10254 }
\DoxyCodeLine{10255 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10256 }
\DoxyCodeLine{10257     \textcolor{comment}{// Versioning information}}
\DoxyCodeLine{10258     \textcolor{keyword}{struct }Version \{}
\DoxyCodeLine{10259         Version( Version \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{10260         Version\& operator=( Version \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{10261         Version(    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_majorVersion,}
\DoxyCodeLine{10262                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_minorVersion,}
\DoxyCodeLine{10263                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_patchNumber,}
\DoxyCodeLine{10264                     \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} \_branchName,}
\DoxyCodeLine{10265                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_buildNumber );}
\DoxyCodeLine{10266 }
\DoxyCodeLine{10267         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} majorVersion;}
\DoxyCodeLine{10268         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} minorVersion;}
\DoxyCodeLine{10269         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} patchNumber;}
\DoxyCodeLine{10270 }
\DoxyCodeLine{10271         \textcolor{comment}{// buildNumber is only used if branchName is not null}}
\DoxyCodeLine{10272         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} branchName;}
\DoxyCodeLine{10273         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} buildNumber;}
\DoxyCodeLine{10274 }
\DoxyCodeLine{10275         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, Version \textcolor{keyword}{const}\& version );}
\DoxyCodeLine{10276     \};}
\DoxyCodeLine{10277 }
\DoxyCodeLine{10278     Version \textcolor{keyword}{const}\& libraryVersion();}
\DoxyCodeLine{10279 \}}
\DoxyCodeLine{10280 }
\DoxyCodeLine{10281 \textcolor{comment}{// end catch\_version.h}}
\DoxyCodeLine{10282 \textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{10283 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{10284 }
\DoxyCodeLine{10285 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10286 }
\DoxyCodeLine{10287     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10288         \textcolor{keyword}{const} \textcolor{keywordtype}{int} MaxExitCode = 255;}
\DoxyCodeLine{10289 }
\DoxyCodeLine{10290         IStreamingReporterPtr createReporter(std::string \textcolor{keyword}{const}\& reporterName, IConfigPtr \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{10291             \textcolor{keyword}{auto} reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);}
\DoxyCodeLine{10292             CATCH\_ENFORCE(reporter, \textcolor{stringliteral}{"No reporter registered with name: '"} << reporterName << \textcolor{stringliteral}{"'"});}
\DoxyCodeLine{10293 }
\DoxyCodeLine{10294             \textcolor{keywordflow}{return} reporter;}
\DoxyCodeLine{10295         \}}
\DoxyCodeLine{10296 }
\DoxyCodeLine{10297         IStreamingReporterPtr makeReporter(std::shared\_ptr<Config> \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{10298             \textcolor{keywordflow}{if} (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) \{}
\DoxyCodeLine{10299                 \textcolor{keywordflow}{return} createReporter(config->getReporterName(), config);}
\DoxyCodeLine{10300             \}}
\DoxyCodeLine{10301 }
\DoxyCodeLine{10302             \textcolor{keyword}{auto} multi = std::unique\_ptr<ListeningReporter>(\textcolor{keyword}{new} ListeningReporter);}
\DoxyCodeLine{10303 }
\DoxyCodeLine{10304             \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();}
\DoxyCodeLine{10305             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : listeners) \{}
\DoxyCodeLine{10306                 multi->addListener(listener->create(Catch::ReporterConfig(config)));}
\DoxyCodeLine{10307             \}}
\DoxyCodeLine{10308             multi->addReporter(createReporter(config->getReporterName(), config));}
\DoxyCodeLine{10309             \textcolor{keywordflow}{return} std::move(multi);}
\DoxyCodeLine{10310         \}}
\DoxyCodeLine{10311 }
\DoxyCodeLine{10312         \mbox{\hyperlink{structCatch_1_1Totals}{Catch::Totals}} runTests(std::shared\_ptr<Config> \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{10313             \textcolor{keyword}{auto} reporter = makeReporter(config);}
\DoxyCodeLine{10314 }
\DoxyCodeLine{10315             RunContext context(config, std::move(reporter));}
\DoxyCodeLine{10316 }
\DoxyCodeLine{10317             Totals totals;}
\DoxyCodeLine{10318 }
\DoxyCodeLine{10319             context.testGroupStarting(config->name(), 1, 1);}
\DoxyCodeLine{10320 }
\DoxyCodeLine{10321             TestSpec testSpec = config->testSpec();}
\DoxyCodeLine{10322 }
\DoxyCodeLine{10323             \textcolor{keyword}{auto} \textcolor{keyword}{const}\& allTestCases = getAllTestCasesSorted(*config);}
\DoxyCodeLine{10324             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : allTestCases) \{}
\DoxyCodeLine{10325                 \textcolor{keywordflow}{if} (!context.aborting() \&\& matchTest(testCase, testSpec, *config))}
\DoxyCodeLine{10326                     totals += context.runTest(testCase);}
\DoxyCodeLine{10327                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{10328                     context.reporter().skipTest(testCase);}
\DoxyCodeLine{10329             \}}
\DoxyCodeLine{10330 }
\DoxyCodeLine{10331             \textcolor{keywordflow}{if} (config->warnAboutNoTests() \&\& totals.testCases.total() == 0) \{}
\DoxyCodeLine{10332                 ReusableStringStream testConfig;}
\DoxyCodeLine{10333 }
\DoxyCodeLine{10334                 \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{10335                 \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& input : config->getTestsOrTags()) \{}
\DoxyCodeLine{10336                     \textcolor{keywordflow}{if} (!first) \{ testConfig << \textcolor{charliteral}{' '}; \}}
\DoxyCodeLine{10337                     first = \textcolor{keyword}{false};}
\DoxyCodeLine{10338                     testConfig << input;}
\DoxyCodeLine{10339                 \}}
\DoxyCodeLine{10340 }
\DoxyCodeLine{10341                 context.reporter().noMatchingTestCases(testConfig.str());}
\DoxyCodeLine{10342                 totals.error = -1;}
\DoxyCodeLine{10343             \}}
\DoxyCodeLine{10344 }
\DoxyCodeLine{10345             context.testGroupEnded(config->name(), totals, 1, 1);}
\DoxyCodeLine{10346             \textcolor{keywordflow}{return} totals;}
\DoxyCodeLine{10347         \}}
\DoxyCodeLine{10348 }
\DoxyCodeLine{10349         \textcolor{keywordtype}{void} applyFilenamesAsTags(Catch::IConfig \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{10350             \textcolor{keyword}{auto}\& tests = \textcolor{keyword}{const\_cast<}std::vector<TestCase>\&\textcolor{keyword}{>}(getAllTestCasesSorted(config));}
\DoxyCodeLine{10351             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& testCase : tests) \{}
\DoxyCodeLine{10352                 \textcolor{keyword}{auto} tags = testCase.tags;}
\DoxyCodeLine{10353 }
\DoxyCodeLine{10354                 std::string filename = testCase.lineInfo.file;}
\DoxyCodeLine{10355                 \textcolor{keyword}{auto} lastSlash = filename.find\_last\_of(\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)/"});}
\DoxyCodeLine{10356                 \textcolor{keywordflow}{if} (lastSlash != std::string::npos) \{}
\DoxyCodeLine{10357                     filename.erase(0, lastSlash);}
\DoxyCodeLine{10358                     filename[0] = \textcolor{charliteral}{'\#'};}
\DoxyCodeLine{10359                 \}}
\DoxyCodeLine{10360 }
\DoxyCodeLine{10361                 \textcolor{keyword}{auto} lastDot = filename.find\_last\_of(\textcolor{charliteral}{'.'});}
\DoxyCodeLine{10362                 \textcolor{keywordflow}{if} (lastDot != std::string::npos) \{}
\DoxyCodeLine{10363                     filename.erase(lastDot);}
\DoxyCodeLine{10364                 \}}
\DoxyCodeLine{10365 }
\DoxyCodeLine{10366                 tags.push\_back(std::move(filename));}
\DoxyCodeLine{10367                 setTags(testCase, tags);}
\DoxyCodeLine{10368             \}}
\DoxyCodeLine{10369         \}}
\DoxyCodeLine{10370 }
\DoxyCodeLine{10371     \} \textcolor{comment}{// anon namespace}}
\DoxyCodeLine{10372 }
\DoxyCodeLine{10373     Session::Session() \{}
\DoxyCodeLine{10374         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} alreadyInstantiated = \textcolor{keyword}{false};}
\DoxyCodeLine{10375         \textcolor{keywordflow}{if}( alreadyInstantiated ) \{}
\DoxyCodeLine{10376             CATCH\_TRY \{ CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"Only one instance of Catch::Session can ever be used"} ); \}}
\DoxyCodeLine{10377             CATCH\_CATCH\_ALL \{ getMutableRegistryHub().registerStartupException(); \}}
\DoxyCodeLine{10378         \}}
\DoxyCodeLine{10379 }
\DoxyCodeLine{10380         \textcolor{comment}{// There cannot be exceptions at startup in no-exception mode.}}
\DoxyCodeLine{10381 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{10382         \textcolor{keyword}{const} \textcolor{keyword}{auto}\& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();}
\DoxyCodeLine{10383         \textcolor{keywordflow}{if} ( !exceptions.empty() ) \{}
\DoxyCodeLine{10384             m\_startupExceptions = \textcolor{keyword}{true};}
\DoxyCodeLine{10385             Colour colourGuard( Colour::Red );}
\DoxyCodeLine{10386             Catch::cerr() << \textcolor{stringliteral}{"Errors occurred during startup!"} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10387             \textcolor{comment}{// iterate over all exceptions and notify user}}
\DoxyCodeLine{10388             \textcolor{keywordflow}{for} ( \textcolor{keyword}{const} \textcolor{keyword}{auto}\& ex\_ptr : exceptions ) \{}
\DoxyCodeLine{10389                 \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{10390                     std::rethrow\_exception(ex\_ptr);}
\DoxyCodeLine{10391                 \} \textcolor{keywordflow}{catch} ( std::exception \textcolor{keyword}{const}\& ex ) \{}
\DoxyCodeLine{10392                     Catch::cerr() << Column( ex.what() ).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10393                 \}}
\DoxyCodeLine{10394             \}}
\DoxyCodeLine{10395         \}}
\DoxyCodeLine{10396 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10397 }
\DoxyCodeLine{10398         alreadyInstantiated = \textcolor{keyword}{true};}
\DoxyCodeLine{10399         m\_cli = makeCommandLineParser( m\_configData );}
\DoxyCodeLine{10400     \}}
\DoxyCodeLine{10401     Session::~Session() \{}
\DoxyCodeLine{10402         Catch::cleanUp();}
\DoxyCodeLine{10403     \}}
\DoxyCodeLine{10404 }
\DoxyCodeLine{10405     \textcolor{keywordtype}{void} Session::showHelp()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10406         Catch::cout()}
\DoxyCodeLine{10407                 << \textcolor{stringliteral}{"\(\backslash\)nCatch v"} << libraryVersion() << \textcolor{stringliteral}{"\(\backslash\)n"}}
\DoxyCodeLine{10408                 << m\_cli << std::endl}
\DoxyCodeLine{10409                 << \textcolor{stringliteral}{"For more detailed usage please see the project docs\(\backslash\)n"} << std::endl;}
\DoxyCodeLine{10410     \}}
\DoxyCodeLine{10411     \textcolor{keywordtype}{void} Session::libIdentify() \{}
\DoxyCodeLine{10412         Catch::cout()}
\DoxyCodeLine{10413                 << std::left << std::setw(16) << \textcolor{stringliteral}{"description: "} << \textcolor{stringliteral}{"A Catch test executable\(\backslash\)n"}}
\DoxyCodeLine{10414                 << std::left << std::setw(16) << \textcolor{stringliteral}{"category: "} << \textcolor{stringliteral}{"testframework\(\backslash\)n"}}
\DoxyCodeLine{10415                 << std::left << std::setw(16) << \textcolor{stringliteral}{"framework: "} << \textcolor{stringliteral}{"Catch Test\(\backslash\)n"}}
\DoxyCodeLine{10416                 << std::left << std::setw(16) << \textcolor{stringliteral}{"version: "} << libraryVersion() << std::endl;}
\DoxyCodeLine{10417     \}}
\DoxyCodeLine{10418 }
\DoxyCodeLine{10419     \textcolor{keywordtype}{int} Session::applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv ) \{}
\DoxyCodeLine{10420         \textcolor{keywordflow}{if}( m\_startupExceptions )}
\DoxyCodeLine{10421             \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{10422 }
\DoxyCodeLine{10423         \textcolor{keyword}{auto} result = m\_cli.parse( clara::Args( argc, argv ) );}
\DoxyCodeLine{10424         \textcolor{keywordflow}{if}( !result ) \{}
\DoxyCodeLine{10425             Catch::cerr()}
\DoxyCodeLine{10426                 << Colour( Colour::Red )}
\DoxyCodeLine{10427                 << \textcolor{stringliteral}{"\(\backslash\)nError(s) in input:\(\backslash\)n"}}
\DoxyCodeLine{10428                 << Column( result.errorMessage() ).indent( 2 )}
\DoxyCodeLine{10429                 << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};}
\DoxyCodeLine{10430             Catch::cerr() << \textcolor{stringliteral}{"Run with -? for usage\(\backslash\)n"} << std::endl;}
\DoxyCodeLine{10431             \textcolor{keywordflow}{return} MaxExitCode;}
\DoxyCodeLine{10432         \}}
\DoxyCodeLine{10433 }
\DoxyCodeLine{10434         \textcolor{keywordflow}{if}( m\_configData.showHelp )}
\DoxyCodeLine{10435             showHelp();}
\DoxyCodeLine{10436         \textcolor{keywordflow}{if}( m\_configData.libIdentify )}
\DoxyCodeLine{10437             libIdentify();}
\DoxyCodeLine{10438         m\_config.reset();}
\DoxyCodeLine{10439         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{10440     \}}
\DoxyCodeLine{10441 }
\DoxyCodeLine{10442 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(WIN32) \&\& defined(UNICODE)}}
\DoxyCodeLine{10443     \textcolor{keywordtype}{int} Session::applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv ) \{}
\DoxyCodeLine{10444 }
\DoxyCodeLine{10445         \textcolor{keywordtype}{char} **utf8Argv = \textcolor{keyword}{new} \textcolor{keywordtype}{char} *[ argc ];}
\DoxyCodeLine{10446 }
\DoxyCodeLine{10447         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < argc; ++i ) \{}
\DoxyCodeLine{10448             \textcolor{keywordtype}{int} bufSize = WideCharToMultiByte( CP\_UTF8, 0, argv[i], -1, NULL, 0, NULL, NULL );}
\DoxyCodeLine{10449 }
\DoxyCodeLine{10450             utf8Argv[ i ] = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[ bufSize ];}
\DoxyCodeLine{10451 }
\DoxyCodeLine{10452             WideCharToMultiByte( CP\_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, NULL, NULL );}
\DoxyCodeLine{10453         \}}
\DoxyCodeLine{10454 }
\DoxyCodeLine{10455         \textcolor{keywordtype}{int} returnCode = applyCommandLine( argc, utf8Argv );}
\DoxyCodeLine{10456 }
\DoxyCodeLine{10457         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < argc; ++i )}
\DoxyCodeLine{10458             delete [] utf8Argv[ i ];}
\DoxyCodeLine{10459 }
\DoxyCodeLine{10460         \textcolor{keyword}{delete} [] utf8Argv;}
\DoxyCodeLine{10461 }
\DoxyCodeLine{10462         \textcolor{keywordflow}{return} returnCode;}
\DoxyCodeLine{10463     \}}
\DoxyCodeLine{10464 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10465 }
\DoxyCodeLine{10466     \textcolor{keywordtype}{void} Session::useConfigData( ConfigData \textcolor{keyword}{const}\& configData ) \{}
\DoxyCodeLine{10467         m\_configData = configData;}
\DoxyCodeLine{10468         m\_config.reset();}
\DoxyCodeLine{10469     \}}
\DoxyCodeLine{10470 }
\DoxyCodeLine{10471     \textcolor{keywordtype}{int} Session::run() \{}
\DoxyCodeLine{10472         \textcolor{keywordflow}{if}( ( m\_configData.waitForKeypress \& WaitForKeypress::BeforeStart ) != 0 ) \{}
\DoxyCodeLine{10473             Catch::cout() << \textcolor{stringliteral}{"...waiting for enter/ return before starting"} << std::endl;}
\DoxyCodeLine{10474             static\_cast<void>(std::getchar());}
\DoxyCodeLine{10475         \}}
\DoxyCodeLine{10476         \textcolor{keywordtype}{int} exitCode = runInternal();}
\DoxyCodeLine{10477         \textcolor{keywordflow}{if}( ( m\_configData.waitForKeypress \& WaitForKeypress::BeforeExit ) != 0 ) \{}
\DoxyCodeLine{10478             Catch::cout() << \textcolor{stringliteral}{"...waiting for enter/ return before exiting, with code: "} << exitCode << std::endl;}
\DoxyCodeLine{10479             static\_cast<void>(std::getchar());}
\DoxyCodeLine{10480         \}}
\DoxyCodeLine{10481         \textcolor{keywordflow}{return} exitCode;}
\DoxyCodeLine{10482     \}}
\DoxyCodeLine{10483 }
\DoxyCodeLine{10484     clara::Parser \textcolor{keyword}{const}\& Session::cli()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10485         \textcolor{keywordflow}{return} m\_cli;}
\DoxyCodeLine{10486     \}}
\DoxyCodeLine{10487     \textcolor{keywordtype}{void} Session::cli( clara::Parser \textcolor{keyword}{const}\& newParser ) \{}
\DoxyCodeLine{10488         m\_cli = newParser;}
\DoxyCodeLine{10489     \}}
\DoxyCodeLine{10490     ConfigData\& Session::configData() \{}
\DoxyCodeLine{10491         \textcolor{keywordflow}{return} m\_configData;}
\DoxyCodeLine{10492     \}}
\DoxyCodeLine{10493     Config\& Session::config() \{}
\DoxyCodeLine{10494         \textcolor{keywordflow}{if}( !m\_config )}
\DoxyCodeLine{10495             m\_config = std::make\_shared<Config>( m\_configData );}
\DoxyCodeLine{10496         \textcolor{keywordflow}{return} *m\_config;}
\DoxyCodeLine{10497     \}}
\DoxyCodeLine{10498 }
\DoxyCodeLine{10499     \textcolor{keywordtype}{int} Session::runInternal() \{}
\DoxyCodeLine{10500         \textcolor{keywordflow}{if}( m\_startupExceptions )}
\DoxyCodeLine{10501             \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{10502 }
\DoxyCodeLine{10503         \textcolor{keywordflow}{if} (m\_configData.showHelp || m\_configData.libIdentify) \{}
\DoxyCodeLine{10504             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{10505         \}}
\DoxyCodeLine{10506 }
\DoxyCodeLine{10507         CATCH\_TRY \{}
\DoxyCodeLine{10508             config(); \textcolor{comment}{// Force config to be constructed}}
\DoxyCodeLine{10509 }
\DoxyCodeLine{10510             seedRng( *m\_config );}
\DoxyCodeLine{10511 }
\DoxyCodeLine{10512             \textcolor{keywordflow}{if}( m\_configData.filenamesAsTags )}
\DoxyCodeLine{10513                 applyFilenamesAsTags( *m\_config );}
\DoxyCodeLine{10514 }
\DoxyCodeLine{10515             \textcolor{comment}{// Handle list request}}
\DoxyCodeLine{10516             \textcolor{keywordflow}{if}( Option<std::size\_t> listed = list( config() ) )}
\DoxyCodeLine{10517                 \textcolor{keywordflow}{return} static\_cast<int>( *listed );}
\DoxyCodeLine{10518 }
\DoxyCodeLine{10519             \textcolor{keyword}{auto} totals = runTests( m\_config );}
\DoxyCodeLine{10520             \textcolor{comment}{// Note that on unices only the lower 8 bits are usually used, clamping}}
\DoxyCodeLine{10521             \textcolor{comment}{// the return value to 255 prevents false negative when some multiple}}
\DoxyCodeLine{10522             \textcolor{comment}{// of 256 tests has failed}}
\DoxyCodeLine{10523             \textcolor{keywordflow}{return} (std::min) (MaxExitCode, (std::max) (totals.error, static\_cast<int>(totals.assertions.failed)));}
\DoxyCodeLine{10524         \}}
\DoxyCodeLine{10525 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{10526         \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{10527             Catch::cerr() << ex.what() << std::endl;}
\DoxyCodeLine{10528             \textcolor{keywordflow}{return} MaxExitCode;}
\DoxyCodeLine{10529         \}}
\DoxyCodeLine{10530 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10531     \}}
\DoxyCodeLine{10532 }
\DoxyCodeLine{10533 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10534 \textcolor{comment}{// end catch\_session.cpp}}
\DoxyCodeLine{10535 \textcolor{comment}{// start catch\_singletons.cpp}}
\DoxyCodeLine{10536 }
\DoxyCodeLine{10537 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{10538 }
\DoxyCodeLine{10539 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10540 }
\DoxyCodeLine{10541     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10542         \textcolor{keyword}{static} \textcolor{keyword}{auto} getSingletons() -> std::vector<ISingleton*>*\& \{}
\DoxyCodeLine{10543             \textcolor{keyword}{static} std::vector<ISingleton*>* g\_singletons = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10544             \textcolor{keywordflow}{if}( !g\_singletons )}
\DoxyCodeLine{10545                 g\_singletons = \textcolor{keyword}{new} std::vector<ISingleton*>();}
\DoxyCodeLine{10546             \textcolor{keywordflow}{return} g\_singletons;}
\DoxyCodeLine{10547         \}}
\DoxyCodeLine{10548     \}}
\DoxyCodeLine{10549 }
\DoxyCodeLine{10550     ISingleton::~ISingleton() \{\}}
\DoxyCodeLine{10551 }
\DoxyCodeLine{10552     \textcolor{keywordtype}{void} addSingleton(ISingleton* singleton ) \{}
\DoxyCodeLine{10553         getSingletons()->push\_back( singleton );}
\DoxyCodeLine{10554     \}}
\DoxyCodeLine{10555     \textcolor{keywordtype}{void} cleanupSingletons() \{}
\DoxyCodeLine{10556         \textcolor{keyword}{auto}\& singletons = getSingletons();}
\DoxyCodeLine{10557         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} singleton : *singletons )}
\DoxyCodeLine{10558             \textcolor{keyword}{delete} singleton;}
\DoxyCodeLine{10559         \textcolor{keyword}{delete} singletons;}
\DoxyCodeLine{10560         singletons = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10561     \}}
\DoxyCodeLine{10562 }
\DoxyCodeLine{10563 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10564 \textcolor{comment}{// end catch\_singletons.cpp}}
\DoxyCodeLine{10565 \textcolor{comment}{// start catch\_startup\_exception\_registry.cpp}}
\DoxyCodeLine{10566 }
\DoxyCodeLine{10567 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10568 \textcolor{keywordtype}{void} StartupExceptionRegistry::add( std::exception\_ptr \textcolor{keyword}{const}\& exception ) noexcept \{}
\DoxyCodeLine{10569         CATCH\_TRY \{}
\DoxyCodeLine{10570             m\_exceptions.push\_back(exception);}
\DoxyCodeLine{10571         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{10572             \textcolor{comment}{// If we run out of memory during start-up there's really not a lot more we can do about it}}
\DoxyCodeLine{10573             std::terminate();}
\DoxyCodeLine{10574         \}}
\DoxyCodeLine{10575     \}}
\DoxyCodeLine{10576 }
\DoxyCodeLine{10577     std::vector<std::exception\_ptr> \textcolor{keyword}{const}\& StartupExceptionRegistry::getExceptions() const noexcept \{}
\DoxyCodeLine{10578         \textcolor{keywordflow}{return} m\_exceptions;}
\DoxyCodeLine{10579     \}}
\DoxyCodeLine{10580 }
\DoxyCodeLine{10581 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10582 \textcolor{comment}{// end catch\_startup\_exception\_registry.cpp}}
\DoxyCodeLine{10583 \textcolor{comment}{// start catch\_stream.cpp}}
\DoxyCodeLine{10584 }
\DoxyCodeLine{10585 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{10586 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{10587 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{10588 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{10589 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{10590 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{10591 }
\DoxyCodeLine{10592 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10593 }
\DoxyCodeLine{10594     Catch::IStream::~IStream() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10595 }
\DoxyCodeLine{10596     \textcolor{keyword}{namespace }detail \{ \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10597         \textcolor{keyword}{template}<\textcolor{keyword}{typename} WriterF, std::\textcolor{keywordtype}{size\_t} bufferSize=256>}
\DoxyCodeLine{10598         \textcolor{keyword}{class }StreamBufImpl : \textcolor{keyword}{public} std::streambuf \{}
\DoxyCodeLine{10599             \textcolor{keywordtype}{char} data[bufferSize];}
\DoxyCodeLine{10600             WriterF m\_writer;}
\DoxyCodeLine{10601 }
\DoxyCodeLine{10602         \textcolor{keyword}{public}:}
\DoxyCodeLine{10603             StreamBufImpl() \{}
\DoxyCodeLine{10604                 setp( data, data + \textcolor{keyword}{sizeof}(data) );}
\DoxyCodeLine{10605             \}}
\DoxyCodeLine{10606 }
\DoxyCodeLine{10607             ~StreamBufImpl() noexcept \{}
\DoxyCodeLine{10608                 StreamBufImpl::sync();}
\DoxyCodeLine{10609             \}}
\DoxyCodeLine{10610 }
\DoxyCodeLine{10611         \textcolor{keyword}{private}:}
\DoxyCodeLine{10612             \textcolor{keywordtype}{int} overflow( \textcolor{keywordtype}{int} c )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10613                 sync();}
\DoxyCodeLine{10614 }
\DoxyCodeLine{10615                 \textcolor{keywordflow}{if}( c != EOF ) \{}
\DoxyCodeLine{10616                     \textcolor{keywordflow}{if}( pbase() == epptr() )}
\DoxyCodeLine{10617                         m\_writer( std::string( 1, static\_cast<char>( c ) ) );}
\DoxyCodeLine{10618                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{10619                         sputc( static\_cast<char>( c ) );}
\DoxyCodeLine{10620                 \}}
\DoxyCodeLine{10621                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{10622             \}}
\DoxyCodeLine{10623 }
\DoxyCodeLine{10624             \textcolor{keywordtype}{int} sync()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10625                 \textcolor{keywordflow}{if}( pbase() != pptr() ) \{}
\DoxyCodeLine{10626                     m\_writer( std::string( pbase(), static\_cast<std::string::size\_type>( pptr() - pbase() ) ) );}
\DoxyCodeLine{10627                     setp( pbase(), epptr() );}
\DoxyCodeLine{10628                 \}}
\DoxyCodeLine{10629                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{10630             \}}
\DoxyCodeLine{10631         \};}
\DoxyCodeLine{10632 }
\DoxyCodeLine{10634 }
\DoxyCodeLine{10635         \textcolor{keyword}{struct }OutputDebugWriter \{}
\DoxyCodeLine{10636 }
\DoxyCodeLine{10637             \textcolor{keywordtype}{void} operator()( std::string \textcolor{keyword}{const}\&str ) \{}
\DoxyCodeLine{10638                 writeToDebugConsole( str );}
\DoxyCodeLine{10639             \}}
\DoxyCodeLine{10640         \};}
\DoxyCodeLine{10641 }
\DoxyCodeLine{10643 }
\DoxyCodeLine{10644         \textcolor{keyword}{class }FileStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{10645             \textcolor{keyword}{mutable} std::ofstream m\_ofs;}
\DoxyCodeLine{10646         \textcolor{keyword}{public}:}
\DoxyCodeLine{10647             FileStream( StringRef filename ) \{}
\DoxyCodeLine{10648                 m\_ofs.open( filename.c\_str() );}
\DoxyCodeLine{10649                 CATCH\_ENFORCE( !m\_ofs.fail(), \textcolor{stringliteral}{"Unable to open file: '"} << filename << \textcolor{stringliteral}{"'"} );}
\DoxyCodeLine{10650             \}}
\DoxyCodeLine{10651             ~FileStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10652         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{10653             std::ostream\& stream()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{10654                 \textcolor{keywordflow}{return} m\_ofs;}
\DoxyCodeLine{10655             \}}
\DoxyCodeLine{10656         \};}
\DoxyCodeLine{10657 }
\DoxyCodeLine{10659 }
\DoxyCodeLine{10660         \textcolor{keyword}{class }CoutStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{10661             \textcolor{keyword}{mutable} std::ostream m\_os;}
\DoxyCodeLine{10662         \textcolor{keyword}{public}:}
\DoxyCodeLine{10663             \textcolor{comment}{// Store the streambuf from cout up-front because}}
\DoxyCodeLine{10664             \textcolor{comment}{// cout may get redirected when running tests}}
\DoxyCodeLine{10665             CoutStream() : m\_os( Catch::cout().rdbuf() ) \{\}}
\DoxyCodeLine{10666             ~CoutStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10667 }
\DoxyCodeLine{10668         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{10669             std::ostream\& stream()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} m\_os; \}}
\DoxyCodeLine{10670         \};}
\DoxyCodeLine{10671 }
\DoxyCodeLine{10673 }
\DoxyCodeLine{10674         \textcolor{keyword}{class }DebugOutStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{10675             std::unique\_ptr<StreamBufImpl<OutputDebugWriter>> m\_streamBuf;}
\DoxyCodeLine{10676             \textcolor{keyword}{mutable} std::ostream m\_os;}
\DoxyCodeLine{10677         \textcolor{keyword}{public}:}
\DoxyCodeLine{10678             DebugOutStream()}
\DoxyCodeLine{10679             :   m\_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),}
\DoxyCodeLine{10680                 m\_os( m\_streamBuf.get() )}
\DoxyCodeLine{10681             \{\}}
\DoxyCodeLine{10682 }
\DoxyCodeLine{10683             ~DebugOutStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10684 }
\DoxyCodeLine{10685         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{10686             std::ostream\& stream()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} m\_os; \}}
\DoxyCodeLine{10687         \};}
\DoxyCodeLine{10688 }
\DoxyCodeLine{10689     \}\} \textcolor{comment}{// namespace anon::detail}}
\DoxyCodeLine{10690 }
\DoxyCodeLine{10692 }
\DoxyCodeLine{10693     \textcolor{keyword}{auto} makeStream( StringRef \textcolor{keyword}{const} \&filename ) -> IStream \textcolor{keyword}{const}* \{}
\DoxyCodeLine{10694         \textcolor{keywordflow}{if}( filename.empty() )}
\DoxyCodeLine{10695             \textcolor{keywordflow}{return} \textcolor{keyword}{new} detail::CoutStream();}
\DoxyCodeLine{10696         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( filename[0] == \textcolor{charliteral}{'\%'} ) \{}
\DoxyCodeLine{10697             \textcolor{keywordflow}{if}( filename == \textcolor{stringliteral}{"\%debug"} )}
\DoxyCodeLine{10698                 \textcolor{keywordflow}{return} \textcolor{keyword}{new} detail::DebugOutStream();}
\DoxyCodeLine{10699             \textcolor{keywordflow}{else}}
\DoxyCodeLine{10700                 CATCH\_ERROR( \textcolor{stringliteral}{"Unrecognised stream: '"} << filename << \textcolor{stringliteral}{"'"} );}
\DoxyCodeLine{10701         \}}
\DoxyCodeLine{10702         \textcolor{keywordflow}{else}}
\DoxyCodeLine{10703             \textcolor{keywordflow}{return} \textcolor{keyword}{new} detail::FileStream( filename );}
\DoxyCodeLine{10704     \}}
\DoxyCodeLine{10705 }
\DoxyCodeLine{10706     \textcolor{comment}{// This class encapsulates the idea of a pool of ostringstreams that can be reused.}}
\DoxyCodeLine{10707     \textcolor{keyword}{struct }StringStreams \{}
\DoxyCodeLine{10708         std::vector<std::unique\_ptr<std::ostringstream>> m\_streams;}
\DoxyCodeLine{10709         std::vector<std::size\_t> m\_unused;}
\DoxyCodeLine{10710         std::ostringstream m\_referenceStream; \textcolor{comment}{// Used for copy state/ flags from}}
\DoxyCodeLine{10711 }
\DoxyCodeLine{10712         \textcolor{keyword}{auto} add() -> std::size\_t \{}
\DoxyCodeLine{10713             \textcolor{keywordflow}{if}( m\_unused.empty() ) \{}
\DoxyCodeLine{10714                 m\_streams.push\_back( std::unique\_ptr<std::ostringstream>( \textcolor{keyword}{new} std::ostringstream ) );}
\DoxyCodeLine{10715                 \textcolor{keywordflow}{return} m\_streams.size()-1;}
\DoxyCodeLine{10716             \}}
\DoxyCodeLine{10717             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{10718                 \textcolor{keyword}{auto} index = m\_unused.back();}
\DoxyCodeLine{10719                 m\_unused.pop\_back();}
\DoxyCodeLine{10720                 \textcolor{keywordflow}{return} index;}
\DoxyCodeLine{10721             \}}
\DoxyCodeLine{10722         \}}
\DoxyCodeLine{10723 }
\DoxyCodeLine{10724         \textcolor{keywordtype}{void} release( std::size\_t index ) \{}
\DoxyCodeLine{10725             m\_streams[index]->copyfmt( m\_referenceStream ); \textcolor{comment}{// Restore initial flags and other state}}
\DoxyCodeLine{10726             m\_unused.push\_back(index);}
\DoxyCodeLine{10727         \}}
\DoxyCodeLine{10728     \};}
\DoxyCodeLine{10729 }
\DoxyCodeLine{10730     ReusableStringStream::ReusableStringStream()}
\DoxyCodeLine{10731     :   m\_index( Singleton<StringStreams>::getMutable().add() ),}
\DoxyCodeLine{10732         m\_oss( Singleton<StringStreams>::getMutable().m\_streams[m\_index].get() )}
\DoxyCodeLine{10733     \{\}}
\DoxyCodeLine{10734 }
\DoxyCodeLine{10735     ReusableStringStream::~ReusableStringStream() \{}
\DoxyCodeLine{10736         static\_cast<std::ostringstream*>( m\_oss )->str(\textcolor{stringliteral}{""});}
\DoxyCodeLine{10737         m\_oss->clear();}
\DoxyCodeLine{10738         Singleton<StringStreams>::getMutable().release( m\_index );}
\DoxyCodeLine{10739     \}}
\DoxyCodeLine{10740 }
\DoxyCodeLine{10741     \textcolor{keyword}{auto} ReusableStringStream::str() const -> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{10742         \textcolor{keywordflow}{return} static\_cast<std::ostringstream*>( m\_oss )->str();}
\DoxyCodeLine{10743     \}}
\DoxyCodeLine{10744 }
\DoxyCodeLine{10746 }
\DoxyCodeLine{10747 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_NOSTDOUT // If you \#define this you must implement these functions}}
\DoxyCodeLine{10748     std::ostream\& cout() \{ \textcolor{keywordflow}{return} std::cout; \}}
\DoxyCodeLine{10749     std::ostream\& cerr() \{ \textcolor{keywordflow}{return} std::cerr; \}}
\DoxyCodeLine{10750     std::ostream\& clog() \{ \textcolor{keywordflow}{return} std::clog; \}}
\DoxyCodeLine{10751 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10752 \}}
\DoxyCodeLine{10753 \textcolor{comment}{// end catch\_stream.cpp}}
\DoxyCodeLine{10754 \textcolor{comment}{// start catch\_string\_manip.cpp}}
\DoxyCodeLine{10755 }
\DoxyCodeLine{10756 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{10757 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{10758 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{10759 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{10760 }
\DoxyCodeLine{10761 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10762 }
\DoxyCodeLine{10763     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10764         \textcolor{keywordtype}{char} toLowerCh(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{10765             \textcolor{keywordflow}{return} static\_cast<char>( std::tolower( c ) );}
\DoxyCodeLine{10766         \}}
\DoxyCodeLine{10767     \}}
\DoxyCodeLine{10768 }
\DoxyCodeLine{10769     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& prefix ) \{}
\DoxyCodeLine{10770         \textcolor{keywordflow}{return} s.size() >= prefix.size() \&\& std::equal(prefix.begin(), prefix.end(), s.begin());}
\DoxyCodeLine{10771     \}}
\DoxyCodeLine{10772     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} prefix ) \{}
\DoxyCodeLine{10773         \textcolor{keywordflow}{return} !s.empty() \&\& s[0] == prefix;}
\DoxyCodeLine{10774     \}}
\DoxyCodeLine{10775     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& suffix ) \{}
\DoxyCodeLine{10776         \textcolor{keywordflow}{return} s.size() >= suffix.size() \&\& std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());}
\DoxyCodeLine{10777     \}}
\DoxyCodeLine{10778     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} suffix ) \{}
\DoxyCodeLine{10779         \textcolor{keywordflow}{return} !s.empty() \&\& s[s.size()-1] == suffix;}
\DoxyCodeLine{10780     \}}
\DoxyCodeLine{10781     \textcolor{keywordtype}{bool} contains( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& infix ) \{}
\DoxyCodeLine{10782         \textcolor{keywordflow}{return} s.find( infix ) != std::string::npos;}
\DoxyCodeLine{10783     \}}
\DoxyCodeLine{10784     \textcolor{keywordtype}{void} toLowerInPlace( std::string\& s ) \{}
\DoxyCodeLine{10785         std::transform( s.begin(), s.end(), s.begin(), toLowerCh );}
\DoxyCodeLine{10786     \}}
\DoxyCodeLine{10787     std::string toLower( std::string \textcolor{keyword}{const}\& s ) \{}
\DoxyCodeLine{10788         std::string lc = s;}
\DoxyCodeLine{10789         toLowerInPlace( lc );}
\DoxyCodeLine{10790         \textcolor{keywordflow}{return} lc;}
\DoxyCodeLine{10791     \}}
\DoxyCodeLine{10792     std::string trim( std::string \textcolor{keyword}{const}\& str ) \{}
\DoxyCodeLine{10793         \textcolor{keyword}{static} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* whitespaceChars = \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)r\(\backslash\)t "};}
\DoxyCodeLine{10794         std::string::size\_type start = str.find\_first\_not\_of( whitespaceChars );}
\DoxyCodeLine{10795         std::string::size\_type end = str.find\_last\_not\_of( whitespaceChars );}
\DoxyCodeLine{10796 }
\DoxyCodeLine{10797         \textcolor{keywordflow}{return} start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();}
\DoxyCodeLine{10798     \}}
\DoxyCodeLine{10799 }
\DoxyCodeLine{10800     \textcolor{keywordtype}{bool} replaceInPlace( std::string\& str, std::string \textcolor{keyword}{const}\& replaceThis, std::string \textcolor{keyword}{const}\& withThis ) \{}
\DoxyCodeLine{10801         \textcolor{keywordtype}{bool} replaced = \textcolor{keyword}{false};}
\DoxyCodeLine{10802         std::size\_t i = str.find( replaceThis );}
\DoxyCodeLine{10803         \textcolor{keywordflow}{while}( i != std::string::npos ) \{}
\DoxyCodeLine{10804             replaced = \textcolor{keyword}{true};}
\DoxyCodeLine{10805             str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );}
\DoxyCodeLine{10806             \textcolor{keywordflow}{if}( i < str.size()-withThis.size() )}
\DoxyCodeLine{10807                 i = str.find( replaceThis, i+withThis.size() );}
\DoxyCodeLine{10808             \textcolor{keywordflow}{else}}
\DoxyCodeLine{10809                 i = std::string::npos;}
\DoxyCodeLine{10810         \}}
\DoxyCodeLine{10811         \textcolor{keywordflow}{return} replaced;}
\DoxyCodeLine{10812     \}}
\DoxyCodeLine{10813 }
\DoxyCodeLine{10814     pluralise::pluralise( std::size\_t count, std::string \textcolor{keyword}{const}\& label )}
\DoxyCodeLine{10815     :   m\_count( count ),}
\DoxyCodeLine{10816         m\_label( label )}
\DoxyCodeLine{10817     \{\}}
\DoxyCodeLine{10818 }
\DoxyCodeLine{10819     std::ostream\& operator << ( std::ostream\& os, pluralise \textcolor{keyword}{const}\& pluraliser ) \{}
\DoxyCodeLine{10820         os << pluraliser.m\_count << \textcolor{charliteral}{' '} << pluraliser.m\_label;}
\DoxyCodeLine{10821         \textcolor{keywordflow}{if}( pluraliser.m\_count != 1 )}
\DoxyCodeLine{10822             os << \textcolor{charliteral}{'s'};}
\DoxyCodeLine{10823         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{10824     \}}
\DoxyCodeLine{10825 }
\DoxyCodeLine{10826 \}}
\DoxyCodeLine{10827 \textcolor{comment}{// end catch\_string\_manip.cpp}}
\DoxyCodeLine{10828 \textcolor{comment}{// start catch\_stringref.cpp}}
\DoxyCodeLine{10829 }
\DoxyCodeLine{10830 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{10831 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{10832 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "-Wexit-time-destructors"}}
\DoxyCodeLine{10833 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10834 }
\DoxyCodeLine{10835 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{10836 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{10837 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{10838 }
\DoxyCodeLine{10839 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10840     \textcolor{keyword}{const} uint32\_t byte\_2\_lead = 0xC0;}
\DoxyCodeLine{10841     \textcolor{keyword}{const} uint32\_t byte\_3\_lead = 0xE0;}
\DoxyCodeLine{10842     \textcolor{keyword}{const} uint32\_t byte\_4\_lead = 0xF0;}
\DoxyCodeLine{10843 \}}
\DoxyCodeLine{10844 }
\DoxyCodeLine{10845 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10846     StringRef::StringRef( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars ) noexcept}
\DoxyCodeLine{10847     : StringRef( rawChars, static\_cast<StringRef::size\_type>(std::strlen(rawChars) ) )}
\DoxyCodeLine{10848     \{\}}
\DoxyCodeLine{10849 }
\DoxyCodeLine{10850     StringRef::operator std::string()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10851         \textcolor{keywordflow}{return} std::string( m\_start, m\_size );}
\DoxyCodeLine{10852     \}}
\DoxyCodeLine{10853 }
\DoxyCodeLine{10854     \textcolor{keywordtype}{void} StringRef::swap( StringRef\& other ) noexcept \{}
\DoxyCodeLine{10855         std::swap( m\_start, other.m\_start );}
\DoxyCodeLine{10856         std::swap( m\_size, other.m\_size );}
\DoxyCodeLine{10857         std::swap( m\_data, other.m\_data );}
\DoxyCodeLine{10858     \}}
\DoxyCodeLine{10859 }
\DoxyCodeLine{10860     \textcolor{keyword}{auto} StringRef::c\_str() const -> \textcolor{keywordtype}{char} const* \{}
\DoxyCodeLine{10861         \textcolor{keywordflow}{if}( isSubstring() )}
\DoxyCodeLine{10862            const\_cast<StringRef*>( \textcolor{keyword}{this} )->takeOwnership();}
\DoxyCodeLine{10863         \textcolor{keywordflow}{return} m\_start;}
\DoxyCodeLine{10864     \}}
\DoxyCodeLine{10865     \textcolor{keyword}{auto} StringRef::currentData() const noexcept -> \textcolor{keywordtype}{char} const* \{}
\DoxyCodeLine{10866         \textcolor{keywordflow}{return} m\_start;}
\DoxyCodeLine{10867     \}}
\DoxyCodeLine{10868 }
\DoxyCodeLine{10869     \textcolor{keyword}{auto} StringRef::isOwned() const noexcept -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{10870         \textcolor{keywordflow}{return} m\_data != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10871     \}}
\DoxyCodeLine{10872     \textcolor{keyword}{auto} StringRef::isSubstring() const noexcept -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{10873         \textcolor{keywordflow}{return} m\_start[m\_size] != \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{10874     \}}
\DoxyCodeLine{10875 }
\DoxyCodeLine{10876     \textcolor{keywordtype}{void} StringRef::takeOwnership() \{}
\DoxyCodeLine{10877         \textcolor{keywordflow}{if}( !isOwned() ) \{}
\DoxyCodeLine{10878             m\_data = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[m\_size+1];}
\DoxyCodeLine{10879             memcpy( m\_data, m\_start, m\_size );}
\DoxyCodeLine{10880             m\_data[m\_size] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{10881             m\_start = m\_data;}
\DoxyCodeLine{10882         \}}
\DoxyCodeLine{10883     \}}
\DoxyCodeLine{10884     \textcolor{keyword}{auto} StringRef::substr( size\_type start, size\_type size ) \textcolor{keyword}{const} noexcept -> StringRef \{}
\DoxyCodeLine{10885         \textcolor{keywordflow}{if}( start < m\_size )}
\DoxyCodeLine{10886             \textcolor{keywordflow}{return} StringRef( m\_start+start, size );}
\DoxyCodeLine{10887         \textcolor{keywordflow}{else}}
\DoxyCodeLine{10888             \textcolor{keywordflow}{return} StringRef();}
\DoxyCodeLine{10889     \}}
\DoxyCodeLine{10890     \textcolor{keyword}{auto} StringRef::operator == ( StringRef \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} noexcept -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{10891         \textcolor{keywordflow}{return}}
\DoxyCodeLine{10892             size() == other.size() \&\&}
\DoxyCodeLine{10893             (std::strncmp( m\_start, other.m\_start, size() ) == 0);}
\DoxyCodeLine{10894     \}}
\DoxyCodeLine{10895     \textcolor{keyword}{auto} StringRef::operator != ( StringRef \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} noexcept -> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{10896         \textcolor{keywordflow}{return} !operator==( other );}
\DoxyCodeLine{10897     \}}
\DoxyCodeLine{10898 }
\DoxyCodeLine{10899     \textcolor{keyword}{auto} StringRef::operator[](size\_type index) \textcolor{keyword}{const} noexcept -> \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{10900         \textcolor{keywordflow}{return} m\_start[index];}
\DoxyCodeLine{10901     \}}
\DoxyCodeLine{10902 }
\DoxyCodeLine{10903     \textcolor{keyword}{auto} StringRef::numberOfCharacters() const noexcept -> size\_type \{}
\DoxyCodeLine{10904         size\_type noChars = m\_size;}
\DoxyCodeLine{10905         \textcolor{comment}{// Make adjustments for uft encodings}}
\DoxyCodeLine{10906         \textcolor{keywordflow}{for}( size\_type i=0; i < m\_size; ++i ) \{}
\DoxyCodeLine{10907             \textcolor{keywordtype}{char} c = m\_start[i];}
\DoxyCodeLine{10908             \textcolor{keywordflow}{if}( ( c \& byte\_2\_lead ) == byte\_2\_lead ) \{}
\DoxyCodeLine{10909                 noChars--;}
\DoxyCodeLine{10910                 \textcolor{keywordflow}{if} (( c \& byte\_3\_lead ) == byte\_3\_lead )}
\DoxyCodeLine{10911                     noChars--;}
\DoxyCodeLine{10912                 \textcolor{keywordflow}{if}( ( c \& byte\_4\_lead ) == byte\_4\_lead )}
\DoxyCodeLine{10913                     noChars--;}
\DoxyCodeLine{10914             \}}
\DoxyCodeLine{10915         \}}
\DoxyCodeLine{10916         \textcolor{keywordflow}{return} noChars;}
\DoxyCodeLine{10917     \}}
\DoxyCodeLine{10918 }
\DoxyCodeLine{10919     \textcolor{keyword}{auto} operator + ( StringRef \textcolor{keyword}{const}\& lhs, StringRef \textcolor{keyword}{const}\& rhs ) -> std::string \{}
\DoxyCodeLine{10920         std::string str;}
\DoxyCodeLine{10921         str.reserve( lhs.size() + rhs.size() );}
\DoxyCodeLine{10922         str += lhs;}
\DoxyCodeLine{10923         str += rhs;}
\DoxyCodeLine{10924         \textcolor{keywordflow}{return} str;}
\DoxyCodeLine{10925     \}}
\DoxyCodeLine{10926     \textcolor{keyword}{auto} operator + ( StringRef \textcolor{keyword}{const}\& lhs, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* rhs ) -> std::string \{}
\DoxyCodeLine{10927         \textcolor{keywordflow}{return} std::string( lhs ) + std::string( rhs );}
\DoxyCodeLine{10928     \}}
\DoxyCodeLine{10929     \textcolor{keyword}{auto} operator + ( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* lhs, StringRef \textcolor{keyword}{const}\& rhs ) -> std::string \{}
\DoxyCodeLine{10930         \textcolor{keywordflow}{return} std::string( lhs ) + std::string( rhs );}
\DoxyCodeLine{10931     \}}
\DoxyCodeLine{10932 }
\DoxyCodeLine{10933     \textcolor{keyword}{auto} operator << ( std::ostream\& os, StringRef \textcolor{keyword}{const}\& str ) -> std::ostream\& \{}
\DoxyCodeLine{10934         \textcolor{keywordflow}{return} os.write(str.currentData(), str.size());}
\DoxyCodeLine{10935     \}}
\DoxyCodeLine{10936 }
\DoxyCodeLine{10937     \textcolor{keyword}{auto} operator+=( std::string\& lhs, StringRef \textcolor{keyword}{const}\& rhs ) -> std::string\& \{}
\DoxyCodeLine{10938         lhs.append(rhs.currentData(), rhs.size());}
\DoxyCodeLine{10939         \textcolor{keywordflow}{return} lhs;}
\DoxyCodeLine{10940     \}}
\DoxyCodeLine{10941 }
\DoxyCodeLine{10942 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10943 }
\DoxyCodeLine{10944 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{10945 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{10946 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10947 \textcolor{comment}{// end catch\_stringref.cpp}}
\DoxyCodeLine{10948 \textcolor{comment}{// start catch\_tag\_alias.cpp}}
\DoxyCodeLine{10949 }
\DoxyCodeLine{10950 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10951     TagAlias::TagAlias(std::string \textcolor{keyword}{const} \& \_tag, SourceLineInfo \_lineInfo): tag(\_tag), lineInfo(\_lineInfo) \{\}}
\DoxyCodeLine{10952 \}}
\DoxyCodeLine{10953 \textcolor{comment}{// end catch\_tag\_alias.cpp}}
\DoxyCodeLine{10954 \textcolor{comment}{// start catch\_tag\_alias\_autoregistrar.cpp}}
\DoxyCodeLine{10955 }
\DoxyCodeLine{10956 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10957 }
\DoxyCodeLine{10958     RegistrarForTagAliases::RegistrarForTagAliases(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* alias, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo) \{}
\DoxyCodeLine{10959         CATCH\_TRY \{}
\DoxyCodeLine{10960             getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);}
\DoxyCodeLine{10961         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{10962             \textcolor{comment}{// Do not throw when constructing global objects, instead register the exception to be processed later}}
\DoxyCodeLine{10963             getMutableRegistryHub().registerStartupException();}
\DoxyCodeLine{10964         \}}
\DoxyCodeLine{10965     \}}
\DoxyCodeLine{10966 }
\DoxyCodeLine{10967 \}}
\DoxyCodeLine{10968 \textcolor{comment}{// end catch\_tag\_alias\_autoregistrar.cpp}}
\DoxyCodeLine{10969 \textcolor{comment}{// start catch\_tag\_alias\_registry.cpp}}
\DoxyCodeLine{10970 }
\DoxyCodeLine{10971 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{10972 }
\DoxyCodeLine{10973 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10974 }
\DoxyCodeLine{10975     TagAliasRegistry::~TagAliasRegistry() \{\}}
\DoxyCodeLine{10976 }
\DoxyCodeLine{10977     TagAlias \textcolor{keyword}{const}* TagAliasRegistry::find( std::string \textcolor{keyword}{const}\& alias )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10978         \textcolor{keyword}{auto} it = m\_registry.find( alias );}
\DoxyCodeLine{10979         \textcolor{keywordflow}{if}( it != m\_registry.end() )}
\DoxyCodeLine{10980             \textcolor{keywordflow}{return} \&(it->second);}
\DoxyCodeLine{10981         \textcolor{keywordflow}{else}}
\DoxyCodeLine{10982             \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10983     \}}
\DoxyCodeLine{10984 }
\DoxyCodeLine{10985     std::string TagAliasRegistry::expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10986         std::string expandedTestSpec = unexpandedTestSpec;}
\DoxyCodeLine{10987         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& registryKvp : m\_registry ) \{}
\DoxyCodeLine{10988             std::size\_t pos = expandedTestSpec.find( registryKvp.first );}
\DoxyCodeLine{10989             \textcolor{keywordflow}{if}( pos != std::string::npos ) \{}
\DoxyCodeLine{10990                 expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +}
\DoxyCodeLine{10991                                     registryKvp.second.tag +}
\DoxyCodeLine{10992                                     expandedTestSpec.substr( pos + registryKvp.first.size() );}
\DoxyCodeLine{10993             \}}
\DoxyCodeLine{10994         \}}
\DoxyCodeLine{10995         \textcolor{keywordflow}{return} expandedTestSpec;}
\DoxyCodeLine{10996     \}}
\DoxyCodeLine{10997 }
\DoxyCodeLine{10998     \textcolor{keywordtype}{void} TagAliasRegistry::add( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) \{}
\DoxyCodeLine{10999         CATCH\_ENFORCE( startsWith(alias, \textcolor{stringliteral}{"[@"}) \&\& endsWith(alias, \textcolor{charliteral}{']'}),}
\DoxyCodeLine{11000                       \textcolor{stringliteral}{"error: tag alias, '"} << alias << \textcolor{stringliteral}{"' is not of the form [@alias name].\(\backslash\)n"} << lineInfo );}
\DoxyCodeLine{11001 }
\DoxyCodeLine{11002         CATCH\_ENFORCE( m\_registry.insert(std::make\_pair(alias, TagAlias(tag, lineInfo))).second,}
\DoxyCodeLine{11003                       \textcolor{stringliteral}{"error: tag alias, '"} << alias << \textcolor{stringliteral}{"' already registered.\(\backslash\)n"}}
\DoxyCodeLine{11004                       << \textcolor{stringliteral}{"\(\backslash\)tFirst seen at: "} << find(alias)->lineInfo << \textcolor{stringliteral}{"\(\backslash\)n"}}
\DoxyCodeLine{11005                       << \textcolor{stringliteral}{"\(\backslash\)tRedefined at: "} << lineInfo );}
\DoxyCodeLine{11006     \}}
\DoxyCodeLine{11007 }
\DoxyCodeLine{11008     ITagAliasRegistry::~ITagAliasRegistry() \{\}}
\DoxyCodeLine{11009 }
\DoxyCodeLine{11010     ITagAliasRegistry \textcolor{keyword}{const}\& ITagAliasRegistry::get() \{}
\DoxyCodeLine{11011         \textcolor{keywordflow}{return} getRegistryHub().getTagAliasRegistry();}
\DoxyCodeLine{11012     \}}
\DoxyCodeLine{11013 }
\DoxyCodeLine{11014 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11015 \textcolor{comment}{// end catch\_tag\_alias\_registry.cpp}}
\DoxyCodeLine{11016 \textcolor{comment}{// start catch\_test\_case\_info.cpp}}
\DoxyCodeLine{11017 }
\DoxyCodeLine{11018 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{11019 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{11020 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{11021 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{11022 }
\DoxyCodeLine{11023 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11024 }
\DoxyCodeLine{11025     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{11026         TestCaseInfo::SpecialProperties parseSpecialTag( std::string \textcolor{keyword}{const}\& tag ) \{}
\DoxyCodeLine{11027             \textcolor{keywordflow}{if}( startsWith( tag, \textcolor{charliteral}{'.'} ) ||}
\DoxyCodeLine{11028                 tag == \textcolor{stringliteral}{"!hide"} )}
\DoxyCodeLine{11029                 \textcolor{keywordflow}{return} TestCaseInfo::IsHidden;}
\DoxyCodeLine{11030             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"!throws"} )}
\DoxyCodeLine{11031                 \textcolor{keywordflow}{return} TestCaseInfo::Throws;}
\DoxyCodeLine{11032             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"!shouldfail"} )}
\DoxyCodeLine{11033                 \textcolor{keywordflow}{return} TestCaseInfo::ShouldFail;}
\DoxyCodeLine{11034             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"!mayfail"} )}
\DoxyCodeLine{11035                 \textcolor{keywordflow}{return} TestCaseInfo::MayFail;}
\DoxyCodeLine{11036             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"!nonportable"} )}
\DoxyCodeLine{11037                 \textcolor{keywordflow}{return} TestCaseInfo::NonPortable;}
\DoxyCodeLine{11038             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"!benchmark"} )}
\DoxyCodeLine{11039                 \textcolor{keywordflow}{return} static\_cast<TestCaseInfo::SpecialProperties>( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );}
\DoxyCodeLine{11040             \textcolor{keywordflow}{else}}
\DoxyCodeLine{11041                 \textcolor{keywordflow}{return} TestCaseInfo::None;}
\DoxyCodeLine{11042         \}}
\DoxyCodeLine{11043         \textcolor{keywordtype}{bool} isReservedTag( std::string \textcolor{keyword}{const}\& tag ) \{}
\DoxyCodeLine{11044             \textcolor{keywordflow}{return} parseSpecialTag( tag ) == TestCaseInfo::None \&\& tag.size() > 0 \&\& !std::isalnum( static\_cast<unsigned char>(tag[0]) );}
\DoxyCodeLine{11045         \}}
\DoxyCodeLine{11046         \textcolor{keywordtype}{void} enforceNotReservedTag( std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo ) \{}
\DoxyCodeLine{11047             CATCH\_ENFORCE( !isReservedTag(tag),}
\DoxyCodeLine{11048                           \textcolor{stringliteral}{"Tag name: ["} << tag << \textcolor{stringliteral}{"] is not allowed.\(\backslash\)n"}}
\DoxyCodeLine{11049                           << \textcolor{stringliteral}{"Tag names starting with non alpha-numeric characters are reserved\(\backslash\)n"}}
\DoxyCodeLine{11050                           << \_lineInfo );}
\DoxyCodeLine{11051         \}}
\DoxyCodeLine{11052     \}}
\DoxyCodeLine{11053 }
\DoxyCodeLine{11054     TestCase makeTestCase(  ITestInvoker* \_testCase,}
\DoxyCodeLine{11055                             std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{11056                             NameAndTags \textcolor{keyword}{const}\& nameAndTags,}
\DoxyCodeLine{11057                             SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo )}
\DoxyCodeLine{11058     \{}
\DoxyCodeLine{11059         \textcolor{keywordtype}{bool} isHidden = \textcolor{keyword}{false};}
\DoxyCodeLine{11060 }
\DoxyCodeLine{11061         \textcolor{comment}{// Parse out tags}}
\DoxyCodeLine{11062         std::vector<std::string> tags;}
\DoxyCodeLine{11063         std::string desc, tag;}
\DoxyCodeLine{11064         \textcolor{keywordtype}{bool} inTag = \textcolor{keyword}{false};}
\DoxyCodeLine{11065         std::string \_descOrTags = nameAndTags.tags;}
\DoxyCodeLine{11066         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} c : \_descOrTags) \{}
\DoxyCodeLine{11067             \textcolor{keywordflow}{if}( !inTag ) \{}
\DoxyCodeLine{11068                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'['} )}
\DoxyCodeLine{11069                     inTag = \textcolor{keyword}{true};}
\DoxyCodeLine{11070                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{11071                     desc += c;}
\DoxyCodeLine{11072             \}}
\DoxyCodeLine{11073             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11074                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{']'} ) \{}
\DoxyCodeLine{11075                     TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );}
\DoxyCodeLine{11076                     \textcolor{keywordflow}{if}( ( prop \& TestCaseInfo::IsHidden ) != 0 )}
\DoxyCodeLine{11077                         isHidden = \textcolor{keyword}{true};}
\DoxyCodeLine{11078                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( prop == TestCaseInfo::None )}
\DoxyCodeLine{11079                         enforceNotReservedTag( tag, \_lineInfo );}
\DoxyCodeLine{11080 }
\DoxyCodeLine{11081                     tags.push\_back( tag );}
\DoxyCodeLine{11082                     tag.clear();}
\DoxyCodeLine{11083                     inTag = \textcolor{keyword}{false};}
\DoxyCodeLine{11084                 \}}
\DoxyCodeLine{11085                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{11086                     tag += c;}
\DoxyCodeLine{11087             \}}
\DoxyCodeLine{11088         \}}
\DoxyCodeLine{11089         \textcolor{keywordflow}{if}( isHidden ) \{}
\DoxyCodeLine{11090             tags.push\_back( \textcolor{stringliteral}{"."} );}
\DoxyCodeLine{11091         \}}
\DoxyCodeLine{11092 }
\DoxyCodeLine{11093         TestCaseInfo info( nameAndTags.name, \_className, desc, tags, \_lineInfo );}
\DoxyCodeLine{11094         \textcolor{keywordflow}{return} TestCase( \_testCase, std::move(info) );}
\DoxyCodeLine{11095     \}}
\DoxyCodeLine{11096 }
\DoxyCodeLine{11097     \textcolor{keywordtype}{void} setTags( TestCaseInfo\& testCaseInfo, std::vector<std::string> tags ) \{}
\DoxyCodeLine{11098         std::sort(begin(tags), end(tags));}
\DoxyCodeLine{11099         tags.erase(std::unique(begin(tags), end(tags)), end(tags));}
\DoxyCodeLine{11100         testCaseInfo.lcaseTags.clear();}
\DoxyCodeLine{11101 }
\DoxyCodeLine{11102         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tag : tags ) \{}
\DoxyCodeLine{11103             std::string lcaseTag = toLower( tag );}
\DoxyCodeLine{11104             testCaseInfo.properties = static\_cast<TestCaseInfo::SpecialProperties>( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );}
\DoxyCodeLine{11105             testCaseInfo.lcaseTags.push\_back( lcaseTag );}
\DoxyCodeLine{11106         \}}
\DoxyCodeLine{11107         testCaseInfo.tags = std::move(tags);}
\DoxyCodeLine{11108     \}}
\DoxyCodeLine{11109 }
\DoxyCodeLine{11110     TestCaseInfo::TestCaseInfo( std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{11111                                 std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{11112                                 std::string \textcolor{keyword}{const}\& \_description,}
\DoxyCodeLine{11113                                 std::vector<std::string> \textcolor{keyword}{const}\& \_tags,}
\DoxyCodeLine{11114                                 SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo )}
\DoxyCodeLine{11115     :   name( \_name ),}
\DoxyCodeLine{11116         className( \_className ),}
\DoxyCodeLine{11117         description( \_description ),}
\DoxyCodeLine{11118         lineInfo( \_lineInfo ),}
\DoxyCodeLine{11119         properties( None )}
\DoxyCodeLine{11120     \{}
\DoxyCodeLine{11121         setTags( *\textcolor{keyword}{this}, \_tags );}
\DoxyCodeLine{11122     \}}
\DoxyCodeLine{11123 }
\DoxyCodeLine{11124     \textcolor{keywordtype}{bool} TestCaseInfo::isHidden()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11125         \textcolor{keywordflow}{return} ( properties \& IsHidden ) != 0;}
\DoxyCodeLine{11126     \}}
\DoxyCodeLine{11127     \textcolor{keywordtype}{bool} TestCaseInfo::throws()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11128         \textcolor{keywordflow}{return} ( properties \& Throws ) != 0;}
\DoxyCodeLine{11129     \}}
\DoxyCodeLine{11130     \textcolor{keywordtype}{bool} TestCaseInfo::okToFail()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11131         \textcolor{keywordflow}{return} ( properties \& (ShouldFail | MayFail ) ) != 0;}
\DoxyCodeLine{11132     \}}
\DoxyCodeLine{11133     \textcolor{keywordtype}{bool} TestCaseInfo::expectedToFail()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11134         \textcolor{keywordflow}{return} ( properties \& (ShouldFail ) ) != 0;}
\DoxyCodeLine{11135     \}}
\DoxyCodeLine{11136 }
\DoxyCodeLine{11137     std::string TestCaseInfo::tagsAsString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11138         std::string ret;}
\DoxyCodeLine{11139         \textcolor{comment}{// '[' and ']' per tag}}
\DoxyCodeLine{11140         std::size\_t full\_size = 2 * tags.size();}
\DoxyCodeLine{11141         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& tag : tags) \{}
\DoxyCodeLine{11142             full\_size += tag.size();}
\DoxyCodeLine{11143         \}}
\DoxyCodeLine{11144         ret.reserve(full\_size);}
\DoxyCodeLine{11145         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& tag : tags) \{}
\DoxyCodeLine{11146             ret.push\_back(\textcolor{charliteral}{'['});}
\DoxyCodeLine{11147             ret.append(tag);}
\DoxyCodeLine{11148             ret.push\_back(\textcolor{charliteral}{']'});}
\DoxyCodeLine{11149         \}}
\DoxyCodeLine{11150 }
\DoxyCodeLine{11151         \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{11152     \}}
\DoxyCodeLine{11153 }
\DoxyCodeLine{11154     TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo\&\& info ) : TestCaseInfo( std::move(info) ), test( testCase ) \{\}}
\DoxyCodeLine{11155 }
\DoxyCodeLine{11156     TestCase TestCase::withName( std::string \textcolor{keyword}{const}\& \_newName )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11157         TestCase other( *\textcolor{keyword}{this} );}
\DoxyCodeLine{11158         other.name = \_newName;}
\DoxyCodeLine{11159         \textcolor{keywordflow}{return} other;}
\DoxyCodeLine{11160     \}}
\DoxyCodeLine{11161 }
\DoxyCodeLine{11162     \textcolor{keywordtype}{void} TestCase::invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11163         test->invoke();}
\DoxyCodeLine{11164     \}}
\DoxyCodeLine{11165 }
\DoxyCodeLine{11166     \textcolor{keywordtype}{bool} TestCase::operator == ( TestCase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11167         \textcolor{keywordflow}{return}  test.get() == other.test.get() \&\&}
\DoxyCodeLine{11168                 name == other.name \&\&}
\DoxyCodeLine{11169                 className == other.className;}
\DoxyCodeLine{11170     \}}
\DoxyCodeLine{11171 }
\DoxyCodeLine{11172     \textcolor{keywordtype}{bool} TestCase::operator < ( TestCase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11173         \textcolor{keywordflow}{return} name < other.name;}
\DoxyCodeLine{11174     \}}
\DoxyCodeLine{11175 }
\DoxyCodeLine{11176     TestCaseInfo \textcolor{keyword}{const}\& TestCase::getTestCaseInfo()\textcolor{keyword}{ const}}
\DoxyCodeLine{11177 \textcolor{keyword}{    }\{}
\DoxyCodeLine{11178         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{11179     \}}
\DoxyCodeLine{11180 }
\DoxyCodeLine{11181 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11182 \textcolor{comment}{// end catch\_test\_case\_info.cpp}}
\DoxyCodeLine{11183 \textcolor{comment}{// start catch\_test\_case\_registry\_impl.cpp}}
\DoxyCodeLine{11184 }
\DoxyCodeLine{11185 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{11186 }
\DoxyCodeLine{11187 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11188 }
\DoxyCodeLine{11189     std::vector<TestCase> sortTests( IConfig \textcolor{keyword}{const}\& config, std::vector<TestCase> \textcolor{keyword}{const}\& unsortedTestCases ) \{}
\DoxyCodeLine{11190 }
\DoxyCodeLine{11191         std::vector<TestCase> sorted = unsortedTestCases;}
\DoxyCodeLine{11192 }
\DoxyCodeLine{11193         \textcolor{keywordflow}{switch}( config.runOrder() ) \{}
\DoxyCodeLine{11194             \textcolor{keywordflow}{case} RunTests::InLexicographicalOrder:}
\DoxyCodeLine{11195                 std::sort( sorted.begin(), sorted.end() );}
\DoxyCodeLine{11196                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11197             \textcolor{keywordflow}{case} RunTests::InRandomOrder:}
\DoxyCodeLine{11198                 seedRng( config );}
\DoxyCodeLine{11199                 std::shuffle( sorted.begin(), sorted.end(), rng() );}
\DoxyCodeLine{11200                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11201             \textcolor{keywordflow}{case} RunTests::InDeclarationOrder:}
\DoxyCodeLine{11202                 \textcolor{comment}{// already in declaration order}}
\DoxyCodeLine{11203                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11204         \}}
\DoxyCodeLine{11205         \textcolor{keywordflow}{return} sorted;}
\DoxyCodeLine{11206     \}}
\DoxyCodeLine{11207     \textcolor{keywordtype}{bool} matchTest( TestCase \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11208         \textcolor{keywordflow}{return} testSpec.matches( testCase ) \&\& ( config.allowThrows() || !testCase.throws() );}
\DoxyCodeLine{11209     \}}
\DoxyCodeLine{11210 }
\DoxyCodeLine{11211     \textcolor{keywordtype}{void} enforceNoDuplicateTestCases( std::vector<TestCase> \textcolor{keyword}{const}\& functions ) \{}
\DoxyCodeLine{11212         std::set<TestCase> seenFunctions;}
\DoxyCodeLine{11213         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& \textcolor{keyword}{function} : functions ) \{}
\DoxyCodeLine{11214             \textcolor{keyword}{auto} prev = seenFunctions.insert( \textcolor{keyword}{function} );}
\DoxyCodeLine{11215             CATCH\_ENFORCE( prev.second,}
\DoxyCodeLine{11216                     \textcolor{stringliteral}{"error: TEST\_CASE( \(\backslash\)""} << \textcolor{keyword}{function}.name << \textcolor{stringliteral}{"\(\backslash\)" ) already defined.\(\backslash\)n"}}
\DoxyCodeLine{11217                     << \textcolor{stringliteral}{"\(\backslash\)tFirst seen at "} << prev.first->getTestCaseInfo().lineInfo << \textcolor{stringliteral}{"\(\backslash\)n"}}
\DoxyCodeLine{11218                     << \textcolor{stringliteral}{"\(\backslash\)tRedefined at "} << \textcolor{keyword}{function}.getTestCaseInfo().lineInfo );}
\DoxyCodeLine{11219         \}}
\DoxyCodeLine{11220     \}}
\DoxyCodeLine{11221 }
\DoxyCodeLine{11222     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11223         std::vector<TestCase> filtered;}
\DoxyCodeLine{11224         filtered.reserve( testCases.size() );}
\DoxyCodeLine{11225         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : testCases )}
\DoxyCodeLine{11226             \textcolor{keywordflow}{if}( matchTest( testCase, testSpec, config ) )}
\DoxyCodeLine{11227                 filtered.push\_back( testCase );}
\DoxyCodeLine{11228         \textcolor{keywordflow}{return} filtered;}
\DoxyCodeLine{11229     \}}
\DoxyCodeLine{11230     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11231         \textcolor{keywordflow}{return} getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );}
\DoxyCodeLine{11232     \}}
\DoxyCodeLine{11233 }
\DoxyCodeLine{11234     \textcolor{keywordtype}{void} TestRegistry::registerTest( TestCase \textcolor{keyword}{const}\& testCase ) \{}
\DoxyCodeLine{11235         std::string name = testCase.getTestCaseInfo().name;}
\DoxyCodeLine{11236         \textcolor{keywordflow}{if}( name.empty() ) \{}
\DoxyCodeLine{11237             ReusableStringStream rss;}
\DoxyCodeLine{11238             rss << \textcolor{stringliteral}{"Anonymous test case "} << ++m\_unnamedCount;}
\DoxyCodeLine{11239             \textcolor{keywordflow}{return} registerTest( testCase.withName( rss.str() ) );}
\DoxyCodeLine{11240         \}}
\DoxyCodeLine{11241         m\_functions.push\_back( testCase );}
\DoxyCodeLine{11242     \}}
\DoxyCodeLine{11243 }
\DoxyCodeLine{11244     std::vector<TestCase> \textcolor{keyword}{const}\& TestRegistry::getAllTests()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11245         \textcolor{keywordflow}{return} m\_functions;}
\DoxyCodeLine{11246     \}}
\DoxyCodeLine{11247     std::vector<TestCase> \textcolor{keyword}{const}\& TestRegistry::getAllTestsSorted( IConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11248         \textcolor{keywordflow}{if}( m\_sortedFunctions.empty() )}
\DoxyCodeLine{11249             enforceNoDuplicateTestCases( m\_functions );}
\DoxyCodeLine{11250 }
\DoxyCodeLine{11251         \textcolor{keywordflow}{if}(  m\_currentSortOrder != config.runOrder() || m\_sortedFunctions.empty() ) \{}
\DoxyCodeLine{11252             m\_sortedFunctions = sortTests( config, m\_functions );}
\DoxyCodeLine{11253             m\_currentSortOrder = config.runOrder();}
\DoxyCodeLine{11254         \}}
\DoxyCodeLine{11255         \textcolor{keywordflow}{return} m\_sortedFunctions;}
\DoxyCodeLine{11256     \}}
\DoxyCodeLine{11257 }
\DoxyCodeLine{11259     TestInvokerAsFunction::TestInvokerAsFunction( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept : m\_testAsFunction( testAsFunction ) \{\}}
\DoxyCodeLine{11260 }
\DoxyCodeLine{11261     \textcolor{keywordtype}{void} TestInvokerAsFunction::invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11262         m\_testAsFunction();}
\DoxyCodeLine{11263     \}}
\DoxyCodeLine{11264 }
\DoxyCodeLine{11265     std::string extractClassName( StringRef \textcolor{keyword}{const}\& classOrQualifiedMethodName ) \{}
\DoxyCodeLine{11266         std::string className = classOrQualifiedMethodName;}
\DoxyCodeLine{11267         \textcolor{keywordflow}{if}( startsWith( className, \textcolor{charliteral}{'\&'} ) )}
\DoxyCodeLine{11268         \{}
\DoxyCodeLine{11269             std::size\_t lastColons = className.rfind( \textcolor{stringliteral}{"::"} );}
\DoxyCodeLine{11270             std::size\_t penultimateColons = className.rfind( \textcolor{stringliteral}{"::"}, lastColons-1 );}
\DoxyCodeLine{11271             \textcolor{keywordflow}{if}( penultimateColons == std::string::npos )}
\DoxyCodeLine{11272                 penultimateColons = 1;}
\DoxyCodeLine{11273             className = className.substr( penultimateColons, lastColons-penultimateColons );}
\DoxyCodeLine{11274         \}}
\DoxyCodeLine{11275         \textcolor{keywordflow}{return} className;}
\DoxyCodeLine{11276     \}}
\DoxyCodeLine{11277 }
\DoxyCodeLine{11278 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11279 \textcolor{comment}{// end catch\_test\_case\_registry\_impl.cpp}}
\DoxyCodeLine{11280 \textcolor{comment}{// start catch\_test\_case\_tracker.cpp}}
\DoxyCodeLine{11281 }
\DoxyCodeLine{11282 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{11283 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{11284 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{11285 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{11286 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{11287 }
\DoxyCodeLine{11288 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{11289 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{11290 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "-Wexit-time-destructors"}}
\DoxyCodeLine{11291 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11292 }
\DoxyCodeLine{11293 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11294 \textcolor{keyword}{namespace }TestCaseTracking \{}
\DoxyCodeLine{11295 }
\DoxyCodeLine{11296     NameAndLocation::NameAndLocation( std::string \textcolor{keyword}{const}\& \_name, SourceLineInfo \textcolor{keyword}{const}\& \_location )}
\DoxyCodeLine{11297     :   name( \_name ),}
\DoxyCodeLine{11298         location( \_location )}
\DoxyCodeLine{11299     \{\}}
\DoxyCodeLine{11300 }
\DoxyCodeLine{11301     ITracker::~ITracker() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11302 }
\DoxyCodeLine{11303     TrackerContext\& TrackerContext::instance() \{}
\DoxyCodeLine{11304         \textcolor{keyword}{static} TrackerContext s\_instance;}
\DoxyCodeLine{11305         \textcolor{keywordflow}{return} s\_instance;}
\DoxyCodeLine{11306     \}}
\DoxyCodeLine{11307 }
\DoxyCodeLine{11308     ITracker\& TrackerContext::startRun() \{}
\DoxyCodeLine{11309         m\_rootTracker = std::make\_shared<SectionTracker>( NameAndLocation( \textcolor{stringliteral}{"\{root\}"}, CATCH\_INTERNAL\_LINEINFO ), *\textcolor{keyword}{this}, \textcolor{keyword}{nullptr} );}
\DoxyCodeLine{11310         m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{11311         m\_runState = Executing;}
\DoxyCodeLine{11312         \textcolor{keywordflow}{return} *m\_rootTracker;}
\DoxyCodeLine{11313     \}}
\DoxyCodeLine{11314 }
\DoxyCodeLine{11315     \textcolor{keywordtype}{void} TrackerContext::endRun() \{}
\DoxyCodeLine{11316         m\_rootTracker.reset();}
\DoxyCodeLine{11317         m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{11318         m\_runState = NotStarted;}
\DoxyCodeLine{11319     \}}
\DoxyCodeLine{11320 }
\DoxyCodeLine{11321     \textcolor{keywordtype}{void} TrackerContext::startCycle() \{}
\DoxyCodeLine{11322         m\_currentTracker = m\_rootTracker.get();}
\DoxyCodeLine{11323         m\_runState = Executing;}
\DoxyCodeLine{11324     \}}
\DoxyCodeLine{11325     \textcolor{keywordtype}{void} TrackerContext::completeCycle() \{}
\DoxyCodeLine{11326         m\_runState = CompletedCycle;}
\DoxyCodeLine{11327     \}}
\DoxyCodeLine{11328 }
\DoxyCodeLine{11329     \textcolor{keywordtype}{bool} TrackerContext::completedCycle()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11330         \textcolor{keywordflow}{return} m\_runState == CompletedCycle;}
\DoxyCodeLine{11331     \}}
\DoxyCodeLine{11332     ITracker\& TrackerContext::currentTracker() \{}
\DoxyCodeLine{11333         \textcolor{keywordflow}{return} *m\_currentTracker;}
\DoxyCodeLine{11334     \}}
\DoxyCodeLine{11335     \textcolor{keywordtype}{void} TrackerContext::setCurrentTracker( ITracker* tracker ) \{}
\DoxyCodeLine{11336         m\_currentTracker = tracker;}
\DoxyCodeLine{11337     \}}
\DoxyCodeLine{11338 }
\DoxyCodeLine{11339     TrackerBase::TrackerBase( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent )}
\DoxyCodeLine{11340     :   m\_nameAndLocation( nameAndLocation ),}
\DoxyCodeLine{11341         m\_ctx( ctx ),}
\DoxyCodeLine{11342         m\_parent( parent )}
\DoxyCodeLine{11343     \{\}}
\DoxyCodeLine{11344 }
\DoxyCodeLine{11345     NameAndLocation \textcolor{keyword}{const}\& TrackerBase::nameAndLocation()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11346         \textcolor{keywordflow}{return} m\_nameAndLocation;}
\DoxyCodeLine{11347     \}}
\DoxyCodeLine{11348     \textcolor{keywordtype}{bool} TrackerBase::isComplete()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11349         \textcolor{keywordflow}{return} m\_runState == CompletedSuccessfully || m\_runState == Failed;}
\DoxyCodeLine{11350     \}}
\DoxyCodeLine{11351     \textcolor{keywordtype}{bool} TrackerBase::isSuccessfullyCompleted()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11352         \textcolor{keywordflow}{return} m\_runState == CompletedSuccessfully;}
\DoxyCodeLine{11353     \}}
\DoxyCodeLine{11354     \textcolor{keywordtype}{bool} TrackerBase::isOpen()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11355         \textcolor{keywordflow}{return} m\_runState != NotStarted \&\& !isComplete();}
\DoxyCodeLine{11356     \}}
\DoxyCodeLine{11357     \textcolor{keywordtype}{bool} TrackerBase::hasChildren()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11358         \textcolor{keywordflow}{return} !m\_children.empty();}
\DoxyCodeLine{11359     \}}
\DoxyCodeLine{11360 }
\DoxyCodeLine{11361     \textcolor{keywordtype}{void} TrackerBase::addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) \{}
\DoxyCodeLine{11362         m\_children.push\_back( child );}
\DoxyCodeLine{11363     \}}
\DoxyCodeLine{11364 }
\DoxyCodeLine{11365     ITrackerPtr TrackerBase::findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{11366         \textcolor{keyword}{auto} it = std::find\_if( m\_children.begin(), m\_children.end(),}
\DoxyCodeLine{11367             [\&nameAndLocation]( ITrackerPtr \textcolor{keyword}{const}\& tracker )\{}
\DoxyCodeLine{11368                 \textcolor{keywordflow}{return}}
\DoxyCodeLine{11369                     tracker->nameAndLocation().location == nameAndLocation.location \&\&}
\DoxyCodeLine{11370                     tracker->nameAndLocation().name == nameAndLocation.name;}
\DoxyCodeLine{11371             \} );}
\DoxyCodeLine{11372         \textcolor{keywordflow}{return}( it != m\_children.end() )}
\DoxyCodeLine{11373             ? *it}
\DoxyCodeLine{11374             : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{11375     \}}
\DoxyCodeLine{11376     ITracker\& TrackerBase::parent() \{}
\DoxyCodeLine{11377         assert( m\_parent ); \textcolor{comment}{// Should always be non-null except for root}}
\DoxyCodeLine{11378         \textcolor{keywordflow}{return} *m\_parent;}
\DoxyCodeLine{11379     \}}
\DoxyCodeLine{11380 }
\DoxyCodeLine{11381     \textcolor{keywordtype}{void} TrackerBase::openChild() \{}
\DoxyCodeLine{11382         \textcolor{keywordflow}{if}( m\_runState != ExecutingChildren ) \{}
\DoxyCodeLine{11383             m\_runState = ExecutingChildren;}
\DoxyCodeLine{11384             \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{11385                 m\_parent->openChild();}
\DoxyCodeLine{11386         \}}
\DoxyCodeLine{11387     \}}
\DoxyCodeLine{11388 }
\DoxyCodeLine{11389     \textcolor{keywordtype}{bool} TrackerBase::isSectionTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{11390     \textcolor{keywordtype}{bool} TrackerBase::isIndexTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{11391 }
\DoxyCodeLine{11392     \textcolor{keywordtype}{void} TrackerBase::open() \{}
\DoxyCodeLine{11393         m\_runState = Executing;}
\DoxyCodeLine{11394         moveToThis();}
\DoxyCodeLine{11395         \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{11396             m\_parent->openChild();}
\DoxyCodeLine{11397     \}}
\DoxyCodeLine{11398 }
\DoxyCodeLine{11399     \textcolor{keywordtype}{void} TrackerBase::close() \{}
\DoxyCodeLine{11400 }
\DoxyCodeLine{11401         \textcolor{comment}{// Close any still open children (e.g. generators)}}
\DoxyCodeLine{11402         \textcolor{keywordflow}{while}( \&m\_ctx.currentTracker() != this )}
\DoxyCodeLine{11403             m\_ctx.currentTracker().close();}
\DoxyCodeLine{11404 }
\DoxyCodeLine{11405         \textcolor{keywordflow}{switch}( m\_runState ) \{}
\DoxyCodeLine{11406             \textcolor{keywordflow}{case} NeedsAnotherRun:}
\DoxyCodeLine{11407                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11408 }
\DoxyCodeLine{11409             \textcolor{keywordflow}{case} Executing:}
\DoxyCodeLine{11410                 m\_runState = CompletedSuccessfully;}
\DoxyCodeLine{11411                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11412             \textcolor{keywordflow}{case} ExecutingChildren:}
\DoxyCodeLine{11413                 \textcolor{keywordflow}{if}( m\_children.empty() || m\_children.back()->isComplete() )}
\DoxyCodeLine{11414                     m\_runState = CompletedSuccessfully;}
\DoxyCodeLine{11415                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11416 }
\DoxyCodeLine{11417             \textcolor{keywordflow}{case} NotStarted:}
\DoxyCodeLine{11418             \textcolor{keywordflow}{case} CompletedSuccessfully:}
\DoxyCodeLine{11419             \textcolor{keywordflow}{case} Failed:}
\DoxyCodeLine{11420                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"Illogical state: "} << m\_runState );}
\DoxyCodeLine{11421 }
\DoxyCodeLine{11422             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{11423                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"Unknown state: "} << m\_runState );}
\DoxyCodeLine{11424         \}}
\DoxyCodeLine{11425         moveToParent();}
\DoxyCodeLine{11426         m\_ctx.completeCycle();}
\DoxyCodeLine{11427     \}}
\DoxyCodeLine{11428     \textcolor{keywordtype}{void} TrackerBase::fail() \{}
\DoxyCodeLine{11429         m\_runState = Failed;}
\DoxyCodeLine{11430         \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{11431             m\_parent->markAsNeedingAnotherRun();}
\DoxyCodeLine{11432         moveToParent();}
\DoxyCodeLine{11433         m\_ctx.completeCycle();}
\DoxyCodeLine{11434     \}}
\DoxyCodeLine{11435     \textcolor{keywordtype}{void} TrackerBase::markAsNeedingAnotherRun() \{}
\DoxyCodeLine{11436         m\_runState = NeedsAnotherRun;}
\DoxyCodeLine{11437     \}}
\DoxyCodeLine{11438 }
\DoxyCodeLine{11439     \textcolor{keywordtype}{void} TrackerBase::moveToParent() \{}
\DoxyCodeLine{11440         assert( m\_parent );}
\DoxyCodeLine{11441         m\_ctx.setCurrentTracker( m\_parent );}
\DoxyCodeLine{11442     \}}
\DoxyCodeLine{11443     \textcolor{keywordtype}{void} TrackerBase::moveToThis() \{}
\DoxyCodeLine{11444         m\_ctx.setCurrentTracker( \textcolor{keyword}{this} );}
\DoxyCodeLine{11445     \}}
\DoxyCodeLine{11446 }
\DoxyCodeLine{11447     SectionTracker::SectionTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent )}
\DoxyCodeLine{11448     :   TrackerBase( nameAndLocation, ctx, parent )}
\DoxyCodeLine{11449     \{}
\DoxyCodeLine{11450         \textcolor{keywordflow}{if}( parent ) \{}
\DoxyCodeLine{11451             \textcolor{keywordflow}{while}( !parent->isSectionTracker() )}
\DoxyCodeLine{11452                 parent = \&parent->parent();}
\DoxyCodeLine{11453 }
\DoxyCodeLine{11454             SectionTracker\& parentSection = static\_cast<SectionTracker\&>( *parent );}
\DoxyCodeLine{11455             addNextFilters( parentSection.m\_filters );}
\DoxyCodeLine{11456         \}}
\DoxyCodeLine{11457     \}}
\DoxyCodeLine{11458 }
\DoxyCodeLine{11459     \textcolor{keywordtype}{bool} SectionTracker::isSectionTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{11460 }
\DoxyCodeLine{11461     SectionTracker\& SectionTracker::acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{11462         std::shared\_ptr<SectionTracker> section;}
\DoxyCodeLine{11463 }
\DoxyCodeLine{11464         ITracker\& currentTracker = ctx.currentTracker();}
\DoxyCodeLine{11465         \textcolor{keywordflow}{if}( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) \{}
\DoxyCodeLine{11466             assert( childTracker );}
\DoxyCodeLine{11467             assert( childTracker->isSectionTracker() );}
\DoxyCodeLine{11468             section = std::static\_pointer\_cast<SectionTracker>( childTracker );}
\DoxyCodeLine{11469         \}}
\DoxyCodeLine{11470         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11471             section = std::make\_shared<SectionTracker>( nameAndLocation, ctx, \&currentTracker );}
\DoxyCodeLine{11472             currentTracker.addChild( section );}
\DoxyCodeLine{11473         \}}
\DoxyCodeLine{11474         \textcolor{keywordflow}{if}( !ctx.completedCycle() )}
\DoxyCodeLine{11475             section->tryOpen();}
\DoxyCodeLine{11476         \textcolor{keywordflow}{return} *section;}
\DoxyCodeLine{11477     \}}
\DoxyCodeLine{11478 }
\DoxyCodeLine{11479     \textcolor{keywordtype}{void} SectionTracker::tryOpen() \{}
\DoxyCodeLine{11480         \textcolor{keywordflow}{if}( !isComplete() \&\& (m\_filters.empty() || m\_filters[0].empty() ||  m\_filters[0] == m\_nameAndLocation.name ) )}
\DoxyCodeLine{11481             open();}
\DoxyCodeLine{11482     \}}
\DoxyCodeLine{11483 }
\DoxyCodeLine{11484     \textcolor{keywordtype}{void} SectionTracker::addInitialFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters ) \{}
\DoxyCodeLine{11485         \textcolor{keywordflow}{if}( !filters.empty() ) \{}
\DoxyCodeLine{11486             m\_filters.push\_back(\textcolor{stringliteral}{""}); \textcolor{comment}{// Root - should never be consulted}}
\DoxyCodeLine{11487             m\_filters.push\_back(\textcolor{stringliteral}{""}); \textcolor{comment}{// Test Case - not a section filter}}
\DoxyCodeLine{11488             m\_filters.insert( m\_filters.end(), filters.begin(), filters.end() );}
\DoxyCodeLine{11489         \}}
\DoxyCodeLine{11490     \}}
\DoxyCodeLine{11491     \textcolor{keywordtype}{void} SectionTracker::addNextFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters ) \{}
\DoxyCodeLine{11492         \textcolor{keywordflow}{if}( filters.size() > 1 )}
\DoxyCodeLine{11493             m\_filters.insert( m\_filters.end(), ++filters.begin(), filters.end() );}
\DoxyCodeLine{11494     \}}
\DoxyCodeLine{11495 }
\DoxyCodeLine{11496     IndexTracker::IndexTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent, \textcolor{keywordtype}{int} size )}
\DoxyCodeLine{11497     :   TrackerBase( nameAndLocation, ctx, parent ),}
\DoxyCodeLine{11498         m\_size( size )}
\DoxyCodeLine{11499     \{\}}
\DoxyCodeLine{11500 }
\DoxyCodeLine{11501     \textcolor{keywordtype}{bool} IndexTracker::isIndexTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{11502 }
\DoxyCodeLine{11503     IndexTracker\& IndexTracker::acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, \textcolor{keywordtype}{int} size ) \{}
\DoxyCodeLine{11504         std::shared\_ptr<IndexTracker> tracker;}
\DoxyCodeLine{11505 }
\DoxyCodeLine{11506         ITracker\& currentTracker = ctx.currentTracker();}
\DoxyCodeLine{11507         \textcolor{keywordflow}{if}( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) \{}
\DoxyCodeLine{11508             assert( childTracker );}
\DoxyCodeLine{11509             assert( childTracker->isIndexTracker() );}
\DoxyCodeLine{11510             tracker = std::static\_pointer\_cast<IndexTracker>( childTracker );}
\DoxyCodeLine{11511         \}}
\DoxyCodeLine{11512         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11513             tracker = std::make\_shared<IndexTracker>( nameAndLocation, ctx, \&currentTracker, size );}
\DoxyCodeLine{11514             currentTracker.addChild( tracker );}
\DoxyCodeLine{11515         \}}
\DoxyCodeLine{11516 }
\DoxyCodeLine{11517         \textcolor{keywordflow}{if}( !ctx.completedCycle() \&\& !tracker->isComplete() ) \{}
\DoxyCodeLine{11518             \textcolor{keywordflow}{if}( tracker->m\_runState != ExecutingChildren \&\& tracker->m\_runState != NeedsAnotherRun )}
\DoxyCodeLine{11519                 tracker->moveNext();}
\DoxyCodeLine{11520             tracker->open();}
\DoxyCodeLine{11521         \}}
\DoxyCodeLine{11522 }
\DoxyCodeLine{11523         \textcolor{keywordflow}{return} *tracker;}
\DoxyCodeLine{11524     \}}
\DoxyCodeLine{11525 }
\DoxyCodeLine{11526     \textcolor{keywordtype}{int} IndexTracker::index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_index; \}}
\DoxyCodeLine{11527 }
\DoxyCodeLine{11528     \textcolor{keywordtype}{void} IndexTracker::moveNext() \{}
\DoxyCodeLine{11529         m\_index++;}
\DoxyCodeLine{11530         m\_children.clear();}
\DoxyCodeLine{11531     \}}
\DoxyCodeLine{11532 }
\DoxyCodeLine{11533     \textcolor{keywordtype}{void} IndexTracker::close() \{}
\DoxyCodeLine{11534         TrackerBase::close();}
\DoxyCodeLine{11535         \textcolor{keywordflow}{if}( m\_runState == CompletedSuccessfully \&\& m\_index < m\_size-1 )}
\DoxyCodeLine{11536             m\_runState = Executing;}
\DoxyCodeLine{11537     \}}
\DoxyCodeLine{11538 }
\DoxyCodeLine{11539 \} \textcolor{comment}{// namespace TestCaseTracking}}
\DoxyCodeLine{11540 }
\DoxyCodeLine{11541 \textcolor{keyword}{using} TestCaseTracking::ITracker;}
\DoxyCodeLine{11542 \textcolor{keyword}{using} TestCaseTracking::TrackerContext;}
\DoxyCodeLine{11543 \textcolor{keyword}{using} TestCaseTracking::SectionTracker;}
\DoxyCodeLine{11544 \textcolor{keyword}{using} TestCaseTracking::IndexTracker;}
\DoxyCodeLine{11545 }
\DoxyCodeLine{11546 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11547 }
\DoxyCodeLine{11548 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{11549 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{11550 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11551 \textcolor{comment}{// end catch\_test\_case\_tracker.cpp}}
\DoxyCodeLine{11552 \textcolor{comment}{// start catch\_test\_registry.cpp}}
\DoxyCodeLine{11553 }
\DoxyCodeLine{11554 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11555 }
\DoxyCodeLine{11556     \textcolor{keyword}{auto} makeTestInvoker( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept -> ITestInvoker* \{}
\DoxyCodeLine{11557         \textcolor{keywordflow}{return} \textcolor{keyword}{new}(std::nothrow) TestInvokerAsFunction( testAsFunction );}
\DoxyCodeLine{11558     \}}
\DoxyCodeLine{11559 }
\DoxyCodeLine{11560     NameAndTags::NameAndTags( StringRef \textcolor{keyword}{const}\& name\_ , StringRef \textcolor{keyword}{const}\& tags\_ ) noexcept : name( name\_ ), tags( tags\_ ) \{\}}
\DoxyCodeLine{11561 }
\DoxyCodeLine{11562     AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo \textcolor{keyword}{const}\& lineInfo, StringRef \textcolor{keyword}{const}\& classOrMethod, NameAndTags \textcolor{keyword}{const}\& nameAndTags ) noexcept \{}
\DoxyCodeLine{11563         CATCH\_TRY \{}
\DoxyCodeLine{11564             getMutableRegistryHub()}
\DoxyCodeLine{11565                     .registerTest(}
\DoxyCodeLine{11566                         makeTestCase(}
\DoxyCodeLine{11567                             invoker,}
\DoxyCodeLine{11568                             extractClassName( classOrMethod ),}
\DoxyCodeLine{11569                             nameAndTags,}
\DoxyCodeLine{11570                             lineInfo));}
\DoxyCodeLine{11571         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{11572             \textcolor{comment}{// Do not throw when constructing global objects, instead register the exception to be processed later}}
\DoxyCodeLine{11573             getMutableRegistryHub().registerStartupException();}
\DoxyCodeLine{11574         \}}
\DoxyCodeLine{11575     \}}
\DoxyCodeLine{11576 }
\DoxyCodeLine{11577     AutoReg::~AutoReg() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11578 \}}
\DoxyCodeLine{11579 \textcolor{comment}{// end catch\_test\_registry.cpp}}
\DoxyCodeLine{11580 \textcolor{comment}{// start catch\_test\_spec.cpp}}
\DoxyCodeLine{11581 }
\DoxyCodeLine{11582 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{11583 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{11584 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{11585 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{11586 }
\DoxyCodeLine{11587 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11588 }
\DoxyCodeLine{11589     TestSpec::Pattern::~Pattern() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11590     TestSpec::NamePattern::~NamePattern() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11591     TestSpec::TagPattern::~TagPattern() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11592     TestSpec::ExcludedPattern::~ExcludedPattern() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11593 }
\DoxyCodeLine{11594     TestSpec::NamePattern::NamePattern( std::string \textcolor{keyword}{const}\& name )}
\DoxyCodeLine{11595     : m\_wildcardPattern( toLower( name ), CaseSensitive::No )}
\DoxyCodeLine{11596     \{\}}
\DoxyCodeLine{11597     \textcolor{keywordtype}{bool} TestSpec::NamePattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11598         \textcolor{keywordflow}{return} m\_wildcardPattern.matches( toLower( testCase.name ) );}
\DoxyCodeLine{11599     \}}
\DoxyCodeLine{11600 }
\DoxyCodeLine{11601     TestSpec::TagPattern::TagPattern( std::string \textcolor{keyword}{const}\& tag ) : m\_tag( toLower( tag ) ) \{\}}
\DoxyCodeLine{11602     \textcolor{keywordtype}{bool} TestSpec::TagPattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11603         \textcolor{keywordflow}{return} std::find(begin(testCase.lcaseTags),}
\DoxyCodeLine{11604                          end(testCase.lcaseTags),}
\DoxyCodeLine{11605                          m\_tag) != end(testCase.lcaseTags);}
\DoxyCodeLine{11606     \}}
\DoxyCodeLine{11607 }
\DoxyCodeLine{11608     TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr \textcolor{keyword}{const}\& underlyingPattern ) : m\_underlyingPattern( underlyingPattern ) \{\}}
\DoxyCodeLine{11609     \textcolor{keywordtype}{bool} TestSpec::ExcludedPattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} !m\_underlyingPattern->matches( testCase ); \}}
\DoxyCodeLine{11610 }
\DoxyCodeLine{11611     \textcolor{keywordtype}{bool} TestSpec::Filter::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11612         \textcolor{comment}{// All patterns in a filter must match for the filter to be a match}}
\DoxyCodeLine{11613         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& pattern : m\_patterns ) \{}
\DoxyCodeLine{11614             \textcolor{keywordflow}{if}( !pattern->matches( testCase ) )}
\DoxyCodeLine{11615                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11616         \}}
\DoxyCodeLine{11617         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11618     \}}
\DoxyCodeLine{11619 }
\DoxyCodeLine{11620     \textcolor{keywordtype}{bool} TestSpec::hasFilters()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11621         \textcolor{keywordflow}{return} !m\_filters.empty();}
\DoxyCodeLine{11622     \}}
\DoxyCodeLine{11623     \textcolor{keywordtype}{bool} TestSpec::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11624         \textcolor{comment}{// A TestSpec matches if any filter matches}}
\DoxyCodeLine{11625         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& filter : m\_filters )}
\DoxyCodeLine{11626             \textcolor{keywordflow}{if}( filter.matches( testCase ) )}
\DoxyCodeLine{11627                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11628         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11629     \}}
\DoxyCodeLine{11630 \}}
\DoxyCodeLine{11631 \textcolor{comment}{// end catch\_test\_spec.cpp}}
\DoxyCodeLine{11632 \textcolor{comment}{// start catch\_test\_spec\_parser.cpp}}
\DoxyCodeLine{11633 }
\DoxyCodeLine{11634 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11635 }
\DoxyCodeLine{11636     TestSpecParser::TestSpecParser( ITagAliasRegistry \textcolor{keyword}{const}\& tagAliases ) : m\_tagAliases( \&tagAliases ) \{\}}
\DoxyCodeLine{11637 }
\DoxyCodeLine{11638     TestSpecParser\& TestSpecParser::parse( std::string \textcolor{keyword}{const}\& arg ) \{}
\DoxyCodeLine{11639         m\_mode = None;}
\DoxyCodeLine{11640         m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{11641         m\_start = std::string::npos;}
\DoxyCodeLine{11642         m\_arg = m\_tagAliases->expandAliases( arg );}
\DoxyCodeLine{11643         m\_escapeChars.clear();}
\DoxyCodeLine{11644         \textcolor{keywordflow}{for}( m\_pos = 0; m\_pos < m\_arg.size(); ++m\_pos )}
\DoxyCodeLine{11645             visitChar( m\_arg[m\_pos] );}
\DoxyCodeLine{11646         \textcolor{keywordflow}{if}( m\_mode == Name )}
\DoxyCodeLine{11647             addPattern<TestSpec::NamePattern>();}
\DoxyCodeLine{11648         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{11649     \}}
\DoxyCodeLine{11650     TestSpec TestSpecParser::testSpec() \{}
\DoxyCodeLine{11651         addFilter();}
\DoxyCodeLine{11652         \textcolor{keywordflow}{return} m\_testSpec;}
\DoxyCodeLine{11653     \}}
\DoxyCodeLine{11654 }
\DoxyCodeLine{11655     \textcolor{keywordtype}{void} TestSpecParser::visitChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{11656         \textcolor{keywordflow}{if}( m\_mode == None ) \{}
\DoxyCodeLine{11657             \textcolor{keywordflow}{switch}( c ) \{}
\DoxyCodeLine{11658             \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}: \textcolor{keywordflow}{return};}
\DoxyCodeLine{11659             \textcolor{keywordflow}{case} \textcolor{charliteral}{'~'}: m\_exclusion = \textcolor{keyword}{true}; \textcolor{keywordflow}{return};}
\DoxyCodeLine{11660             \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}: \textcolor{keywordflow}{return} startNewMode( Tag, ++m\_pos );}
\DoxyCodeLine{11661             \textcolor{keywordflow}{case} \textcolor{charliteral}{'"'}: \textcolor{keywordflow}{return} startNewMode( QuotedName, ++m\_pos );}
\DoxyCodeLine{11662             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}: \textcolor{keywordflow}{return} escape();}
\DoxyCodeLine{11663             \textcolor{keywordflow}{default}: startNewMode( Name, m\_pos ); \textcolor{keywordflow}{break};}
\DoxyCodeLine{11664             \}}
\DoxyCodeLine{11665         \}}
\DoxyCodeLine{11666         \textcolor{keywordflow}{if}( m\_mode == Name ) \{}
\DoxyCodeLine{11667             \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{','} ) \{}
\DoxyCodeLine{11668                 addPattern<TestSpec::NamePattern>();}
\DoxyCodeLine{11669                 addFilter();}
\DoxyCodeLine{11670             \}}
\DoxyCodeLine{11671             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'['} ) \{}
\DoxyCodeLine{11672                 \textcolor{keywordflow}{if}( subString() == \textcolor{stringliteral}{"exclude:"} )}
\DoxyCodeLine{11673                     m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{11674                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{11675                     addPattern<TestSpec::NamePattern>();}
\DoxyCodeLine{11676                 startNewMode( Tag, ++m\_pos );}
\DoxyCodeLine{11677             \}}
\DoxyCodeLine{11678             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} )}
\DoxyCodeLine{11679                 escape();}
\DoxyCodeLine{11680         \}}
\DoxyCodeLine{11681         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( m\_mode == EscapedName )}
\DoxyCodeLine{11682             m\_mode = Name;}
\DoxyCodeLine{11683         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( m\_mode == QuotedName \&\& c == \textcolor{charliteral}{'"'} )}
\DoxyCodeLine{11684             addPattern<TestSpec::NamePattern>();}
\DoxyCodeLine{11685         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( m\_mode == Tag \&\& c == \textcolor{charliteral}{']'} )}
\DoxyCodeLine{11686             addPattern<TestSpec::TagPattern>();}
\DoxyCodeLine{11687     \}}
\DoxyCodeLine{11688     \textcolor{keywordtype}{void} TestSpecParser::startNewMode( Mode mode, std::size\_t start ) \{}
\DoxyCodeLine{11689         m\_mode = mode;}
\DoxyCodeLine{11690         m\_start = start;}
\DoxyCodeLine{11691     \}}
\DoxyCodeLine{11692     \textcolor{keywordtype}{void} TestSpecParser::escape() \{}
\DoxyCodeLine{11693         \textcolor{keywordflow}{if}( m\_mode == None )}
\DoxyCodeLine{11694             m\_start = m\_pos;}
\DoxyCodeLine{11695         m\_mode = EscapedName;}
\DoxyCodeLine{11696         m\_escapeChars.push\_back( m\_pos );}
\DoxyCodeLine{11697     \}}
\DoxyCodeLine{11698     std::string TestSpecParser::subString()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_arg.substr( m\_start, m\_pos - m\_start ); \}}
\DoxyCodeLine{11699 }
\DoxyCodeLine{11700     \textcolor{keywordtype}{void} TestSpecParser::addFilter() \{}
\DoxyCodeLine{11701         \textcolor{keywordflow}{if}( !m\_currentFilter.m\_patterns.empty() ) \{}
\DoxyCodeLine{11702             m\_testSpec.m\_filters.push\_back( m\_currentFilter );}
\DoxyCodeLine{11703             m\_currentFilter = TestSpec::Filter();}
\DoxyCodeLine{11704         \}}
\DoxyCodeLine{11705     \}}
\DoxyCodeLine{11706 }
\DoxyCodeLine{11707     TestSpec parseTestSpec( std::string \textcolor{keyword}{const}\& arg ) \{}
\DoxyCodeLine{11708         \textcolor{keywordflow}{return} TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();}
\DoxyCodeLine{11709     \}}
\DoxyCodeLine{11710 }
\DoxyCodeLine{11711 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11712 \textcolor{comment}{// end catch\_test\_spec\_parser.cpp}}
\DoxyCodeLine{11713 \textcolor{comment}{// start catch\_timer.cpp}}
\DoxyCodeLine{11714 }
\DoxyCodeLine{11715 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{11716 }
\DoxyCodeLine{11717 \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t nanosecondsInSecond = 1000000000;}
\DoxyCodeLine{11718 }
\DoxyCodeLine{11719 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11720 }
\DoxyCodeLine{11721     \textcolor{keyword}{auto} getCurrentNanosecondsSinceEpoch() -> uint64\_t \{}
\DoxyCodeLine{11722         \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::nanoseconds>( std::chrono::high\_resolution\_clock::now().time\_since\_epoch() ).count();}
\DoxyCodeLine{11723     \}}
\DoxyCodeLine{11724 }
\DoxyCodeLine{11725     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{11726         \textcolor{keyword}{auto} estimateClockResolution() -> uint64\_t \{}
\DoxyCodeLine{11727             uint64\_t sum = 0;}
\DoxyCodeLine{11728             \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t iterations = 1000000;}
\DoxyCodeLine{11729 }
\DoxyCodeLine{11730             \textcolor{keyword}{auto} startTime = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{11731 }
\DoxyCodeLine{11732             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < iterations; ++i ) \{}
\DoxyCodeLine{11733 }
\DoxyCodeLine{11734                 uint64\_t ticks;}
\DoxyCodeLine{11735                 uint64\_t baseTicks = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{11736                 \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{11737                     ticks = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{11738                 \} \textcolor{keywordflow}{while}( ticks == baseTicks );}
\DoxyCodeLine{11739 }
\DoxyCodeLine{11740                 \textcolor{keyword}{auto} delta = ticks - baseTicks;}
\DoxyCodeLine{11741                 sum += delta;}
\DoxyCodeLine{11742 }
\DoxyCodeLine{11743                 \textcolor{comment}{// If we have been calibrating for over 3 seconds -- the clock}}
\DoxyCodeLine{11744                 \textcolor{comment}{// is terrible and we should move on.}}
\DoxyCodeLine{11745                 \textcolor{comment}{// TBD: How to signal that the measured resolution is probably wrong?}}
\DoxyCodeLine{11746                 \textcolor{keywordflow}{if} (ticks > startTime + 3 * nanosecondsInSecond) \{}
\DoxyCodeLine{11747                     \textcolor{keywordflow}{return} sum / i;}
\DoxyCodeLine{11748                 \}}
\DoxyCodeLine{11749             \}}
\DoxyCodeLine{11750 }
\DoxyCodeLine{11751             \textcolor{comment}{// We're just taking the mean, here. To do better we could take the std. dev and exclude outliers}}
\DoxyCodeLine{11752             \textcolor{comment}{// - and potentially do more iterations if there's a high variance.}}
\DoxyCodeLine{11753             \textcolor{keywordflow}{return} sum/iterations;}
\DoxyCodeLine{11754         \}}
\DoxyCodeLine{11755     \}}
\DoxyCodeLine{11756     \textcolor{keyword}{auto} getEstimatedClockResolution() -> uint64\_t \{}
\DoxyCodeLine{11757         \textcolor{keyword}{static} \textcolor{keyword}{auto} s\_resolution = estimateClockResolution();}
\DoxyCodeLine{11758         \textcolor{keywordflow}{return} s\_resolution;}
\DoxyCodeLine{11759     \}}
\DoxyCodeLine{11760 }
\DoxyCodeLine{11761     \textcolor{keywordtype}{void} Timer::start() \{}
\DoxyCodeLine{11762        m\_nanoseconds = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{11763     \}}
\DoxyCodeLine{11764     \textcolor{keyword}{auto} Timer::getElapsedNanoseconds() const -> uint64\_t \{}
\DoxyCodeLine{11765         \textcolor{keywordflow}{return} getCurrentNanosecondsSinceEpoch() - m\_nanoseconds;}
\DoxyCodeLine{11766     \}}
\DoxyCodeLine{11767     \textcolor{keyword}{auto} Timer::getElapsedMicroseconds() const -> uint64\_t \{}
\DoxyCodeLine{11768         \textcolor{keywordflow}{return} getElapsedNanoseconds()/1000;}
\DoxyCodeLine{11769     \}}
\DoxyCodeLine{11770     \textcolor{keyword}{auto} Timer::getElapsedMilliseconds() const -> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{11771         \textcolor{keywordflow}{return} static\_cast<unsigned int>(getElapsedMicroseconds()/1000);}
\DoxyCodeLine{11772     \}}
\DoxyCodeLine{11773     \textcolor{keyword}{auto} Timer::getElapsedSeconds() const -> \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{11774         \textcolor{keywordflow}{return} getElapsedMicroseconds()/1000000.0;}
\DoxyCodeLine{11775     \}}
\DoxyCodeLine{11776 }
\DoxyCodeLine{11777 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11778 \textcolor{comment}{// end catch\_timer.cpp}}
\DoxyCodeLine{11779 \textcolor{comment}{// start catch\_tostring.cpp}}
\DoxyCodeLine{11780 }
\DoxyCodeLine{11781 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{11782 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{11783 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "-Wexit-time-destructors"}}
\DoxyCodeLine{11784 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "-Wglobal-constructors"}}
\DoxyCodeLine{11785 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11786 }
\DoxyCodeLine{11787 \textcolor{comment}{// Enable specific decls locally}}
\DoxyCodeLine{11788 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{11789 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{11790 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11791 }
\DoxyCodeLine{11792 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{11793 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{11794 }
\DoxyCodeLine{11795 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11796 }
\DoxyCodeLine{11797 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{11798 }
\DoxyCodeLine{11799     \textcolor{keyword}{const} std::string unprintableString = \textcolor{stringliteral}{"\{?\}"};}
\DoxyCodeLine{11800 }
\DoxyCodeLine{11801     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{11802         \textcolor{keyword}{const} \textcolor{keywordtype}{int} hexThreshold = 255;}
\DoxyCodeLine{11803 }
\DoxyCodeLine{11804         \textcolor{keyword}{struct }Endianness \{}
\DoxyCodeLine{11805             \textcolor{keyword}{enum} Arch \{ Big, Little \};}
\DoxyCodeLine{11806 }
\DoxyCodeLine{11807             \textcolor{keyword}{static} Arch which() \{}
\DoxyCodeLine{11808                 \textcolor{keyword}{union }\_\{}
\DoxyCodeLine{11809                     \textcolor{keywordtype}{int} asInt;}
\DoxyCodeLine{11810                     \textcolor{keywordtype}{char} asChar[sizeof (int)];}
\DoxyCodeLine{11811                 \} u;}
\DoxyCodeLine{11812 }
\DoxyCodeLine{11813                 u.asInt = 1;}
\DoxyCodeLine{11814                 \textcolor{keywordflow}{return} ( u.asChar[\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})-1] == 1 ) ? Big : Little;}
\DoxyCodeLine{11815             \}}
\DoxyCodeLine{11816         \};}
\DoxyCodeLine{11817     \}}
\DoxyCodeLine{11818 }
\DoxyCodeLine{11819     std::string rawMemoryToString( \textcolor{keyword}{const} \textcolor{keywordtype}{void} *\textcolor{keywordtype}{object}, std::size\_t size ) \{}
\DoxyCodeLine{11820         \textcolor{comment}{// Reverse order for little endian architectures}}
\DoxyCodeLine{11821         \textcolor{keywordtype}{int} i = 0, end = static\_cast<int>( size ), inc = 1;}
\DoxyCodeLine{11822         \textcolor{keywordflow}{if}( Endianness::which() == Endianness::Little ) \{}
\DoxyCodeLine{11823             i = end-1;}
\DoxyCodeLine{11824             end = inc = -1;}
\DoxyCodeLine{11825         \}}
\DoxyCodeLine{11826 }
\DoxyCodeLine{11827         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const} *bytes = static\_cast<unsigned char const *>(\textcolor{keywordtype}{object});}
\DoxyCodeLine{11828         ReusableStringStream rss;}
\DoxyCodeLine{11829         rss << \textcolor{stringliteral}{"0x"} << std::setfill(\textcolor{charliteral}{'0'}) << std::hex;}
\DoxyCodeLine{11830         \textcolor{keywordflow}{for}( ; i != end; i += inc )}
\DoxyCodeLine{11831              rss << std::setw(2) << static\_cast<unsigned>(bytes[i]);}
\DoxyCodeLine{11832        \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{11833     \}}
\DoxyCodeLine{11834 \}}
\DoxyCodeLine{11835 }
\DoxyCodeLine{11836 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{11837 std::string fpToString( T value, \textcolor{keywordtype}{int} precision ) \{}
\DoxyCodeLine{11838     \textcolor{keywordflow}{if} (Catch::isnan(value)) \{}
\DoxyCodeLine{11839         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"nan"};}
\DoxyCodeLine{11840     \}}
\DoxyCodeLine{11841 }
\DoxyCodeLine{11842     ReusableStringStream rss;}
\DoxyCodeLine{11843     rss << std::setprecision( precision )}
\DoxyCodeLine{11844         << std::fixed}
\DoxyCodeLine{11845         << value;}
\DoxyCodeLine{11846     std::string d = rss.str();}
\DoxyCodeLine{11847     std::size\_t i = d.find\_last\_not\_of( \textcolor{charliteral}{'0'} );}
\DoxyCodeLine{11848     \textcolor{keywordflow}{if}( i != std::string::npos \&\& i != d.size()-1 ) \{}
\DoxyCodeLine{11849         \textcolor{keywordflow}{if}( d[i] == \textcolor{charliteral}{'.'} )}
\DoxyCodeLine{11850             i++;}
\DoxyCodeLine{11851         d = d.substr( 0, i+1 );}
\DoxyCodeLine{11852     \}}
\DoxyCodeLine{11853     \textcolor{keywordflow}{return} d;}
\DoxyCodeLine{11854 \}}
\DoxyCodeLine{11855 }
\DoxyCodeLine{11857 \textcolor{comment}{//}}
\DoxyCodeLine{11858 \textcolor{comment}{//   Out-of-line defs for full specialization of StringMaker}}
\DoxyCodeLine{11859 \textcolor{comment}{//}}
\DoxyCodeLine{11861 \textcolor{comment}{}}
\DoxyCodeLine{11862 std::string StringMaker<std::string>::convert(\textcolor{keyword}{const} std::string\& str) \{}
\DoxyCodeLine{11863     \textcolor{keywordflow}{if} (!getCurrentContext().getConfig()->showInvisibles()) \{}
\DoxyCodeLine{11864         \textcolor{keywordflow}{return} \textcolor{charliteral}{'"'} + str + '"';}
\DoxyCodeLine{11865     \}}
\DoxyCodeLine{11866 }
\DoxyCodeLine{11867     std::string s(\textcolor{stringliteral}{"\(\backslash\)""});}
\DoxyCodeLine{11868     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} c : str) \{}
\DoxyCodeLine{11869         \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{11870         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)n'}:}
\DoxyCodeLine{11871             s.append(\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)n"});}
\DoxyCodeLine{11872             \textcolor{keywordflow}{break};}
\DoxyCodeLine{11873         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)t'}:}
\DoxyCodeLine{11874             s.append(\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)t"});}
\DoxyCodeLine{11875             \textcolor{keywordflow}{break};}
\DoxyCodeLine{11876         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{11877             s.push\_back(c);}
\DoxyCodeLine{11878             \textcolor{keywordflow}{break};}
\DoxyCodeLine{11879         \}}
\DoxyCodeLine{11880     \}}
\DoxyCodeLine{11881     s.append(\textcolor{stringliteral}{"\(\backslash\)""});}
\DoxyCodeLine{11882     \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{11883 \}}
\DoxyCodeLine{11884 }
\DoxyCodeLine{11885 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{11886 std::string StringMaker<std::string\_view>::convert(std::string\_view str) \{}
\DoxyCodeLine{11887     return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{11888 \}}
\DoxyCodeLine{11889 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11890 }
\DoxyCodeLine{11891 std::string StringMaker<char const*>::convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{11892     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{11893         return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{11894     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11895         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"\{null string\}"} \};}
\DoxyCodeLine{11896     \}}
\DoxyCodeLine{11897 \}}
\DoxyCodeLine{11898 std::string StringMaker<char*>::convert(\textcolor{keywordtype}{char}* str) \{}
\DoxyCodeLine{11899     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{11900         return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{11901     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11902         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"\{null string\}"} \};}
\DoxyCodeLine{11903     \}}
\DoxyCodeLine{11904 \}}
\DoxyCodeLine{11905 }
\DoxyCodeLine{11906 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{11907 std::string StringMaker<std::wstring>::convert(\textcolor{keyword}{const} std::wstring\& wstr) \{}
\DoxyCodeLine{11908     std::string s;}
\DoxyCodeLine{11909     s.reserve(wstr.size());}
\DoxyCodeLine{11910     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} c : wstr) \{}
\DoxyCodeLine{11911         s += (c <= 0xff) ? static\_cast<char>(c) : '?';}
\DoxyCodeLine{11912     \}}
\DoxyCodeLine{11913     return ::Catch::Detail::stringify(s);}
\DoxyCodeLine{11914 \}}
\DoxyCodeLine{11915 }
\DoxyCodeLine{11916 \textcolor{preprocessor}{\# ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{11917 std::string StringMaker<std::wstring\_view>::convert(std::wstring\_view str) \{}
\DoxyCodeLine{11918     \textcolor{keywordflow}{return} StringMaker<std::wstring>::convert(std::wstring(str));}
\DoxyCodeLine{11919 \}}
\DoxyCodeLine{11920 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{11921 }
\DoxyCodeLine{11922 std::string StringMaker<wchar\_t const*>::convert(\textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * str) \{}
\DoxyCodeLine{11923     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{11924         return ::Catch::Detail::stringify(std::wstring\{ str \});}
\DoxyCodeLine{11925     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11926         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"\{null string\}"} \};}
\DoxyCodeLine{11927     \}}
\DoxyCodeLine{11928 \}}
\DoxyCodeLine{11929 std::string StringMaker<wchar\_t *>::convert(\textcolor{keywordtype}{wchar\_t} * str) \{}
\DoxyCodeLine{11930     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{11931         return ::Catch::Detail::stringify(std::wstring\{ str \});}
\DoxyCodeLine{11932     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11933         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"\{null string\}"} \};}
\DoxyCodeLine{11934     \}}
\DoxyCodeLine{11935 \}}
\DoxyCodeLine{11936 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11937 }
\DoxyCodeLine{11938 std::string StringMaker<int>::convert(\textcolor{keywordtype}{int} value) \{}
\DoxyCodeLine{11939     return ::Catch::Detail::stringify(static\_cast<long long>(value));}
\DoxyCodeLine{11940 \}}
\DoxyCodeLine{11941 std::string StringMaker<long>::convert(\textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{11942     return ::Catch::Detail::stringify(static\_cast<long long>(value));}
\DoxyCodeLine{11943 \}}
\DoxyCodeLine{11944 std::string StringMaker<long long>::convert(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{11945     ReusableStringStream rss;}
\DoxyCodeLine{11946     rss << value;}
\DoxyCodeLine{11947     \textcolor{keywordflow}{if} (value > Detail::hexThreshold) \{}
\DoxyCodeLine{11948         rss << \textcolor{stringliteral}{" (0x"} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{11949     \}}
\DoxyCodeLine{11950     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{11951 \}}
\DoxyCodeLine{11952 }
\DoxyCodeLine{11953 std::string StringMaker<unsigned int>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} value) \{}
\DoxyCodeLine{11954     return ::Catch::Detail::stringify(static\_cast<unsigned long long>(value));}
\DoxyCodeLine{11955 \}}
\DoxyCodeLine{11956 std::string StringMaker<unsigned long>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{11957     return ::Catch::Detail::stringify(static\_cast<unsigned long long>(value));}
\DoxyCodeLine{11958 \}}
\DoxyCodeLine{11959 std::string StringMaker<unsigned long long>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{11960     ReusableStringStream rss;}
\DoxyCodeLine{11961     rss << value;}
\DoxyCodeLine{11962     \textcolor{keywordflow}{if} (value > Detail::hexThreshold) \{}
\DoxyCodeLine{11963         rss << \textcolor{stringliteral}{" (0x"} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{11964     \}}
\DoxyCodeLine{11965     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{11966 \}}
\DoxyCodeLine{11967 }
\DoxyCodeLine{11968 std::string StringMaker<bool>::convert(\textcolor{keywordtype}{bool} b) \{}
\DoxyCodeLine{11969     \textcolor{keywordflow}{return} b ? \textcolor{stringliteral}{"true"} : \textcolor{stringliteral}{"false"};}
\DoxyCodeLine{11970 \}}
\DoxyCodeLine{11971 }
\DoxyCodeLine{11972 std::string StringMaker<signed char>::convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} value) \{}
\DoxyCodeLine{11973     \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)r'}) \{}
\DoxyCodeLine{11974         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"'\(\backslash\)\(\backslash\)r'"};}
\DoxyCodeLine{11975     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)f'}) \{}
\DoxyCodeLine{11976         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"'\(\backslash\)\(\backslash\)f'"};}
\DoxyCodeLine{11977     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)n'}) \{}
\DoxyCodeLine{11978         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"'\(\backslash\)\(\backslash\)n'"};}
\DoxyCodeLine{11979     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)t'}) \{}
\DoxyCodeLine{11980         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"'\(\backslash\)\(\backslash\)t'"};}
\DoxyCodeLine{11981     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{charliteral}{'\(\backslash\)0'} <= value \&\& value < \textcolor{charliteral}{' '}) \{}
\DoxyCodeLine{11982         return ::Catch::Detail::stringify(static\_cast<unsigned int>(value));}
\DoxyCodeLine{11983     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11984         \textcolor{keywordtype}{char} chstr[] = \textcolor{stringliteral}{"' '"};}
\DoxyCodeLine{11985         chstr[1] = value;}
\DoxyCodeLine{11986         \textcolor{keywordflow}{return} chstr;}
\DoxyCodeLine{11987     \}}
\DoxyCodeLine{11988 \}}
\DoxyCodeLine{11989 std::string StringMaker<char>::convert(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{11990     return ::Catch::Detail::stringify(static\_cast<signed char>(c));}
\DoxyCodeLine{11991 \}}
\DoxyCodeLine{11992 std::string StringMaker<unsigned char>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{11993     return ::Catch::Detail::stringify(static\_cast<char>(c));}
\DoxyCodeLine{11994 \}}
\DoxyCodeLine{11995 }
\DoxyCodeLine{11996 std::string StringMaker<std::nullptr\_t>::convert(std::nullptr\_t) \{}
\DoxyCodeLine{11997     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"nullptr"};}
\DoxyCodeLine{11998 \}}
\DoxyCodeLine{11999 }
\DoxyCodeLine{12000 std::string StringMaker<float>::convert(\textcolor{keywordtype}{float} value) \{}
\DoxyCodeLine{12001     \textcolor{keywordflow}{return} fpToString(value, 5) + 'f';}
\DoxyCodeLine{12002 \}}
\DoxyCodeLine{12003 std::string StringMaker<double>::convert(\textcolor{keywordtype}{double} value) \{}
\DoxyCodeLine{12004     \textcolor{keywordflow}{return} fpToString(value, 10);}
\DoxyCodeLine{12005 \}}
\DoxyCodeLine{12006 }
\DoxyCodeLine{12007 std::string ratio\_string<std::atto>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"a"}; \}}
\DoxyCodeLine{12008 std::string ratio\_string<std::femto>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"f"}; \}}
\DoxyCodeLine{12009 std::string ratio\_string<std::pico>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"p"}; \}}
\DoxyCodeLine{12010 std::string ratio\_string<std::nano>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"n"}; \}}
\DoxyCodeLine{12011 std::string ratio\_string<std::micro>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"u"}; \}}
\DoxyCodeLine{12012 std::string ratio\_string<std::milli>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"m"}; \}}
\DoxyCodeLine{12013 }
\DoxyCodeLine{12014 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12015 }
\DoxyCodeLine{12016 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{12017 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{12018 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12019 }
\DoxyCodeLine{12020 \textcolor{comment}{// end catch\_tostring.cpp}}
\DoxyCodeLine{12021 \textcolor{comment}{// start catch\_totals.cpp}}
\DoxyCodeLine{12022 }
\DoxyCodeLine{12023 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12024 }
\DoxyCodeLine{12025     Counts Counts::operator - ( Counts \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12026         Counts diff;}
\DoxyCodeLine{12027         diff.passed = passed - other.passed;}
\DoxyCodeLine{12028         diff.failed = failed - other.failed;}
\DoxyCodeLine{12029         diff.failedButOk = failedButOk - other.failedButOk;}
\DoxyCodeLine{12030         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{12031     \}}
\DoxyCodeLine{12032 }
\DoxyCodeLine{12033     Counts\& Counts::operator += ( Counts \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{12034         passed += other.passed;}
\DoxyCodeLine{12035         failed += other.failed;}
\DoxyCodeLine{12036         failedButOk += other.failedButOk;}
\DoxyCodeLine{12037         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12038     \}}
\DoxyCodeLine{12039 }
\DoxyCodeLine{12040     std::size\_t Counts::total()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12041         \textcolor{keywordflow}{return} passed + failed + failedButOk;}
\DoxyCodeLine{12042     \}}
\DoxyCodeLine{12043     \textcolor{keywordtype}{bool} Counts::allPassed()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12044         \textcolor{keywordflow}{return} failed == 0 \&\& failedButOk == 0;}
\DoxyCodeLine{12045     \}}
\DoxyCodeLine{12046     \textcolor{keywordtype}{bool} Counts::allOk()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12047         \textcolor{keywordflow}{return} failed == 0;}
\DoxyCodeLine{12048     \}}
\DoxyCodeLine{12049 }
\DoxyCodeLine{12050     Totals Totals::operator - ( Totals \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12051         Totals diff;}
\DoxyCodeLine{12052         diff.assertions = assertions - other.assertions;}
\DoxyCodeLine{12053         diff.testCases = testCases - other.testCases;}
\DoxyCodeLine{12054         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{12055     \}}
\DoxyCodeLine{12056 }
\DoxyCodeLine{12057     Totals\& Totals::operator += ( Totals \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{12058         assertions += other.assertions;}
\DoxyCodeLine{12059         testCases += other.testCases;}
\DoxyCodeLine{12060         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12061     \}}
\DoxyCodeLine{12062 }
\DoxyCodeLine{12063     Totals Totals::delta( Totals \textcolor{keyword}{const}\& prevTotals )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12064         Totals diff = *\textcolor{keyword}{this} - prevTotals;}
\DoxyCodeLine{12065         \textcolor{keywordflow}{if}( diff.assertions.failed > 0 )}
\DoxyCodeLine{12066             ++diff.testCases.failed;}
\DoxyCodeLine{12067         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( diff.assertions.failedButOk > 0 )}
\DoxyCodeLine{12068             ++diff.testCases.failedButOk;}
\DoxyCodeLine{12069         \textcolor{keywordflow}{else}}
\DoxyCodeLine{12070             ++diff.testCases.passed;}
\DoxyCodeLine{12071         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{12072     \}}
\DoxyCodeLine{12073 }
\DoxyCodeLine{12074 \}}
\DoxyCodeLine{12075 \textcolor{comment}{// end catch\_totals.cpp}}
\DoxyCodeLine{12076 \textcolor{comment}{// start catch\_uncaught\_exceptions.cpp}}
\DoxyCodeLine{12077 }
\DoxyCodeLine{12078 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{12079 }
\DoxyCodeLine{12080 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12081     \textcolor{keywordtype}{bool} uncaught\_exceptions() \{}
\DoxyCodeLine{12082 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)}}
\DoxyCodeLine{12083         \textcolor{keywordflow}{return} std::uncaught\_exceptions() > 0;}
\DoxyCodeLine{12084 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12085         \textcolor{keywordflow}{return} std::uncaught\_exception();}
\DoxyCodeLine{12086 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12087   \}}
\DoxyCodeLine{12088 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12089 \textcolor{comment}{// end catch\_uncaught\_exceptions.cpp}}
\DoxyCodeLine{12090 \textcolor{comment}{// start catch\_version.cpp}}
\DoxyCodeLine{12091 }
\DoxyCodeLine{12092 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{12093 }
\DoxyCodeLine{12094 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12095 }
\DoxyCodeLine{12096     Version::Version}
\DoxyCodeLine{12097         (   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_majorVersion,}
\DoxyCodeLine{12098             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_minorVersion,}
\DoxyCodeLine{12099             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_patchNumber,}
\DoxyCodeLine{12100             \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} \_branchName,}
\DoxyCodeLine{12101             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_buildNumber )}
\DoxyCodeLine{12102     :   majorVersion( \_majorVersion ),}
\DoxyCodeLine{12103         minorVersion( \_minorVersion ),}
\DoxyCodeLine{12104         patchNumber( \_patchNumber ),}
\DoxyCodeLine{12105         branchName( \_branchName ),}
\DoxyCodeLine{12106         buildNumber( \_buildNumber )}
\DoxyCodeLine{12107     \{\}}
\DoxyCodeLine{12108 }
\DoxyCodeLine{12109     std::ostream\& operator << ( std::ostream\& os, Version \textcolor{keyword}{const}\& version ) \{}
\DoxyCodeLine{12110         os  << version.majorVersion << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{12111             << version.minorVersion << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{12112             << version.patchNumber;}
\DoxyCodeLine{12113         \textcolor{comment}{// branchName is never null -> 0th char is \(\backslash\)0 if it is empty}}
\DoxyCodeLine{12114         \textcolor{keywordflow}{if} (version.branchName[0]) \{}
\DoxyCodeLine{12115             os << \textcolor{charliteral}{'-'} << version.branchName}
\DoxyCodeLine{12116                << \textcolor{charliteral}{'.'} << version.buildNumber;}
\DoxyCodeLine{12117         \}}
\DoxyCodeLine{12118         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{12119     \}}
\DoxyCodeLine{12120 }
\DoxyCodeLine{12121     Version \textcolor{keyword}{const}\& libraryVersion() \{}
\DoxyCodeLine{12122         \textcolor{keyword}{static} Version version( 2, 5, 0, \textcolor{stringliteral}{""}, 0 );}
\DoxyCodeLine{12123         \textcolor{keywordflow}{return} version;}
\DoxyCodeLine{12124     \}}
\DoxyCodeLine{12125 }
\DoxyCodeLine{12126 \}}
\DoxyCodeLine{12127 \textcolor{comment}{// end catch\_version.cpp}}
\DoxyCodeLine{12128 \textcolor{comment}{// start catch\_wildcard\_pattern.cpp}}
\DoxyCodeLine{12129 }
\DoxyCodeLine{12130 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{12131 }
\DoxyCodeLine{12132 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12133 }
\DoxyCodeLine{12134     WildcardPattern::WildcardPattern( std::string \textcolor{keyword}{const}\& pattern,}
\DoxyCodeLine{12135                                       CaseSensitive::Choice caseSensitivity )}
\DoxyCodeLine{12136     :   m\_caseSensitivity( caseSensitivity ),}
\DoxyCodeLine{12137         m\_pattern( adjustCase( pattern ) )}
\DoxyCodeLine{12138     \{}
\DoxyCodeLine{12139         \textcolor{keywordflow}{if}( startsWith( m\_pattern, \textcolor{charliteral}{'*'} ) ) \{}
\DoxyCodeLine{12140             m\_pattern = m\_pattern.substr( 1 );}
\DoxyCodeLine{12141             m\_wildcard = WildcardAtStart;}
\DoxyCodeLine{12142         \}}
\DoxyCodeLine{12143         \textcolor{keywordflow}{if}( endsWith( m\_pattern, \textcolor{charliteral}{'*'} ) ) \{}
\DoxyCodeLine{12144             m\_pattern = m\_pattern.substr( 0, m\_pattern.size()-1 );}
\DoxyCodeLine{12145             m\_wildcard = static\_cast<WildcardPosition>( m\_wildcard | WildcardAtEnd );}
\DoxyCodeLine{12146         \}}
\DoxyCodeLine{12147     \}}
\DoxyCodeLine{12148 }
\DoxyCodeLine{12149     \textcolor{keywordtype}{bool} WildcardPattern::matches( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12150         \textcolor{keywordflow}{switch}( m\_wildcard ) \{}
\DoxyCodeLine{12151             \textcolor{keywordflow}{case} NoWildcard:}
\DoxyCodeLine{12152                 \textcolor{keywordflow}{return} m\_pattern == adjustCase( str );}
\DoxyCodeLine{12153             \textcolor{keywordflow}{case} WildcardAtStart:}
\DoxyCodeLine{12154                 \textcolor{keywordflow}{return} endsWith( adjustCase( str ), m\_pattern );}
\DoxyCodeLine{12155             \textcolor{keywordflow}{case} WildcardAtEnd:}
\DoxyCodeLine{12156                 \textcolor{keywordflow}{return} startsWith( adjustCase( str ), m\_pattern );}
\DoxyCodeLine{12157             \textcolor{keywordflow}{case} WildcardAtBothEnds:}
\DoxyCodeLine{12158                 \textcolor{keywordflow}{return} contains( adjustCase( str ), m\_pattern );}
\DoxyCodeLine{12159             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{12160                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"Unknown enum"} );}
\DoxyCodeLine{12161         \}}
\DoxyCodeLine{12162     \}}
\DoxyCodeLine{12163 }
\DoxyCodeLine{12164     std::string WildcardPattern::adjustCase( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12165         \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No ? toLower( str ) : str;}
\DoxyCodeLine{12166     \}}
\DoxyCodeLine{12167 \}}
\DoxyCodeLine{12168 \textcolor{comment}{// end catch\_wildcard\_pattern.cpp}}
\DoxyCodeLine{12169 \textcolor{comment}{// start catch\_xmlwriter.cpp}}
\DoxyCodeLine{12170 }
\DoxyCodeLine{12171 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{12172 }
\DoxyCodeLine{12173 \textcolor{keyword}{using} uchar = \textcolor{keywordtype}{unsigned} char;}
\DoxyCodeLine{12174 }
\DoxyCodeLine{12175 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12176 }
\DoxyCodeLine{12177 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{12178 }
\DoxyCodeLine{12179     \textcolor{keywordtype}{size\_t} trailingBytes(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{12180         \textcolor{keywordflow}{if} ((c \& 0xE0) == 0xC0) \{}
\DoxyCodeLine{12181             \textcolor{keywordflow}{return} 2;}
\DoxyCodeLine{12182         \}}
\DoxyCodeLine{12183         \textcolor{keywordflow}{if} ((c \& 0xF0) == 0xE0) \{}
\DoxyCodeLine{12184             \textcolor{keywordflow}{return} 3;}
\DoxyCodeLine{12185         \}}
\DoxyCodeLine{12186         \textcolor{keywordflow}{if} ((c \& 0xF8) == 0xF0) \{}
\DoxyCodeLine{12187             \textcolor{keywordflow}{return} 4;}
\DoxyCodeLine{12188         \}}
\DoxyCodeLine{12189         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"Invalid multibyte utf-8 start byte encountered"});}
\DoxyCodeLine{12190     \}}
\DoxyCodeLine{12191 }
\DoxyCodeLine{12192     uint32\_t headerValue(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{12193         \textcolor{keywordflow}{if} ((c \& 0xE0) == 0xC0) \{}
\DoxyCodeLine{12194             \textcolor{keywordflow}{return} c \& 0x1F;}
\DoxyCodeLine{12195         \}}
\DoxyCodeLine{12196         \textcolor{keywordflow}{if} ((c \& 0xF0) == 0xE0) \{}
\DoxyCodeLine{12197             \textcolor{keywordflow}{return} c \& 0x0F;}
\DoxyCodeLine{12198         \}}
\DoxyCodeLine{12199         \textcolor{keywordflow}{if} ((c \& 0xF8) == 0xF0) \{}
\DoxyCodeLine{12200             \textcolor{keywordflow}{return} c \& 0x07;}
\DoxyCodeLine{12201         \}}
\DoxyCodeLine{12202         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"Invalid multibyte utf-8 start byte encountered"});}
\DoxyCodeLine{12203     \}}
\DoxyCodeLine{12204 }
\DoxyCodeLine{12205     \textcolor{keywordtype}{void} hexEscapeChar(std::ostream\& os, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{12206         os << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)x"}}
\DoxyCodeLine{12207             << std::uppercase << std::hex << std::setfill(\textcolor{charliteral}{'0'}) << std::setw(2)}
\DoxyCodeLine{12208             << static\_cast<int>(c);}
\DoxyCodeLine{12209     \}}
\DoxyCodeLine{12210 }
\DoxyCodeLine{12211 \} \textcolor{comment}{// anonymous namespace}}
\DoxyCodeLine{12212 }
\DoxyCodeLine{12213     XmlEncode::XmlEncode( std::string \textcolor{keyword}{const}\& str, ForWhat forWhat )}
\DoxyCodeLine{12214     :   m\_str( str ),}
\DoxyCodeLine{12215         m\_forWhat( forWhat )}
\DoxyCodeLine{12216     \{\}}
\DoxyCodeLine{12217 }
\DoxyCodeLine{12218     \textcolor{keywordtype}{void} XmlEncode::encodeTo( std::ostream\& os )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12219         \textcolor{comment}{// Apostrophe escaping not necessary if we always use " to write attributes}}
\DoxyCodeLine{12220         \textcolor{comment}{// (see: http://www.w3.org/TR/xml/\#syntax)}}
\DoxyCodeLine{12221 }
\DoxyCodeLine{12222         \textcolor{keywordflow}{for}( std::size\_t idx = 0; idx < m\_str.size(); ++ idx ) \{}
\DoxyCodeLine{12223             uchar c = m\_str[idx];}
\DoxyCodeLine{12224             \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{12225             \textcolor{keywordflow}{case} \textcolor{charliteral}{'<'}:   os << \textcolor{stringliteral}{"\&lt;"}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{12226             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\&'}:   os << \textcolor{stringliteral}{"\&amp;"}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{12227 }
\DoxyCodeLine{12228             \textcolor{keywordflow}{case} \textcolor{charliteral}{'>'}:}
\DoxyCodeLine{12229                 \textcolor{comment}{// See: http://www.w3.org/TR/xml/\#syntax}}
\DoxyCodeLine{12230                 \textcolor{keywordflow}{if} (idx > 2 \&\& m\_str[idx - 1] == \textcolor{charliteral}{']'} \&\& m\_str[idx - 2] == \textcolor{charliteral}{']'})}
\DoxyCodeLine{12231                     os << \textcolor{stringliteral}{"\&gt;"};}
\DoxyCodeLine{12232                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{12233                     os << c;}
\DoxyCodeLine{12234                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12235 }
\DoxyCodeLine{12236             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)"'}:}
\DoxyCodeLine{12237                 \textcolor{keywordflow}{if} (m\_forWhat == ForAttributes)}
\DoxyCodeLine{12238                     os << \textcolor{stringliteral}{"\&quot;"};}
\DoxyCodeLine{12239                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{12240                     os << c;}
\DoxyCodeLine{12241                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12242 }
\DoxyCodeLine{12243             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{12244                 \textcolor{comment}{// Check for control characters and invalid utf-8}}
\DoxyCodeLine{12245 }
\DoxyCodeLine{12246                 \textcolor{comment}{// Escape control characters in standard ascii}}
\DoxyCodeLine{12247                 \textcolor{comment}{// see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0}}
\DoxyCodeLine{12248                 \textcolor{keywordflow}{if} (c < 0x09 || (c > 0x0D \&\& c < 0x20) || c == 0x7F) \{}
\DoxyCodeLine{12249                     hexEscapeChar(os, c);}
\DoxyCodeLine{12250                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{12251                 \}}
\DoxyCodeLine{12252 }
\DoxyCodeLine{12253                 \textcolor{comment}{// Plain ASCII: Write it to stream}}
\DoxyCodeLine{12254                 \textcolor{keywordflow}{if} (c < 0x7F) \{}
\DoxyCodeLine{12255                     os << c;}
\DoxyCodeLine{12256                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{12257                 \}}
\DoxyCodeLine{12258 }
\DoxyCodeLine{12259                 \textcolor{comment}{// UTF-8 territory}}
\DoxyCodeLine{12260                 \textcolor{comment}{// Check if the encoding is valid and if it is not, hex escape bytes.}}
\DoxyCodeLine{12261                 \textcolor{comment}{// Important: We do not check the exact decoded values for validity, only the encoding format}}
\DoxyCodeLine{12262                 \textcolor{comment}{// First check that this bytes is a valid lead byte:}}
\DoxyCodeLine{12263                 \textcolor{comment}{// This means that it is not encoded as 1111 1XXX}}
\DoxyCodeLine{12264                 \textcolor{comment}{// Or as 10XX XXXX}}
\DoxyCodeLine{12265                 \textcolor{keywordflow}{if} (c <  0xC0 ||}
\DoxyCodeLine{12266                     c >= 0xF8) \{}
\DoxyCodeLine{12267                     hexEscapeChar(os, c);}
\DoxyCodeLine{12268                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{12269                 \}}
\DoxyCodeLine{12270 }
\DoxyCodeLine{12271                 \textcolor{keyword}{auto} encBytes = trailingBytes(c);}
\DoxyCodeLine{12272                 \textcolor{comment}{// Are there enough bytes left to avoid accessing out-of-bounds memory?}}
\DoxyCodeLine{12273                 \textcolor{keywordflow}{if} (idx + encBytes - 1 >= m\_str.size()) \{}
\DoxyCodeLine{12274                     hexEscapeChar(os, c);}
\DoxyCodeLine{12275                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{12276                 \}}
\DoxyCodeLine{12277                 \textcolor{comment}{// The header is valid, check data}}
\DoxyCodeLine{12278                 \textcolor{comment}{// The next encBytes bytes must together be a valid utf-8}}
\DoxyCodeLine{12279                 \textcolor{comment}{// This means: bitpattern 10XX XXXX and the extracted value is sane (ish)}}
\DoxyCodeLine{12280                 \textcolor{keywordtype}{bool} valid = \textcolor{keyword}{true};}
\DoxyCodeLine{12281                 uint32\_t value = headerValue(c);}
\DoxyCodeLine{12282                 \textcolor{keywordflow}{for} (std::size\_t n = 1; n < encBytes; ++n) \{}
\DoxyCodeLine{12283                     uchar nc = m\_str[idx + n];}
\DoxyCodeLine{12284                     valid \&= ((nc \& 0xC0) == 0x80);}
\DoxyCodeLine{12285                     value = (value << 6) | (nc \& 0x3F);}
\DoxyCodeLine{12286                 \}}
\DoxyCodeLine{12287 }
\DoxyCodeLine{12288                 \textcolor{keywordflow}{if} (}
\DoxyCodeLine{12289                     \textcolor{comment}{// Wrong bit pattern of following bytes}}
\DoxyCodeLine{12290                     (!valid) ||}
\DoxyCodeLine{12291                     \textcolor{comment}{// Overlong encodings}}
\DoxyCodeLine{12292                     (value < 0x80) ||}
\DoxyCodeLine{12293                     (0x80 <= value \&\& value < 0x800   \&\& encBytes > 2) ||}
\DoxyCodeLine{12294                     (0x800 < value \&\& value < 0x10000 \&\& encBytes > 3) ||}
\DoxyCodeLine{12295                     \textcolor{comment}{// Encoded value out of range}}
\DoxyCodeLine{12296                     (value >= 0x110000)}
\DoxyCodeLine{12297                     ) \{}
\DoxyCodeLine{12298                     hexEscapeChar(os, c);}
\DoxyCodeLine{12299                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{12300                 \}}
\DoxyCodeLine{12301 }
\DoxyCodeLine{12302                 \textcolor{comment}{// If we got here, this is in fact a valid(ish) utf-8 sequence}}
\DoxyCodeLine{12303                 \textcolor{keywordflow}{for} (std::size\_t n = 0; n < encBytes; ++n) \{}
\DoxyCodeLine{12304                     os << m\_str[idx + n];}
\DoxyCodeLine{12305                 \}}
\DoxyCodeLine{12306                 idx += encBytes - 1;}
\DoxyCodeLine{12307                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12308             \}}
\DoxyCodeLine{12309         \}}
\DoxyCodeLine{12310     \}}
\DoxyCodeLine{12311 }
\DoxyCodeLine{12312     std::ostream\& operator << ( std::ostream\& os, XmlEncode \textcolor{keyword}{const}\& xmlEncode ) \{}
\DoxyCodeLine{12313         xmlEncode.encodeTo( os );}
\DoxyCodeLine{12314         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{12315     \}}
\DoxyCodeLine{12316 }
\DoxyCodeLine{12317     XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer )}
\DoxyCodeLine{12318     :   m\_writer( writer )}
\DoxyCodeLine{12319     \{\}}
\DoxyCodeLine{12320 }
\DoxyCodeLine{12321     XmlWriter::ScopedElement::ScopedElement( ScopedElement\&\& other ) noexcept}
\DoxyCodeLine{12322     :   m\_writer( other.m\_writer )\{}
\DoxyCodeLine{12323         other.m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12324     \}}
\DoxyCodeLine{12325     XmlWriter::ScopedElement\& XmlWriter::ScopedElement::operator=( ScopedElement\&\& other ) noexcept \{}
\DoxyCodeLine{12326         \textcolor{keywordflow}{if} ( m\_writer ) \{}
\DoxyCodeLine{12327             m\_writer->endElement();}
\DoxyCodeLine{12328         \}}
\DoxyCodeLine{12329         m\_writer = other.m\_writer;}
\DoxyCodeLine{12330         other.m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12331         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12332     \}}
\DoxyCodeLine{12333 }
\DoxyCodeLine{12334     XmlWriter::ScopedElement::~ScopedElement() \{}
\DoxyCodeLine{12335         \textcolor{keywordflow}{if}( m\_writer )}
\DoxyCodeLine{12336             m\_writer->endElement();}
\DoxyCodeLine{12337     \}}
\DoxyCodeLine{12338 }
\DoxyCodeLine{12339     XmlWriter::ScopedElement\& XmlWriter::ScopedElement::writeText( std::string \textcolor{keyword}{const}\& text, \textcolor{keywordtype}{bool} indent ) \{}
\DoxyCodeLine{12340         m\_writer->writeText( text, indent );}
\DoxyCodeLine{12341         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12342     \}}
\DoxyCodeLine{12343 }
\DoxyCodeLine{12344     XmlWriter::XmlWriter( std::ostream\& os ) : m\_os( os )}
\DoxyCodeLine{12345     \{}
\DoxyCodeLine{12346         writeDeclaration();}
\DoxyCodeLine{12347     \}}
\DoxyCodeLine{12348 }
\DoxyCodeLine{12349     XmlWriter::~XmlWriter() \{}
\DoxyCodeLine{12350         \textcolor{keywordflow}{while}( !m\_tags.empty() )}
\DoxyCodeLine{12351             endElement();}
\DoxyCodeLine{12352     \}}
\DoxyCodeLine{12353 }
\DoxyCodeLine{12354     XmlWriter\& XmlWriter::startElement( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{12355         ensureTagClosed();}
\DoxyCodeLine{12356         newlineIfNecessary();}
\DoxyCodeLine{12357         m\_os << m\_indent << \textcolor{charliteral}{'<'} << name;}
\DoxyCodeLine{12358         m\_tags.push\_back( name );}
\DoxyCodeLine{12359         m\_indent += "  ";}
\DoxyCodeLine{12360         m\_tagIsOpen = \textcolor{keyword}{true};}
\DoxyCodeLine{12361         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12362     \}}
\DoxyCodeLine{12363 }
\DoxyCodeLine{12364     XmlWriter::ScopedElement XmlWriter::scopedElement( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{12365         ScopedElement scoped( \textcolor{keyword}{this} );}
\DoxyCodeLine{12366         startElement( name );}
\DoxyCodeLine{12367         \textcolor{keywordflow}{return} scoped;}
\DoxyCodeLine{12368     \}}
\DoxyCodeLine{12369 }
\DoxyCodeLine{12370     XmlWriter\& XmlWriter::endElement() \{}
\DoxyCodeLine{12371         newlineIfNecessary();}
\DoxyCodeLine{12372         m\_indent = m\_indent.substr( 0, m\_indent.size()-2 );}
\DoxyCodeLine{12373         \textcolor{keywordflow}{if}( m\_tagIsOpen ) \{}
\DoxyCodeLine{12374             m\_os << \textcolor{stringliteral}{"/>"};}
\DoxyCodeLine{12375             m\_tagIsOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{12376         \}}
\DoxyCodeLine{12377         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12378             m\_os << m\_indent << \textcolor{stringliteral}{"</"} << m\_tags.back() << \textcolor{stringliteral}{">"};}
\DoxyCodeLine{12379         \}}
\DoxyCodeLine{12380         m\_os << std::endl;}
\DoxyCodeLine{12381         m\_tags.pop\_back();}
\DoxyCodeLine{12382         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12383     \}}
\DoxyCodeLine{12384 }
\DoxyCodeLine{12385     XmlWriter\& XmlWriter::writeAttribute( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{12386         \textcolor{keywordflow}{if}( !name.empty() \&\& !attribute.empty() )}
\DoxyCodeLine{12387             m\_os << \textcolor{charliteral}{' '} << name << \textcolor{stringliteral}{"=\(\backslash\)""} << XmlEncode( attribute, XmlEncode::ForAttributes ) << \textcolor{charliteral}{'"'};}
\DoxyCodeLine{12388         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12389     \}}
\DoxyCodeLine{12390 }
\DoxyCodeLine{12391     XmlWriter\& XmlWriter::writeAttribute( std::string \textcolor{keyword}{const}\& name, \textcolor{keywordtype}{bool} attribute ) \{}
\DoxyCodeLine{12392         m\_os << \textcolor{charliteral}{' '} << name << \textcolor{stringliteral}{"=\(\backslash\)""} << ( attribute ? \textcolor{stringliteral}{"true"} : \textcolor{stringliteral}{"false"} ) << \textcolor{charliteral}{'"'};}
\DoxyCodeLine{12393         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12394     \}}
\DoxyCodeLine{12395 }
\DoxyCodeLine{12396     XmlWriter\& XmlWriter::writeText( std::string \textcolor{keyword}{const}\& text, \textcolor{keywordtype}{bool} indent ) \{}
\DoxyCodeLine{12397         \textcolor{keywordflow}{if}( !text.empty() )\{}
\DoxyCodeLine{12398             \textcolor{keywordtype}{bool} tagWasOpen = m\_tagIsOpen;}
\DoxyCodeLine{12399             ensureTagClosed();}
\DoxyCodeLine{12400             \textcolor{keywordflow}{if}( tagWasOpen \&\& indent )}
\DoxyCodeLine{12401                 m\_os << m\_indent;}
\DoxyCodeLine{12402             m\_os << XmlEncode( text );}
\DoxyCodeLine{12403             m\_needsNewline = \textcolor{keyword}{true};}
\DoxyCodeLine{12404         \}}
\DoxyCodeLine{12405         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12406     \}}
\DoxyCodeLine{12407 }
\DoxyCodeLine{12408     XmlWriter\& XmlWriter::writeComment( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{12409         ensureTagClosed();}
\DoxyCodeLine{12410         m\_os << m\_indent << \textcolor{stringliteral}{"<!--"} << text << \textcolor{stringliteral}{"-->"};}
\DoxyCodeLine{12411         m\_needsNewline = \textcolor{keyword}{true};}
\DoxyCodeLine{12412         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12413     \}}
\DoxyCodeLine{12414 }
\DoxyCodeLine{12415     \textcolor{keywordtype}{void} XmlWriter::writeStylesheetRef( std::string \textcolor{keyword}{const}\& url ) \{}
\DoxyCodeLine{12416         m\_os << \textcolor{stringliteral}{"<?xml-stylesheet type=\(\backslash\)"text/xsl\(\backslash\)" href=\(\backslash\)""} << url << \textcolor{stringliteral}{"\(\backslash\)"?>\(\backslash\)n"};}
\DoxyCodeLine{12417     \}}
\DoxyCodeLine{12418 }
\DoxyCodeLine{12419     XmlWriter\& XmlWriter::writeBlankLine() \{}
\DoxyCodeLine{12420         ensureTagClosed();}
\DoxyCodeLine{12421         m\_os << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{12422         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12423     \}}
\DoxyCodeLine{12424 }
\DoxyCodeLine{12425     \textcolor{keywordtype}{void} XmlWriter::ensureTagClosed() \{}
\DoxyCodeLine{12426         \textcolor{keywordflow}{if}( m\_tagIsOpen ) \{}
\DoxyCodeLine{12427             m\_os << \textcolor{stringliteral}{">"} << std::endl;}
\DoxyCodeLine{12428             m\_tagIsOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{12429         \}}
\DoxyCodeLine{12430     \}}
\DoxyCodeLine{12431 }
\DoxyCodeLine{12432     \textcolor{keywordtype}{void} XmlWriter::writeDeclaration() \{}
\DoxyCodeLine{12433         m\_os << \textcolor{stringliteral}{"<?xml version=\(\backslash\)"1.0\(\backslash\)" encoding=\(\backslash\)"UTF-8\(\backslash\)"?>\(\backslash\)n"};}
\DoxyCodeLine{12434     \}}
\DoxyCodeLine{12435 }
\DoxyCodeLine{12436     \textcolor{keywordtype}{void} XmlWriter::newlineIfNecessary() \{}
\DoxyCodeLine{12437         \textcolor{keywordflow}{if}( m\_needsNewline ) \{}
\DoxyCodeLine{12438             m\_os << std::endl;}
\DoxyCodeLine{12439             m\_needsNewline = \textcolor{keyword}{false};}
\DoxyCodeLine{12440         \}}
\DoxyCodeLine{12441     \}}
\DoxyCodeLine{12442 \}}
\DoxyCodeLine{12443 \textcolor{comment}{// end catch\_xmlwriter.cpp}}
\DoxyCodeLine{12444 \textcolor{comment}{// start catch\_reporter\_bases.cpp}}
\DoxyCodeLine{12445 }
\DoxyCodeLine{12446 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{12447 \textcolor{preprocessor}{\#include <cfloat>}}
\DoxyCodeLine{12448 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{12449 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{12450 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{12451 }
\DoxyCodeLine{12452 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12453     \textcolor{keywordtype}{void} prepareExpandedExpression(AssertionResult\& result) \{}
\DoxyCodeLine{12454         result.getExpandedExpression();}
\DoxyCodeLine{12455     \}}
\DoxyCodeLine{12456 }
\DoxyCodeLine{12457     \textcolor{comment}{// Because formatting using c++ streams is stateful, drop down to C is required}}
\DoxyCodeLine{12458     \textcolor{comment}{// Alternatively we could use stringstream, but its performance is... not good.}}
\DoxyCodeLine{12459     std::string getFormattedDuration( \textcolor{keywordtype}{double} duration ) \{}
\DoxyCodeLine{12460         \textcolor{comment}{// Max exponent + 1 is required to represent the whole part}}
\DoxyCodeLine{12461         \textcolor{comment}{// + 1 for decimal point}}
\DoxyCodeLine{12462         \textcolor{comment}{// + 3 for the 3 decimal places}}
\DoxyCodeLine{12463         \textcolor{comment}{// + 1 for null terminator}}
\DoxyCodeLine{12464         \textcolor{keyword}{const} std::size\_t maxDoubleSize = DBL\_MAX\_10\_EXP + 1 + 1 + 3 + 1;}
\DoxyCodeLine{12465         \textcolor{keywordtype}{char} buffer[maxDoubleSize];}
\DoxyCodeLine{12466 }
\DoxyCodeLine{12467         \textcolor{comment}{// Save previous errno, to prevent sprintf from overwriting it}}
\DoxyCodeLine{12468         ErrnoGuard guard;}
\DoxyCodeLine{12469 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{12470         sprintf\_s(buffer, \textcolor{stringliteral}{"\%.3f"}, duration);}
\DoxyCodeLine{12471 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12472         sprintf(buffer, \textcolor{stringliteral}{"\%.3f"}, duration);}
\DoxyCodeLine{12473 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12474         \textcolor{keywordflow}{return} std::string(buffer);}
\DoxyCodeLine{12475     \}}
\DoxyCodeLine{12476 }
\DoxyCodeLine{12477     TestEventListenerBase::TestEventListenerBase(ReporterConfig \textcolor{keyword}{const} \& \_config)}
\DoxyCodeLine{12478         :StreamingReporterBase(\_config) \{\}}
\DoxyCodeLine{12479 }
\DoxyCodeLine{12480     std::set<Verbosity> TestEventListenerBase::getSupportedVerbosities() \{}
\DoxyCodeLine{12481         \textcolor{keywordflow}{return} \{ Verbosity::Quiet, Verbosity::Normal, Verbosity::High \};}
\DoxyCodeLine{12482     \}}
\DoxyCodeLine{12483 }
\DoxyCodeLine{12484     \textcolor{keywordtype}{void} TestEventListenerBase::assertionStarting(AssertionInfo \textcolor{keyword}{const} \&) \{\}}
\DoxyCodeLine{12485 }
\DoxyCodeLine{12486     \textcolor{keywordtype}{bool} TestEventListenerBase::assertionEnded(AssertionStats \textcolor{keyword}{const} \&) \{}
\DoxyCodeLine{12487         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12488     \}}
\DoxyCodeLine{12489 }
\DoxyCodeLine{12490 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12491 \textcolor{comment}{// end catch\_reporter\_bases.cpp}}
\DoxyCodeLine{12492 \textcolor{comment}{// start catch\_reporter\_compact.cpp}}
\DoxyCodeLine{12493 }
\DoxyCodeLine{12494 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{12495 }
\DoxyCodeLine{12496 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{12497     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* failedString() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"FAILED"}; \}}
\DoxyCodeLine{12498     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* passedString() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"PASSED"}; \}}
\DoxyCodeLine{12499 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12500     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* failedString() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"failed"}; \}}
\DoxyCodeLine{12501     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* passedString() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"passed"}; \}}
\DoxyCodeLine{12502 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12503 }
\DoxyCodeLine{12504     \textcolor{comment}{// Colour::LightGrey}}
\DoxyCodeLine{12505     Catch::Colour::Code dimColour() \{ \textcolor{keywordflow}{return} Catch::Colour::FileName; \}}
\DoxyCodeLine{12506 }
\DoxyCodeLine{12507     std::string bothOrAll( std::size\_t count ) \{}
\DoxyCodeLine{12508         \textcolor{keywordflow}{return} count == 1 ? std::string() :}
\DoxyCodeLine{12509                count == 2 ? \textcolor{stringliteral}{"both "} : \textcolor{stringliteral}{"all "} ;}
\DoxyCodeLine{12510     \}}
\DoxyCodeLine{12511 }
\DoxyCodeLine{12512 \} \textcolor{comment}{// anon namespace}}
\DoxyCodeLine{12513 }
\DoxyCodeLine{12514 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12515 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{12516 \textcolor{comment}{// Colour, message variants:}}
\DoxyCodeLine{12517 \textcolor{comment}{// - white: No tests ran.}}
\DoxyCodeLine{12518 \textcolor{comment}{// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.}}
\DoxyCodeLine{12519 \textcolor{comment}{// - white: Passed [both/all] N test cases (no assertions).}}
\DoxyCodeLine{12520 \textcolor{comment}{// -   red: Failed N tests cases, failed M assertions.}}
\DoxyCodeLine{12521 \textcolor{comment}{// - green: Passed [both/all] N tests cases with M assertions.}}
\DoxyCodeLine{12522 \textcolor{keywordtype}{void} printTotals(std::ostream\& out, \textcolor{keyword}{const} Totals\& totals) \{}
\DoxyCodeLine{12523     \textcolor{keywordflow}{if} (totals.testCases.total() == 0) \{}
\DoxyCodeLine{12524         out << \textcolor{stringliteral}{"No tests ran."};}
\DoxyCodeLine{12525     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (totals.testCases.failed == totals.testCases.total()) \{}
\DoxyCodeLine{12526         Colour colour(Colour::ResultError);}
\DoxyCodeLine{12527         \textcolor{keyword}{const} std::string qualify\_assertions\_failed =}
\DoxyCodeLine{12528             totals.assertions.failed == totals.assertions.total() ?}
\DoxyCodeLine{12529             bothOrAll(totals.assertions.failed) : std::string();}
\DoxyCodeLine{12530         out <<}
\DoxyCodeLine{12531             \textcolor{stringliteral}{"Failed "} << bothOrAll(totals.testCases.failed)}
\DoxyCodeLine{12532             << pluralise(totals.testCases.failed, \textcolor{stringliteral}{"test case"}) << \textcolor{stringliteral}{", "}}
\DoxyCodeLine{12533             \textcolor{stringliteral}{"failed "} << qualify\_assertions\_failed <<}
\DoxyCodeLine{12534             pluralise(totals.assertions.failed, \textcolor{stringliteral}{"assertion"}) << \textcolor{charliteral}{'.'};}
\DoxyCodeLine{12535     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (totals.assertions.total() == 0) \{}
\DoxyCodeLine{12536         out <<}
\DoxyCodeLine{12537             \textcolor{stringliteral}{"Passed "} << bothOrAll(totals.testCases.total())}
\DoxyCodeLine{12538             << pluralise(totals.testCases.total(), \textcolor{stringliteral}{"test case"})}
\DoxyCodeLine{12539             << \textcolor{stringliteral}{" (no assertions)."};}
\DoxyCodeLine{12540     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (totals.assertions.failed) \{}
\DoxyCodeLine{12541         Colour colour(Colour::ResultError);}
\DoxyCodeLine{12542         out <<}
\DoxyCodeLine{12543             \textcolor{stringliteral}{"Failed "} << pluralise(totals.testCases.failed, \textcolor{stringliteral}{"test case"}) << \textcolor{stringliteral}{", "}}
\DoxyCodeLine{12544             \textcolor{stringliteral}{"failed "} << pluralise(totals.assertions.failed, \textcolor{stringliteral}{"assertion"}) << \textcolor{charliteral}{'.'};}
\DoxyCodeLine{12545     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12546         Colour colour(Colour::ResultSuccess);}
\DoxyCodeLine{12547         out <<}
\DoxyCodeLine{12548             \textcolor{stringliteral}{"Passed "} << bothOrAll(totals.testCases.passed)}
\DoxyCodeLine{12549             << pluralise(totals.testCases.passed, \textcolor{stringliteral}{"test case"}) <<}
\DoxyCodeLine{12550             \textcolor{stringliteral}{" with "} << pluralise(totals.assertions.passed, \textcolor{stringliteral}{"assertion"}) << \textcolor{charliteral}{'.'};}
\DoxyCodeLine{12551     \}}
\DoxyCodeLine{12552 \}}
\DoxyCodeLine{12553 }
\DoxyCodeLine{12554 \textcolor{comment}{// Implementation of CompactReporter formatting}}
\DoxyCodeLine{12555 \textcolor{keyword}{class }AssertionPrinter \{}
\DoxyCodeLine{12556 \textcolor{keyword}{public}:}
\DoxyCodeLine{12557     AssertionPrinter\& operator= (AssertionPrinter \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12558     AssertionPrinter(AssertionPrinter \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12559     AssertionPrinter(std::ostream\& \_stream, AssertionStats \textcolor{keyword}{const}\& \_stats, \textcolor{keywordtype}{bool} \_printInfoMessages)}
\DoxyCodeLine{12560         : stream(\_stream)}
\DoxyCodeLine{12561         , result(\_stats.assertionResult)}
\DoxyCodeLine{12562         , messages(\_stats.infoMessages)}
\DoxyCodeLine{12563         , itMessage(\_stats.infoMessages.begin())}
\DoxyCodeLine{12564         , printInfoMessages(\_printInfoMessages) \{\}}
\DoxyCodeLine{12565 }
\DoxyCodeLine{12566     \textcolor{keywordtype}{void} print() \{}
\DoxyCodeLine{12567         printSourceInfo();}
\DoxyCodeLine{12568 }
\DoxyCodeLine{12569         itMessage = messages.begin();}
\DoxyCodeLine{12570 }
\DoxyCodeLine{12571         \textcolor{keywordflow}{switch} (result.getResultType()) \{}
\DoxyCodeLine{12572         \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{12573             printResultType(Colour::ResultSuccess, passedString());}
\DoxyCodeLine{12574             printOriginalExpression();}
\DoxyCodeLine{12575             printReconstructedExpression();}
\DoxyCodeLine{12576             \textcolor{keywordflow}{if} (!result.hasExpression())}
\DoxyCodeLine{12577                 printRemainingMessages(Colour::None);}
\DoxyCodeLine{12578             \textcolor{keywordflow}{else}}
\DoxyCodeLine{12579                 printRemainingMessages();}
\DoxyCodeLine{12580             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12581         \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{12582             \textcolor{keywordflow}{if} (result.isOk())}
\DoxyCodeLine{12583                 printResultType(Colour::ResultSuccess, failedString() + std::string(" - but was ok"));}
\DoxyCodeLine{12584             \textcolor{keywordflow}{else}}
\DoxyCodeLine{12585                 printResultType(Colour::Error, failedString());}
\DoxyCodeLine{12586             printOriginalExpression();}
\DoxyCodeLine{12587             printReconstructedExpression();}
\DoxyCodeLine{12588             printRemainingMessages();}
\DoxyCodeLine{12589             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12590         \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{12591             printResultType(Colour::Error, failedString());}
\DoxyCodeLine{12592             printIssue(\textcolor{stringliteral}{"unexpected exception with message:"});}
\DoxyCodeLine{12593             printMessage();}
\DoxyCodeLine{12594             printExpressionWas();}
\DoxyCodeLine{12595             printRemainingMessages();}
\DoxyCodeLine{12596             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12597         \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{12598             printResultType(Colour::Error, failedString());}
\DoxyCodeLine{12599             printIssue(\textcolor{stringliteral}{"fatal error condition with message:"});}
\DoxyCodeLine{12600             printMessage();}
\DoxyCodeLine{12601             printExpressionWas();}
\DoxyCodeLine{12602             printRemainingMessages();}
\DoxyCodeLine{12603             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12604         \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{12605             printResultType(Colour::Error, failedString());}
\DoxyCodeLine{12606             printIssue(\textcolor{stringliteral}{"expected exception, got none"});}
\DoxyCodeLine{12607             printExpressionWas();}
\DoxyCodeLine{12608             printRemainingMessages();}
\DoxyCodeLine{12609             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12610         \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{12611             printResultType(Colour::None, \textcolor{stringliteral}{"info"});}
\DoxyCodeLine{12612             printMessage();}
\DoxyCodeLine{12613             printRemainingMessages();}
\DoxyCodeLine{12614             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12615         \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{12616             printResultType(Colour::None, \textcolor{stringliteral}{"warning"});}
\DoxyCodeLine{12617             printMessage();}
\DoxyCodeLine{12618             printRemainingMessages();}
\DoxyCodeLine{12619             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12620         \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{12621             printResultType(Colour::Error, failedString());}
\DoxyCodeLine{12622             printIssue(\textcolor{stringliteral}{"explicitly"});}
\DoxyCodeLine{12623             printRemainingMessages(Colour::None);}
\DoxyCodeLine{12624             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12625             \textcolor{comment}{// These cases are here to prevent compiler warnings}}
\DoxyCodeLine{12626         \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{12627         \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{12628         \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{12629             printResultType(Colour::Error, \textcolor{stringliteral}{"** internal error **"});}
\DoxyCodeLine{12630             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12631         \}}
\DoxyCodeLine{12632     \}}
\DoxyCodeLine{12633 }
\DoxyCodeLine{12634 \textcolor{keyword}{private}:}
\DoxyCodeLine{12635     \textcolor{keywordtype}{void} printSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12636         Colour colourGuard(Colour::FileName);}
\DoxyCodeLine{12637         stream << result.getSourceInfo() << \textcolor{charliteral}{':'};}
\DoxyCodeLine{12638     \}}
\DoxyCodeLine{12639 }
\DoxyCodeLine{12640     \textcolor{keywordtype}{void} printResultType(Colour::Code colour, std::string \textcolor{keyword}{const}\& passOrFail)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12641         \textcolor{keywordflow}{if} (!passOrFail.empty()) \{}
\DoxyCodeLine{12642             \{}
\DoxyCodeLine{12643                 Colour colourGuard(colour);}
\DoxyCodeLine{12644                 stream << \textcolor{charliteral}{' '} << passOrFail;}
\DoxyCodeLine{12645             \}}
\DoxyCodeLine{12646             stream << \textcolor{charliteral}{':'};}
\DoxyCodeLine{12647         \}}
\DoxyCodeLine{12648     \}}
\DoxyCodeLine{12649 }
\DoxyCodeLine{12650     \textcolor{keywordtype}{void} printIssue(std::string \textcolor{keyword}{const}\& issue)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12651         stream << \textcolor{charliteral}{' '} << issue;}
\DoxyCodeLine{12652     \}}
\DoxyCodeLine{12653 }
\DoxyCodeLine{12654     \textcolor{keywordtype}{void} printExpressionWas() \{}
\DoxyCodeLine{12655         \textcolor{keywordflow}{if} (result.hasExpression()) \{}
\DoxyCodeLine{12656             stream << \textcolor{charliteral}{';'};}
\DoxyCodeLine{12657             \{}
\DoxyCodeLine{12658                 Colour colour(dimColour());}
\DoxyCodeLine{12659                 stream << \textcolor{stringliteral}{" expression was:"};}
\DoxyCodeLine{12660             \}}
\DoxyCodeLine{12661             printOriginalExpression();}
\DoxyCodeLine{12662         \}}
\DoxyCodeLine{12663     \}}
\DoxyCodeLine{12664 }
\DoxyCodeLine{12665     \textcolor{keywordtype}{void} printOriginalExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12666         \textcolor{keywordflow}{if} (result.hasExpression()) \{}
\DoxyCodeLine{12667             stream << \textcolor{charliteral}{' '} << result.getExpression();}
\DoxyCodeLine{12668         \}}
\DoxyCodeLine{12669     \}}
\DoxyCodeLine{12670 }
\DoxyCodeLine{12671     \textcolor{keywordtype}{void} printReconstructedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12672         \textcolor{keywordflow}{if} (result.hasExpandedExpression()) \{}
\DoxyCodeLine{12673             \{}
\DoxyCodeLine{12674                 Colour colour(dimColour());}
\DoxyCodeLine{12675                 stream << \textcolor{stringliteral}{" for: "};}
\DoxyCodeLine{12676             \}}
\DoxyCodeLine{12677             stream << result.getExpandedExpression();}
\DoxyCodeLine{12678         \}}
\DoxyCodeLine{12679     \}}
\DoxyCodeLine{12680 }
\DoxyCodeLine{12681     \textcolor{keywordtype}{void} printMessage() \{}
\DoxyCodeLine{12682         \textcolor{keywordflow}{if} (itMessage != messages.end()) \{}
\DoxyCodeLine{12683             stream << \textcolor{stringliteral}{" '"} << itMessage->message << \textcolor{charliteral}{'\(\backslash\)''};}
\DoxyCodeLine{12684             ++itMessage;}
\DoxyCodeLine{12685         \}}
\DoxyCodeLine{12686     \}}
\DoxyCodeLine{12687 }
\DoxyCodeLine{12688     \textcolor{keywordtype}{void} printRemainingMessages(Colour::Code colour = dimColour()) \{}
\DoxyCodeLine{12689         \textcolor{keywordflow}{if} (itMessage == messages.end())}
\DoxyCodeLine{12690             \textcolor{keywordflow}{return};}
\DoxyCodeLine{12691 }
\DoxyCodeLine{12692         \textcolor{comment}{// using messages.end() directly yields (or auto) compilation error:}}
\DoxyCodeLine{12693         std::vector<MessageInfo>::const\_iterator itEnd = messages.end();}
\DoxyCodeLine{12694         \textcolor{keyword}{const} std::size\_t N = static\_cast<std::size\_t>(std::distance(itMessage, itEnd));}
\DoxyCodeLine{12695 }
\DoxyCodeLine{12696         \{}
\DoxyCodeLine{12697             Colour colourGuard(colour);}
\DoxyCodeLine{12698             stream << \textcolor{stringliteral}{" with "} << pluralise(N, \textcolor{stringliteral}{"message"}) << \textcolor{charliteral}{':'};}
\DoxyCodeLine{12699         \}}
\DoxyCodeLine{12700 }
\DoxyCodeLine{12701         \textcolor{keywordflow}{for} (; itMessage != itEnd; ) \{}
\DoxyCodeLine{12702             \textcolor{comment}{// If this assertion is a warning ignore any INFO messages}}
\DoxyCodeLine{12703             \textcolor{keywordflow}{if} (printInfoMessages || itMessage->type != ResultWas::Info) \{}
\DoxyCodeLine{12704                 stream << \textcolor{stringliteral}{" '"} << itMessage->message << \textcolor{charliteral}{'\(\backslash\)''};}
\DoxyCodeLine{12705                 \textcolor{keywordflow}{if} (++itMessage != itEnd) \{}
\DoxyCodeLine{12706                     Colour colourGuard(dimColour());}
\DoxyCodeLine{12707                     stream << \textcolor{stringliteral}{" and"};}
\DoxyCodeLine{12708                 \}}
\DoxyCodeLine{12709             \}}
\DoxyCodeLine{12710         \}}
\DoxyCodeLine{12711     \}}
\DoxyCodeLine{12712 }
\DoxyCodeLine{12713 \textcolor{keyword}{private}:}
\DoxyCodeLine{12714     std::ostream\& stream;}
\DoxyCodeLine{12715     AssertionResult \textcolor{keyword}{const}\& result;}
\DoxyCodeLine{12716     std::vector<MessageInfo> messages;}
\DoxyCodeLine{12717     std::vector<MessageInfo>::const\_iterator itMessage;}
\DoxyCodeLine{12718     \textcolor{keywordtype}{bool} printInfoMessages;}
\DoxyCodeLine{12719 \};}
\DoxyCodeLine{12720 }
\DoxyCodeLine{12721 \} \textcolor{comment}{// anon namespace}}
\DoxyCodeLine{12722 }
\DoxyCodeLine{12723         std::string CompactReporter::getDescription() \{}
\DoxyCodeLine{12724             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Reports test results on a single line, suitable for IDEs"};}
\DoxyCodeLine{12725         \}}
\DoxyCodeLine{12726 }
\DoxyCodeLine{12727         ReporterPreferences CompactReporter::getPreferences()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12728             \textcolor{keywordflow}{return} m\_reporterPrefs;}
\DoxyCodeLine{12729         \}}
\DoxyCodeLine{12730 }
\DoxyCodeLine{12731         \textcolor{keywordtype}{void} CompactReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) \{}
\DoxyCodeLine{12732             stream << \textcolor{stringliteral}{"No test cases matched '"} << spec << \textcolor{charliteral}{'\(\backslash\)''} << std::endl;}
\DoxyCodeLine{12733         \}}
\DoxyCodeLine{12734 }
\DoxyCodeLine{12735         \textcolor{keywordtype}{void} CompactReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{12736 }
\DoxyCodeLine{12737         \textcolor{keywordtype}{bool} CompactReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& \_assertionStats ) \{}
\DoxyCodeLine{12738             AssertionResult \textcolor{keyword}{const}\& result = \_assertionStats.assertionResult;}
\DoxyCodeLine{12739 }
\DoxyCodeLine{12740             \textcolor{keywordtype}{bool} printInfoMessages = \textcolor{keyword}{true};}
\DoxyCodeLine{12741 }
\DoxyCodeLine{12742             \textcolor{comment}{// Drop out if result was successful and we're not printing those}}
\DoxyCodeLine{12743             \textcolor{keywordflow}{if}( !m\_config->includeSuccessfulResults() \&\& result.isOk() ) \{}
\DoxyCodeLine{12744                 \textcolor{keywordflow}{if}( result.getResultType() != ResultWas::Warning )}
\DoxyCodeLine{12745                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12746                 printInfoMessages = \textcolor{keyword}{false};}
\DoxyCodeLine{12747             \}}
\DoxyCodeLine{12748 }
\DoxyCodeLine{12749             AssertionPrinter printer( stream, \_assertionStats, printInfoMessages );}
\DoxyCodeLine{12750             printer.print();}
\DoxyCodeLine{12751 }
\DoxyCodeLine{12752             stream << std::endl;}
\DoxyCodeLine{12753             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12754         \}}
\DoxyCodeLine{12755 }
\DoxyCodeLine{12756         \textcolor{keywordtype}{void} CompactReporter::sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \{}
\DoxyCodeLine{12757             \textcolor{keywordflow}{if} (m\_config->showDurations() == ShowDurations::Always) \{}
\DoxyCodeLine{12758                 stream << getFormattedDuration(\_sectionStats.durationInSeconds) << \textcolor{stringliteral}{" s: "} << \_sectionStats.sectionInfo.name << std::endl;}
\DoxyCodeLine{12759             \}}
\DoxyCodeLine{12760         \}}
\DoxyCodeLine{12761 }
\DoxyCodeLine{12762         \textcolor{keywordtype}{void} CompactReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& \_testRunStats ) \{}
\DoxyCodeLine{12763             printTotals( stream, \_testRunStats.totals );}
\DoxyCodeLine{12764             stream << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{12765             StreamingReporterBase::testRunEnded( \_testRunStats );}
\DoxyCodeLine{12766         \}}
\DoxyCodeLine{12767 }
\DoxyCodeLine{12768         CompactReporter::~CompactReporter() \{\}}
\DoxyCodeLine{12769 }
\DoxyCodeLine{12770     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"compact"}, CompactReporter )}
\DoxyCodeLine{12771 }
\DoxyCodeLine{12772 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12773 \textcolor{comment}{// end catch\_reporter\_compact.cpp}}
\DoxyCodeLine{12774 \textcolor{comment}{// start catch\_reporter\_console.cpp}}
\DoxyCodeLine{12775 }
\DoxyCodeLine{12776 \textcolor{preprocessor}{\#include <cfloat>}}
\DoxyCodeLine{12777 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{12778 }
\DoxyCodeLine{12779 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12780 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{12781 \textcolor{preprocessor}{\#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{12782  \textcolor{comment}{// Note that 4062 (not all labels are handled}}
\DoxyCodeLine{12783  \textcolor{comment}{// and default is missing) is enabled}}
\DoxyCodeLine{12784 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12785 }
\DoxyCodeLine{12786 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12787 }
\DoxyCodeLine{12788 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{12789 }
\DoxyCodeLine{12790 \textcolor{comment}{// Formatter impl for ConsoleReporter}}
\DoxyCodeLine{12791 \textcolor{keyword}{class }ConsoleAssertionPrinter \{}
\DoxyCodeLine{12792 \textcolor{keyword}{public}:}
\DoxyCodeLine{12793     ConsoleAssertionPrinter\& operator= (ConsoleAssertionPrinter \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12794     ConsoleAssertionPrinter(ConsoleAssertionPrinter \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12795     ConsoleAssertionPrinter(std::ostream\& \_stream, AssertionStats \textcolor{keyword}{const}\& \_stats, \textcolor{keywordtype}{bool} \_printInfoMessages)}
\DoxyCodeLine{12796         : stream(\_stream),}
\DoxyCodeLine{12797         stats(\_stats),}
\DoxyCodeLine{12798         result(\_stats.assertionResult),}
\DoxyCodeLine{12799         colour(Colour::None),}
\DoxyCodeLine{12800         message(result.getMessage()),}
\DoxyCodeLine{12801         messages(\_stats.infoMessages),}
\DoxyCodeLine{12802         printInfoMessages(\_printInfoMessages) \{}
\DoxyCodeLine{12803         \textcolor{keywordflow}{switch} (result.getResultType()) \{}
\DoxyCodeLine{12804         \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{12805             colour = Colour::Success;}
\DoxyCodeLine{12806             passOrFail = \textcolor{stringliteral}{"PASSED"};}
\DoxyCodeLine{12807             \textcolor{comment}{//if( result.hasMessage() )}}
\DoxyCodeLine{12808             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{12809                 messageLabel = \textcolor{stringliteral}{"with message"};}
\DoxyCodeLine{12810             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{12811                 messageLabel = \textcolor{stringliteral}{"with messages"};}
\DoxyCodeLine{12812             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12813         \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{12814             \textcolor{keywordflow}{if} (result.isOk()) \{}
\DoxyCodeLine{12815                 colour = Colour::Success;}
\DoxyCodeLine{12816                 passOrFail = \textcolor{stringliteral}{"FAILED - but was ok"};}
\DoxyCodeLine{12817             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12818                 colour = Colour::Error;}
\DoxyCodeLine{12819                 passOrFail = \textcolor{stringliteral}{"FAILED"};}
\DoxyCodeLine{12820             \}}
\DoxyCodeLine{12821             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{12822                 messageLabel = \textcolor{stringliteral}{"with message"};}
\DoxyCodeLine{12823             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{12824                 messageLabel = \textcolor{stringliteral}{"with messages"};}
\DoxyCodeLine{12825             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12826         \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{12827             colour = Colour::Error;}
\DoxyCodeLine{12828             passOrFail = \textcolor{stringliteral}{"FAILED"};}
\DoxyCodeLine{12829             messageLabel = \textcolor{stringliteral}{"due to unexpected exception with "};}
\DoxyCodeLine{12830             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{12831                 messageLabel += \textcolor{stringliteral}{"message"};}
\DoxyCodeLine{12832             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{12833                 messageLabel += \textcolor{stringliteral}{"messages"};}
\DoxyCodeLine{12834             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12835         \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{12836             colour = Colour::Error;}
\DoxyCodeLine{12837             passOrFail = \textcolor{stringliteral}{"FAILED"};}
\DoxyCodeLine{12838             messageLabel = \textcolor{stringliteral}{"due to a fatal error condition"};}
\DoxyCodeLine{12839             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12840         \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{12841             colour = Colour::Error;}
\DoxyCodeLine{12842             passOrFail = \textcolor{stringliteral}{"FAILED"};}
\DoxyCodeLine{12843             messageLabel = \textcolor{stringliteral}{"because no exception was thrown where one was expected"};}
\DoxyCodeLine{12844             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12845         \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{12846             messageLabel = \textcolor{stringliteral}{"info"};}
\DoxyCodeLine{12847             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12848         \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{12849             messageLabel = \textcolor{stringliteral}{"warning"};}
\DoxyCodeLine{12850             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12851         \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{12852             passOrFail = \textcolor{stringliteral}{"FAILED"};}
\DoxyCodeLine{12853             colour = Colour::Error;}
\DoxyCodeLine{12854             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{12855                 messageLabel = \textcolor{stringliteral}{"explicitly with message"};}
\DoxyCodeLine{12856             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{12857                 messageLabel = \textcolor{stringliteral}{"explicitly with messages"};}
\DoxyCodeLine{12858             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12859             \textcolor{comment}{// These cases are here to prevent compiler warnings}}
\DoxyCodeLine{12860         \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{12861         \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{12862         \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{12863             passOrFail = \textcolor{stringliteral}{"** internal error **"};}
\DoxyCodeLine{12864             colour = Colour::Error;}
\DoxyCodeLine{12865             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12866         \}}
\DoxyCodeLine{12867     \}}
\DoxyCodeLine{12868 }
\DoxyCodeLine{12869     \textcolor{keywordtype}{void} print()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12870         printSourceInfo();}
\DoxyCodeLine{12871         \textcolor{keywordflow}{if} (stats.totals.assertions.total() > 0) \{}
\DoxyCodeLine{12872             printResultType();}
\DoxyCodeLine{12873             printOriginalExpression();}
\DoxyCodeLine{12874             printReconstructedExpression();}
\DoxyCodeLine{12875         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12876             stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{12877         \}}
\DoxyCodeLine{12878         printMessage();}
\DoxyCodeLine{12879     \}}
\DoxyCodeLine{12880 }
\DoxyCodeLine{12881 \textcolor{keyword}{private}:}
\DoxyCodeLine{12882     \textcolor{keywordtype}{void} printResultType()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12883         \textcolor{keywordflow}{if} (!passOrFail.empty()) \{}
\DoxyCodeLine{12884             Colour colourGuard(colour);}
\DoxyCodeLine{12885             stream << passOrFail << \textcolor{stringliteral}{":\(\backslash\)n"};}
\DoxyCodeLine{12886         \}}
\DoxyCodeLine{12887     \}}
\DoxyCodeLine{12888     \textcolor{keywordtype}{void} printOriginalExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12889         \textcolor{keywordflow}{if} (result.hasExpression()) \{}
\DoxyCodeLine{12890             Colour colourGuard(Colour::OriginalExpression);}
\DoxyCodeLine{12891             stream << \textcolor{stringliteral}{"  "};}
\DoxyCodeLine{12892             stream << result.getExpressionInMacro();}
\DoxyCodeLine{12893             stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{12894         \}}
\DoxyCodeLine{12895     \}}
\DoxyCodeLine{12896     \textcolor{keywordtype}{void} printReconstructedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12897         \textcolor{keywordflow}{if} (result.hasExpandedExpression()) \{}
\DoxyCodeLine{12898             stream << \textcolor{stringliteral}{"with expansion:\(\backslash\)n"};}
\DoxyCodeLine{12899             Colour colourGuard(Colour::ReconstructedExpression);}
\DoxyCodeLine{12900             stream << Column(result.getExpandedExpression()).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{12901         \}}
\DoxyCodeLine{12902     \}}
\DoxyCodeLine{12903     \textcolor{keywordtype}{void} printMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12904         \textcolor{keywordflow}{if} (!messageLabel.empty())}
\DoxyCodeLine{12905             stream << messageLabel << \textcolor{charliteral}{':'} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{12906         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : messages) \{}
\DoxyCodeLine{12907             \textcolor{comment}{// If this assertion is a warning ignore any INFO messages}}
\DoxyCodeLine{12908             \textcolor{keywordflow}{if} (printInfoMessages || msg.type != ResultWas::Info)}
\DoxyCodeLine{12909                 stream << Column(msg.message).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{12910         \}}
\DoxyCodeLine{12911     \}}
\DoxyCodeLine{12912     \textcolor{keywordtype}{void} printSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12913         Colour colourGuard(Colour::FileName);}
\DoxyCodeLine{12914         stream << result.getSourceInfo() << \textcolor{stringliteral}{": "};}
\DoxyCodeLine{12915     \}}
\DoxyCodeLine{12916 }
\DoxyCodeLine{12917     std::ostream\& stream;}
\DoxyCodeLine{12918     AssertionStats \textcolor{keyword}{const}\& stats;}
\DoxyCodeLine{12919     AssertionResult \textcolor{keyword}{const}\& result;}
\DoxyCodeLine{12920     Colour::Code colour;}
\DoxyCodeLine{12921     std::string passOrFail;}
\DoxyCodeLine{12922     std::string messageLabel;}
\DoxyCodeLine{12923     std::string message;}
\DoxyCodeLine{12924     std::vector<MessageInfo> messages;}
\DoxyCodeLine{12925     \textcolor{keywordtype}{bool} printInfoMessages;}
\DoxyCodeLine{12926 \};}
\DoxyCodeLine{12927 }
\DoxyCodeLine{12928 std::size\_t makeRatio(std::size\_t number, std::size\_t total) \{}
\DoxyCodeLine{12929     std::size\_t ratio = total > 0 ? CATCH\_CONFIG\_CONSOLE\_WIDTH * number / total : 0;}
\DoxyCodeLine{12930     \textcolor{keywordflow}{return} (ratio == 0 \&\& number > 0) ? 1 : ratio;}
\DoxyCodeLine{12931 \}}
\DoxyCodeLine{12932 }
\DoxyCodeLine{12933 std::size\_t\& findMax(std::size\_t\& i, std::size\_t\& j, std::size\_t\& k) \{}
\DoxyCodeLine{12934     \textcolor{keywordflow}{if} (i > j \&\& i > k)}
\DoxyCodeLine{12935         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{12936     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j > k)}
\DoxyCodeLine{12937         \textcolor{keywordflow}{return} j;}
\DoxyCodeLine{12938     \textcolor{keywordflow}{else}}
\DoxyCodeLine{12939         \textcolor{keywordflow}{return} k;}
\DoxyCodeLine{12940 \}}
\DoxyCodeLine{12941 }
\DoxyCodeLine{12942 \textcolor{keyword}{struct }ColumnInfo \{}
\DoxyCodeLine{12943     \textcolor{keyword}{enum} Justification \{ Left, Right \};}
\DoxyCodeLine{12944     std::string name;}
\DoxyCodeLine{12945     \textcolor{keywordtype}{int} width;}
\DoxyCodeLine{12946     Justification justification;}
\DoxyCodeLine{12947 \};}
\DoxyCodeLine{12948 \textcolor{keyword}{struct }ColumnBreak \{\};}
\DoxyCodeLine{12949 \textcolor{keyword}{struct }RowBreak \{\};}
\DoxyCodeLine{12950 }
\DoxyCodeLine{12951 \textcolor{keyword}{class }Duration \{}
\DoxyCodeLine{12952     \textcolor{keyword}{enum class} Unit \{}
\DoxyCodeLine{12953         Auto,}
\DoxyCodeLine{12954         Nanoseconds,}
\DoxyCodeLine{12955         Microseconds,}
\DoxyCodeLine{12956         Milliseconds,}
\DoxyCodeLine{12957         Seconds,}
\DoxyCodeLine{12958         Minutes}
\DoxyCodeLine{12959     \};}
\DoxyCodeLine{12960     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMicrosecond = 1000;}
\DoxyCodeLine{12961     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMillisecond = 1000 * s\_nanosecondsInAMicrosecond;}
\DoxyCodeLine{12962     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInASecond = 1000 * s\_nanosecondsInAMillisecond;}
\DoxyCodeLine{12963     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMinute = 60 * s\_nanosecondsInASecond;}
\DoxyCodeLine{12964 }
\DoxyCodeLine{12965     uint64\_t m\_inNanoseconds;}
\DoxyCodeLine{12966     Unit m\_units;}
\DoxyCodeLine{12967 }
\DoxyCodeLine{12968 \textcolor{keyword}{public}:}
\DoxyCodeLine{12969     \textcolor{keyword}{explicit} Duration(uint64\_t inNanoseconds, Unit units = Unit::Auto)}
\DoxyCodeLine{12970         : m\_inNanoseconds(inNanoseconds),}
\DoxyCodeLine{12971         m\_units(units) \{}
\DoxyCodeLine{12972         \textcolor{keywordflow}{if} (m\_units == Unit::Auto) \{}
\DoxyCodeLine{12973             \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMicrosecond)}
\DoxyCodeLine{12974                 m\_units = Unit::Nanoseconds;}
\DoxyCodeLine{12975             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMillisecond)}
\DoxyCodeLine{12976                 m\_units = Unit::Microseconds;}
\DoxyCodeLine{12977             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInASecond)}
\DoxyCodeLine{12978                 m\_units = Unit::Milliseconds;}
\DoxyCodeLine{12979             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMinute)}
\DoxyCodeLine{12980                 m\_units = Unit::Seconds;}
\DoxyCodeLine{12981             \textcolor{keywordflow}{else}}
\DoxyCodeLine{12982                 m\_units = Unit::Minutes;}
\DoxyCodeLine{12983         \}}
\DoxyCodeLine{12984 }
\DoxyCodeLine{12985     \}}
\DoxyCodeLine{12986 }
\DoxyCodeLine{12987     \textcolor{keyword}{auto} value() const -> \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{12988         \textcolor{keywordflow}{switch} (m\_units) \{}
\DoxyCodeLine{12989         \textcolor{keywordflow}{case} Unit::Microseconds:}
\DoxyCodeLine{12990             \textcolor{keywordflow}{return} m\_inNanoseconds / static\_cast<double>(s\_nanosecondsInAMicrosecond);}
\DoxyCodeLine{12991         \textcolor{keywordflow}{case} Unit::Milliseconds:}
\DoxyCodeLine{12992             \textcolor{keywordflow}{return} m\_inNanoseconds / static\_cast<double>(s\_nanosecondsInAMillisecond);}
\DoxyCodeLine{12993         \textcolor{keywordflow}{case} Unit::Seconds:}
\DoxyCodeLine{12994             \textcolor{keywordflow}{return} m\_inNanoseconds / static\_cast<double>(s\_nanosecondsInASecond);}
\DoxyCodeLine{12995         \textcolor{keywordflow}{case} Unit::Minutes:}
\DoxyCodeLine{12996             \textcolor{keywordflow}{return} m\_inNanoseconds / static\_cast<double>(s\_nanosecondsInAMinute);}
\DoxyCodeLine{12997         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{12998             \textcolor{keywordflow}{return} static\_cast<double>(m\_inNanoseconds);}
\DoxyCodeLine{12999         \}}
\DoxyCodeLine{13000     \}}
\DoxyCodeLine{13001     \textcolor{keyword}{auto} unitsAsString() const -> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{13002         \textcolor{keywordflow}{switch} (m\_units) \{}
\DoxyCodeLine{13003         \textcolor{keywordflow}{case} Unit::Nanoseconds:}
\DoxyCodeLine{13004             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"ns"};}
\DoxyCodeLine{13005         \textcolor{keywordflow}{case} Unit::Microseconds:}
\DoxyCodeLine{13006             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"s"};}
\DoxyCodeLine{13007         \textcolor{keywordflow}{case} Unit::Milliseconds:}
\DoxyCodeLine{13008             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"ms"};}
\DoxyCodeLine{13009         \textcolor{keywordflow}{case} Unit::Seconds:}
\DoxyCodeLine{13010             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"s"};}
\DoxyCodeLine{13011         \textcolor{keywordflow}{case} Unit::Minutes:}
\DoxyCodeLine{13012             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"m"};}
\DoxyCodeLine{13013         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13014             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"** internal error **"};}
\DoxyCodeLine{13015         \}}
\DoxyCodeLine{13016 }
\DoxyCodeLine{13017     \}}
\DoxyCodeLine{13018     \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator << (std::ostream\& os, Duration \textcolor{keyword}{const}\& duration) -> std::ostream\& \{}
\DoxyCodeLine{13019         \textcolor{keywordflow}{return} os << duration.value() << \textcolor{stringliteral}{" "} << duration.unitsAsString();}
\DoxyCodeLine{13020     \}}
\DoxyCodeLine{13021 \};}
\DoxyCodeLine{13022 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{13023 }
\DoxyCodeLine{13024 \textcolor{keyword}{class }TablePrinter \{}
\DoxyCodeLine{13025     std::ostream\& m\_os;}
\DoxyCodeLine{13026     std::vector<ColumnInfo> m\_columnInfos;}
\DoxyCodeLine{13027     std::ostringstream m\_oss;}
\DoxyCodeLine{13028     \textcolor{keywordtype}{int} m\_currentColumn = -1;}
\DoxyCodeLine{13029     \textcolor{keywordtype}{bool} m\_isOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{13030 }
\DoxyCodeLine{13031 \textcolor{keyword}{public}:}
\DoxyCodeLine{13032     TablePrinter( std::ostream\& os, std::vector<ColumnInfo> columnInfos )}
\DoxyCodeLine{13033     :   m\_os( os ),}
\DoxyCodeLine{13034         m\_columnInfos( std::move( columnInfos ) ) \{\}}
\DoxyCodeLine{13035 }
\DoxyCodeLine{13036     \textcolor{keyword}{auto} columnInfos() const -> std::vector<ColumnInfo> const\& \{}
\DoxyCodeLine{13037         \textcolor{keywordflow}{return} m\_columnInfos;}
\DoxyCodeLine{13038     \}}
\DoxyCodeLine{13039 }
\DoxyCodeLine{13040     \textcolor{keywordtype}{void} open() \{}
\DoxyCodeLine{13041         \textcolor{keywordflow}{if} (!m\_isOpen) \{}
\DoxyCodeLine{13042             m\_isOpen = \textcolor{keyword}{true};}
\DoxyCodeLine{13043             *\textcolor{keyword}{this} << RowBreak();}
\DoxyCodeLine{13044             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& info : m\_columnInfos)}
\DoxyCodeLine{13045                 *\textcolor{keyword}{this} << info.name << ColumnBreak();}
\DoxyCodeLine{13046             *\textcolor{keyword}{this} << RowBreak();}
\DoxyCodeLine{13047             m\_os << Catch::getLineOfChars<\textcolor{charliteral}{'-'}>() << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{13048         \}}
\DoxyCodeLine{13049     \}}
\DoxyCodeLine{13050     \textcolor{keywordtype}{void} close() \{}
\DoxyCodeLine{13051         \textcolor{keywordflow}{if} (m\_isOpen) \{}
\DoxyCodeLine{13052             *\textcolor{keyword}{this} << RowBreak();}
\DoxyCodeLine{13053             m\_os << std::endl;}
\DoxyCodeLine{13054             m\_isOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{13055         \}}
\DoxyCodeLine{13056     \}}
\DoxyCodeLine{13057 }
\DoxyCodeLine{13058     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{13059     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, T \textcolor{keyword}{const}\& value) \{}
\DoxyCodeLine{13060         tp.m\_oss << value;}
\DoxyCodeLine{13061         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{13062     \}}
\DoxyCodeLine{13063 }
\DoxyCodeLine{13064     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, ColumnBreak) \{}
\DoxyCodeLine{13065         \textcolor{keyword}{auto} colStr = tp.m\_oss.str();}
\DoxyCodeLine{13066         \textcolor{comment}{// This takes account of utf8 encodings}}
\DoxyCodeLine{13067         \textcolor{keyword}{auto} strSize = \mbox{\hyperlink{classCatch_1_1StringRef}{Catch::StringRef}}(colStr).numberOfCharacters();}
\DoxyCodeLine{13068         tp.m\_oss.str(\textcolor{stringliteral}{""});}
\DoxyCodeLine{13069         tp.open();}
\DoxyCodeLine{13070         \textcolor{keywordflow}{if} (tp.m\_currentColumn == static\_cast<int>(tp.m\_columnInfos.size() - 1)) \{}
\DoxyCodeLine{13071             tp.m\_currentColumn = -1;}
\DoxyCodeLine{13072             tp.m\_os << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{13073         \}}
\DoxyCodeLine{13074         tp.m\_currentColumn++;}
\DoxyCodeLine{13075 }
\DoxyCodeLine{13076         \textcolor{keyword}{auto} colInfo = tp.m\_columnInfos[tp.m\_currentColumn];}
\DoxyCodeLine{13077         \textcolor{keyword}{auto} padding = (strSize + 2 < static\_cast<std::size\_t>(colInfo.width))}
\DoxyCodeLine{13078             ? std::string(colInfo.width - (strSize + 2), ' ')}
\DoxyCodeLine{13079             : std::string();}
\DoxyCodeLine{13080         \textcolor{keywordflow}{if} (colInfo.justification == ColumnInfo::Left)}
\DoxyCodeLine{13081             tp.m\_os << colStr << padding << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{13082         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13083             tp.m\_os << padding << colStr << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{13084         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{13085     \}}
\DoxyCodeLine{13086 }
\DoxyCodeLine{13087     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, RowBreak) \{}
\DoxyCodeLine{13088         \textcolor{keywordflow}{if} (tp.m\_currentColumn > 0) \{}
\DoxyCodeLine{13089             tp.m\_os << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{13090             tp.m\_currentColumn = -1;}
\DoxyCodeLine{13091         \}}
\DoxyCodeLine{13092         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{13093     \}}
\DoxyCodeLine{13094 \};}
\DoxyCodeLine{13095 }
\DoxyCodeLine{13096 ConsoleReporter::ConsoleReporter(ReporterConfig \textcolor{keyword}{const}\& config)}
\DoxyCodeLine{13097     : StreamingReporterBase(config),}
\DoxyCodeLine{13098     m\_tablePrinter(new TablePrinter(config.stream(),}
\DoxyCodeLine{13099     \{}
\DoxyCodeLine{13100         \{ \textcolor{stringliteral}{"benchmark name"}, CATCH\_CONFIG\_CONSOLE\_WIDTH - 32, ColumnInfo::Left \},}
\DoxyCodeLine{13101         \{ \textcolor{stringliteral}{"iters"}, 8, ColumnInfo::Right \},}
\DoxyCodeLine{13102         \{ \textcolor{stringliteral}{"elapsed ns"}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{13103         \{ \textcolor{stringliteral}{"average"}, 14, ColumnInfo::Right \}}
\DoxyCodeLine{13104     \})) \{\}}
\DoxyCodeLine{13105 ConsoleReporter::~ConsoleReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13106 }
\DoxyCodeLine{13107 std::string ConsoleReporter::getDescription() \{}
\DoxyCodeLine{13108     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Reports test results as plain lines of text"};}
\DoxyCodeLine{13109 \}}
\DoxyCodeLine{13110 }
\DoxyCodeLine{13111 \textcolor{keywordtype}{void} ConsoleReporter::noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \{}
\DoxyCodeLine{13112     stream << \textcolor{stringliteral}{"No test cases matched '"} << spec << \textcolor{charliteral}{'\(\backslash\)''} << std::endl;}
\DoxyCodeLine{13113 \}}
\DoxyCodeLine{13114 }
\DoxyCodeLine{13115 \textcolor{keywordtype}{void} ConsoleReporter::assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \{\}}
\DoxyCodeLine{13116 }
\DoxyCodeLine{13117 \textcolor{keywordtype}{bool} ConsoleReporter::assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \{}
\DoxyCodeLine{13118     AssertionResult \textcolor{keyword}{const}\& result = \_assertionStats.assertionResult;}
\DoxyCodeLine{13119 }
\DoxyCodeLine{13120     \textcolor{keywordtype}{bool} includeResults = m\_config->includeSuccessfulResults() || !result.isOk();}
\DoxyCodeLine{13121 }
\DoxyCodeLine{13122     \textcolor{comment}{// Drop out if result was successful but we're not printing them.}}
\DoxyCodeLine{13123     \textcolor{keywordflow}{if} (!includeResults \&\& result.getResultType() != ResultWas::Warning)}
\DoxyCodeLine{13124         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{13125 }
\DoxyCodeLine{13126     lazyPrint();}
\DoxyCodeLine{13127 }
\DoxyCodeLine{13128     ConsoleAssertionPrinter printer(stream, \_assertionStats, includeResults);}
\DoxyCodeLine{13129     printer.print();}
\DoxyCodeLine{13130     stream << std::endl;}
\DoxyCodeLine{13131     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{13132 \}}
\DoxyCodeLine{13133 }
\DoxyCodeLine{13134 \textcolor{keywordtype}{void} ConsoleReporter::sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo) \{}
\DoxyCodeLine{13135     m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{13136     StreamingReporterBase::sectionStarting(\_sectionInfo);}
\DoxyCodeLine{13137 \}}
\DoxyCodeLine{13138 \textcolor{keywordtype}{void} ConsoleReporter::sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \{}
\DoxyCodeLine{13139     m\_tablePrinter->close();}
\DoxyCodeLine{13140     \textcolor{keywordflow}{if} (\_sectionStats.missingAssertions) \{}
\DoxyCodeLine{13141         lazyPrint();}
\DoxyCodeLine{13142         Colour colour(Colour::ResultError);}
\DoxyCodeLine{13143         \textcolor{keywordflow}{if} (m\_sectionStack.size() > 1)}
\DoxyCodeLine{13144             stream << \textcolor{stringliteral}{"\(\backslash\)nNo assertions in section"};}
\DoxyCodeLine{13145         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13146             stream << \textcolor{stringliteral}{"\(\backslash\)nNo assertions in test case"};}
\DoxyCodeLine{13147         stream << \textcolor{stringliteral}{" '"} << \_sectionStats.sectionInfo.name << \textcolor{stringliteral}{"'\(\backslash\)n"} << std::endl;}
\DoxyCodeLine{13148     \}}
\DoxyCodeLine{13149     \textcolor{keywordflow}{if} (m\_config->showDurations() == ShowDurations::Always) \{}
\DoxyCodeLine{13150         stream << getFormattedDuration(\_sectionStats.durationInSeconds) << \textcolor{stringliteral}{" s: "} << \_sectionStats.sectionInfo.name << std::endl;}
\DoxyCodeLine{13151     \}}
\DoxyCodeLine{13152     \textcolor{keywordflow}{if} (m\_headerPrinted) \{}
\DoxyCodeLine{13153         m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{13154     \}}
\DoxyCodeLine{13155     StreamingReporterBase::sectionEnded(\_sectionStats);}
\DoxyCodeLine{13156 \}}
\DoxyCodeLine{13157 }
\DoxyCodeLine{13158 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const}\& info) \{}
\DoxyCodeLine{13159     lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{13160 }
\DoxyCodeLine{13161     \textcolor{keyword}{auto} nameCol = Column( info.name ).width( static\_cast<std::size\_t>( m\_tablePrinter->columnInfos()[0].width - 2 ) );}
\DoxyCodeLine{13162 }
\DoxyCodeLine{13163     \textcolor{keywordtype}{bool} firstLine = \textcolor{keyword}{true};}
\DoxyCodeLine{13164     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : nameCol) \{}
\DoxyCodeLine{13165         \textcolor{keywordflow}{if} (!firstLine)}
\DoxyCodeLine{13166             (*m\_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();}
\DoxyCodeLine{13167         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13168             firstLine = \textcolor{keyword}{false};}
\DoxyCodeLine{13169 }
\DoxyCodeLine{13170         (*m\_tablePrinter) << line << ColumnBreak();}
\DoxyCodeLine{13171     \}}
\DoxyCodeLine{13172 \}}
\DoxyCodeLine{13173 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkEnded(BenchmarkStats \textcolor{keyword}{const}\& stats) \{}
\DoxyCodeLine{13174     Duration average(stats.elapsedTimeInNanoseconds / stats.iterations);}
\DoxyCodeLine{13175     (*m\_tablePrinter)}
\DoxyCodeLine{13176         << stats.iterations << ColumnBreak()}
\DoxyCodeLine{13177         << stats.elapsedTimeInNanoseconds << ColumnBreak()}
\DoxyCodeLine{13178         << average << ColumnBreak();}
\DoxyCodeLine{13179 \}}
\DoxyCodeLine{13180 }
\DoxyCodeLine{13181 \textcolor{keywordtype}{void} ConsoleReporter::testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \_testCaseStats) \{}
\DoxyCodeLine{13182     m\_tablePrinter->close();}
\DoxyCodeLine{13183     StreamingReporterBase::testCaseEnded(\_testCaseStats);}
\DoxyCodeLine{13184     m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{13185 \}}
\DoxyCodeLine{13186 \textcolor{keywordtype}{void} ConsoleReporter::testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \_testGroupStats) \{}
\DoxyCodeLine{13187     \textcolor{keywordflow}{if} (currentGroupInfo.used) \{}
\DoxyCodeLine{13188         printSummaryDivider();}
\DoxyCodeLine{13189         stream << \textcolor{stringliteral}{"Summary for group '"} << \_testGroupStats.groupInfo.name << \textcolor{stringliteral}{"':\(\backslash\)n"};}
\DoxyCodeLine{13190         printTotals(\_testGroupStats.totals);}
\DoxyCodeLine{13191         stream << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{13192     \}}
\DoxyCodeLine{13193     StreamingReporterBase::testGroupEnded(\_testGroupStats);}
\DoxyCodeLine{13194 \}}
\DoxyCodeLine{13195 \textcolor{keywordtype}{void} ConsoleReporter::testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \{}
\DoxyCodeLine{13196     printTotalsDivider(\_testRunStats.totals);}
\DoxyCodeLine{13197     printTotals(\_testRunStats.totals);}
\DoxyCodeLine{13198     stream << std::endl;}
\DoxyCodeLine{13199     StreamingReporterBase::testRunEnded(\_testRunStats);}
\DoxyCodeLine{13200 \}}
\DoxyCodeLine{13201 }
\DoxyCodeLine{13202 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrint() \{}
\DoxyCodeLine{13203 }
\DoxyCodeLine{13204     m\_tablePrinter->close();}
\DoxyCodeLine{13205     lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{13206 \}}
\DoxyCodeLine{13207 }
\DoxyCodeLine{13208 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() \{}
\DoxyCodeLine{13209 }
\DoxyCodeLine{13210     \textcolor{keywordflow}{if} (!currentTestRunInfo.used)}
\DoxyCodeLine{13211         lazyPrintRunInfo();}
\DoxyCodeLine{13212     \textcolor{keywordflow}{if} (!currentGroupInfo.used)}
\DoxyCodeLine{13213         lazyPrintGroupInfo();}
\DoxyCodeLine{13214 }
\DoxyCodeLine{13215     \textcolor{keywordflow}{if} (!m\_headerPrinted) \{}
\DoxyCodeLine{13216         printTestCaseAndSectionHeader();}
\DoxyCodeLine{13217         m\_headerPrinted = \textcolor{keyword}{true};}
\DoxyCodeLine{13218     \}}
\DoxyCodeLine{13219 \}}
\DoxyCodeLine{13220 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintRunInfo() \{}
\DoxyCodeLine{13221     stream << '\(\backslash\)n' << getLineOfChars<'~'>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13222     Colour colour(Colour::SecondaryText);}
\DoxyCodeLine{13223     stream << currentTestRunInfo->name}
\DoxyCodeLine{13224         << \textcolor{stringliteral}{" is a Catch v"} << libraryVersion() << \textcolor{stringliteral}{" host application.\(\backslash\)n"}}
\DoxyCodeLine{13225         << \textcolor{stringliteral}{"Run with -? for options\(\backslash\)n\(\backslash\)n"};}
\DoxyCodeLine{13226 }
\DoxyCodeLine{13227     \textcolor{keywordflow}{if} (m\_config->rngSeed() != 0)}
\DoxyCodeLine{13228         stream << \textcolor{stringliteral}{"Randomness seeded to: "} << m\_config->rngSeed() << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};}
\DoxyCodeLine{13229 }
\DoxyCodeLine{13230     currentTestRunInfo.used = \textcolor{keyword}{true};}
\DoxyCodeLine{13231 \}}
\DoxyCodeLine{13232 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintGroupInfo() \{}
\DoxyCodeLine{13233     \textcolor{keywordflow}{if} (!currentGroupInfo->name.empty() \&\& currentGroupInfo->groupsCounts > 1) \{}
\DoxyCodeLine{13234         printClosedHeader(\textcolor{stringliteral}{"Group: "} + currentGroupInfo->name);}
\DoxyCodeLine{13235         currentGroupInfo.used = \textcolor{keyword}{true};}
\DoxyCodeLine{13236     \}}
\DoxyCodeLine{13237 \}}
\DoxyCodeLine{13238 \textcolor{keywordtype}{void} ConsoleReporter::printTestCaseAndSectionHeader() \{}
\DoxyCodeLine{13239     assert(!m\_sectionStack.empty());}
\DoxyCodeLine{13240     printOpenHeader(currentTestCaseInfo->name);}
\DoxyCodeLine{13241 }
\DoxyCodeLine{13242     \textcolor{keywordflow}{if} (m\_sectionStack.size() > 1) \{}
\DoxyCodeLine{13243         Colour colourGuard(Colour::Headers);}
\DoxyCodeLine{13244 }
\DoxyCodeLine{13245         \textcolor{keyword}{auto}}
\DoxyCodeLine{13246             it = m\_sectionStack.begin() + 1, \textcolor{comment}{// Skip first section (test case)}}
\DoxyCodeLine{13247             itEnd = m\_sectionStack.end();}
\DoxyCodeLine{13248         \textcolor{keywordflow}{for} (; it != itEnd; ++it)}
\DoxyCodeLine{13249             printHeaderString(it->name, 2);}
\DoxyCodeLine{13250     \}}
\DoxyCodeLine{13251 }
\DoxyCodeLine{13252     SourceLineInfo lineInfo = m\_sectionStack.back().lineInfo;}
\DoxyCodeLine{13253 }
\DoxyCodeLine{13254     \textcolor{keywordflow}{if} (!lineInfo.empty()) \{}
\DoxyCodeLine{13255         stream << getLineOfChars<\textcolor{charliteral}{'-'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13256         Colour colourGuard(Colour::FileName);}
\DoxyCodeLine{13257         stream << lineInfo << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13258     \}}
\DoxyCodeLine{13259     stream << getLineOfChars<\textcolor{charliteral}{'.'}>() << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{13260 \}}
\DoxyCodeLine{13261 }
\DoxyCodeLine{13262 \textcolor{keywordtype}{void} ConsoleReporter::printClosedHeader(std::string \textcolor{keyword}{const}\& \_name) \{}
\DoxyCodeLine{13263     printOpenHeader(\_name);}
\DoxyCodeLine{13264     stream << getLineOfChars<\textcolor{charliteral}{'.'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13265 \}}
\DoxyCodeLine{13266 \textcolor{keywordtype}{void} ConsoleReporter::printOpenHeader(std::string \textcolor{keyword}{const}\& \_name) \{}
\DoxyCodeLine{13267     stream << getLineOfChars<\textcolor{charliteral}{'-'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13268     \{}
\DoxyCodeLine{13269         Colour colourGuard(Colour::Headers);}
\DoxyCodeLine{13270         printHeaderString(\_name);}
\DoxyCodeLine{13271     \}}
\DoxyCodeLine{13272 \}}
\DoxyCodeLine{13273 }
\DoxyCodeLine{13274 \textcolor{comment}{// if string has a : in first line will set indent to follow it on}}
\DoxyCodeLine{13275 \textcolor{comment}{// subsequent lines}}
\DoxyCodeLine{13276 \textcolor{keywordtype}{void} ConsoleReporter::printHeaderString(std::string \textcolor{keyword}{const}\& \_string, std::size\_t indent) \{}
\DoxyCodeLine{13277     std::size\_t i = \_string.find(\textcolor{stringliteral}{": "});}
\DoxyCodeLine{13278     \textcolor{keywordflow}{if} (i != std::string::npos)}
\DoxyCodeLine{13279         i += 2;}
\DoxyCodeLine{13280     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13281         i = 0;}
\DoxyCodeLine{13282     stream << Column(\_string).indent(indent + i).initialIndent(indent) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13283 \}}
\DoxyCodeLine{13284 }
\DoxyCodeLine{13285 \textcolor{keyword}{struct }SummaryColumn \{}
\DoxyCodeLine{13286 }
\DoxyCodeLine{13287     SummaryColumn( std::string \_label, Colour::Code \_colour )}
\DoxyCodeLine{13288     :   label( std::move( \_label ) ),}
\DoxyCodeLine{13289         colour( \_colour ) \{\}}
\DoxyCodeLine{13290     SummaryColumn addRow( std::size\_t count ) \{}
\DoxyCodeLine{13291         ReusableStringStream rss;}
\DoxyCodeLine{13292         rss << count;}
\DoxyCodeLine{13293         std::string row = rss.str();}
\DoxyCodeLine{13294         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& oldRow : rows) \{}
\DoxyCodeLine{13295             \textcolor{keywordflow}{while} (oldRow.size() < row.size())}
\DoxyCodeLine{13296                 oldRow = \textcolor{charliteral}{' '} + oldRow;}
\DoxyCodeLine{13297             \textcolor{keywordflow}{while} (oldRow.size() > row.size())}
\DoxyCodeLine{13298                 row = \textcolor{charliteral}{' '} + row;}
\DoxyCodeLine{13299         \}}
\DoxyCodeLine{13300         rows.push\_back(row);}
\DoxyCodeLine{13301         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{13302     \}}
\DoxyCodeLine{13303 }
\DoxyCodeLine{13304     std::string label;}
\DoxyCodeLine{13305     Colour::Code colour;}
\DoxyCodeLine{13306     std::vector<std::string> rows;}
\DoxyCodeLine{13307 }
\DoxyCodeLine{13308 \};}
\DoxyCodeLine{13309 }
\DoxyCodeLine{13310 \textcolor{keywordtype}{void} ConsoleReporter::printTotals( Totals \textcolor{keyword}{const}\& totals ) \{}
\DoxyCodeLine{13311     \textcolor{keywordflow}{if} (totals.testCases.total() == 0) \{}
\DoxyCodeLine{13312         stream << Colour(Colour::Warning) << \textcolor{stringliteral}{"No tests ran\(\backslash\)n"};}
\DoxyCodeLine{13313     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (totals.assertions.total() > 0 \&\& totals.testCases.allPassed()) \{}
\DoxyCodeLine{13314         stream << Colour(Colour::ResultSuccess) << \textcolor{stringliteral}{"All tests passed"};}
\DoxyCodeLine{13315         stream << \textcolor{stringliteral}{" ("}}
\DoxyCodeLine{13316             << pluralise(totals.assertions.passed, \textcolor{stringliteral}{"assertion"}) << \textcolor{stringliteral}{" in "}}
\DoxyCodeLine{13317             << pluralise(totals.testCases.passed, \textcolor{stringliteral}{"test case"}) << \textcolor{charliteral}{')'}}
\DoxyCodeLine{13318             << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13319     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13320 }
\DoxyCodeLine{13321         std::vector<SummaryColumn> columns;}
\DoxyCodeLine{13322         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{""}, Colour::None)}
\DoxyCodeLine{13323                           .addRow(totals.testCases.total())}
\DoxyCodeLine{13324                           .addRow(totals.assertions.total()));}
\DoxyCodeLine{13325         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"passed"}, Colour::Success)}
\DoxyCodeLine{13326                           .addRow(totals.testCases.passed)}
\DoxyCodeLine{13327                           .addRow(totals.assertions.passed));}
\DoxyCodeLine{13328         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"failed"}, Colour::ResultError)}
\DoxyCodeLine{13329                           .addRow(totals.testCases.failed)}
\DoxyCodeLine{13330                           .addRow(totals.assertions.failed));}
\DoxyCodeLine{13331         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"failed as expected"}, Colour::ResultExpectedFailure)}
\DoxyCodeLine{13332                           .addRow(totals.testCases.failedButOk)}
\DoxyCodeLine{13333                           .addRow(totals.assertions.failedButOk));}
\DoxyCodeLine{13334 }
\DoxyCodeLine{13335         printSummaryRow(\textcolor{stringliteral}{"test cases"}, columns, 0);}
\DoxyCodeLine{13336         printSummaryRow(\textcolor{stringliteral}{"assertions"}, columns, 1);}
\DoxyCodeLine{13337     \}}
\DoxyCodeLine{13338 \}}
\DoxyCodeLine{13339 \textcolor{keywordtype}{void} ConsoleReporter::printSummaryRow(std::string \textcolor{keyword}{const}\& label, std::vector<SummaryColumn> \textcolor{keyword}{const}\& cols, std::size\_t row) \{}
\DoxyCodeLine{13340     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} col : cols) \{}
\DoxyCodeLine{13341         std::string value = col.rows[row];}
\DoxyCodeLine{13342         \textcolor{keywordflow}{if} (col.label.empty()) \{}
\DoxyCodeLine{13343             stream << label << \textcolor{stringliteral}{": "};}
\DoxyCodeLine{13344             \textcolor{keywordflow}{if} (value != \textcolor{stringliteral}{"0"})}
\DoxyCodeLine{13345                 stream << value;}
\DoxyCodeLine{13346             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13347                 stream << Colour(Colour::Warning) << \textcolor{stringliteral}{"- none -"};}
\DoxyCodeLine{13348         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value != \textcolor{stringliteral}{"0"}) \{}
\DoxyCodeLine{13349             stream << Colour(Colour::LightGrey) << \textcolor{stringliteral}{" | "};}
\DoxyCodeLine{13350             stream << Colour(col.colour)}
\DoxyCodeLine{13351                 << value << \textcolor{charliteral}{' '} << col.label;}
\DoxyCodeLine{13352         \}}
\DoxyCodeLine{13353     \}}
\DoxyCodeLine{13354     stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13355 \}}
\DoxyCodeLine{13356 }
\DoxyCodeLine{13357 \textcolor{keywordtype}{void} ConsoleReporter::printTotalsDivider(Totals \textcolor{keyword}{const}\& totals) \{}
\DoxyCodeLine{13358     \textcolor{keywordflow}{if} (totals.testCases.total() > 0) \{}
\DoxyCodeLine{13359         std::size\_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());}
\DoxyCodeLine{13360         std::size\_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());}
\DoxyCodeLine{13361         std::size\_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());}
\DoxyCodeLine{13362         \textcolor{keywordflow}{while} (failedRatio + failedButOkRatio + passedRatio < CATCH\_CONFIG\_CONSOLE\_WIDTH - 1)}
\DoxyCodeLine{13363             findMax(failedRatio, failedButOkRatio, passedRatio)++;}
\DoxyCodeLine{13364         \textcolor{keywordflow}{while} (failedRatio + failedButOkRatio + passedRatio > CATCH\_CONFIG\_CONSOLE\_WIDTH - 1)}
\DoxyCodeLine{13365             findMax(failedRatio, failedButOkRatio, passedRatio)--;}
\DoxyCodeLine{13366 }
\DoxyCodeLine{13367         stream << Colour(Colour::Error) << std::string(failedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{13368         stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{13369         \textcolor{keywordflow}{if} (totals.testCases.allPassed())}
\DoxyCodeLine{13370             stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{13371         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13372             stream << Colour(Colour::Success) << std::string(passedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{13373     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13374         stream << Colour(Colour::Warning) << std::string(CATCH\_CONFIG\_CONSOLE\_WIDTH - 1, \textcolor{charliteral}{'='});}
\DoxyCodeLine{13375     \}}
\DoxyCodeLine{13376     stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13377 \}}
\DoxyCodeLine{13378 \textcolor{keywordtype}{void} ConsoleReporter::printSummaryDivider() \{}
\DoxyCodeLine{13379     stream << getLineOfChars<\textcolor{charliteral}{'-'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13380 \}}
\DoxyCodeLine{13381 }
\DoxyCodeLine{13382 CATCH\_REGISTER\_REPORTER(\textcolor{stringliteral}{"console"}, ConsoleReporter)}
\DoxyCodeLine{13383 }
\DoxyCodeLine{13384 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13385 }
\DoxyCodeLine{13386 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{13387 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{13388 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13389 \textcolor{comment}{// end catch\_reporter\_console.cpp}}
\DoxyCodeLine{13390 \textcolor{comment}{// start catch\_reporter\_junit.cpp}}
\DoxyCodeLine{13391 }
\DoxyCodeLine{13392 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{13393 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{13394 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{13395 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{13396 }
\DoxyCodeLine{13397 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13398 }
\DoxyCodeLine{13399     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13400         std::string getCurrentTimestamp() \{}
\DoxyCodeLine{13401             \textcolor{comment}{// Beware, this is not reentrant because of backward compatibility issues}}
\DoxyCodeLine{13402             \textcolor{comment}{// Also, UTC only, again because of backward compatibility (\%z is C++11)}}
\DoxyCodeLine{13403             time\_t rawtime;}
\DoxyCodeLine{13404             std::time(\&rawtime);}
\DoxyCodeLine{13405             \textcolor{keyword}{auto} \textcolor{keyword}{const} timeStampSize = \textcolor{keyword}{sizeof}(\textcolor{stringliteral}{"2017-01-16T17:06:45Z"});}
\DoxyCodeLine{13406 }
\DoxyCodeLine{13407 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{13408             std::tm timeInfo = \{\};}
\DoxyCodeLine{13409             gmtime\_s(\&timeInfo, \&rawtime);}
\DoxyCodeLine{13410 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{13411             std::tm* timeInfo;}
\DoxyCodeLine{13412             timeInfo = std::gmtime(\&rawtime);}
\DoxyCodeLine{13413 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13414 }
\DoxyCodeLine{13415             \textcolor{keywordtype}{char} timeStamp[timeStampSize];}
\DoxyCodeLine{13416             \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} fmt = \textcolor{stringliteral}{"\%Y-\%m-\%dT\%H:\%M:\%SZ"};}
\DoxyCodeLine{13417 }
\DoxyCodeLine{13418 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{13419             std::strftime(timeStamp, timeStampSize, fmt, \&timeInfo);}
\DoxyCodeLine{13420 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{13421             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);}
\DoxyCodeLine{13422 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13423             \textcolor{keywordflow}{return} std::string(timeStamp);}
\DoxyCodeLine{13424         \}}
\DoxyCodeLine{13425 }
\DoxyCodeLine{13426         std::string fileNameTag(\textcolor{keyword}{const} std::vector<std::string> \&tags) \{}
\DoxyCodeLine{13427             \textcolor{keyword}{auto} it = std::find\_if(begin(tags),}
\DoxyCodeLine{13428                                    end(tags),}
\DoxyCodeLine{13429                                    [] (std::string \textcolor{keyword}{const}\& tag) \{\textcolor{keywordflow}{return} tag.front() == \textcolor{charliteral}{'\#'}; \});}
\DoxyCodeLine{13430             \textcolor{keywordflow}{if} (it != tags.end())}
\DoxyCodeLine{13431                 \textcolor{keywordflow}{return} it->substr(1);}
\DoxyCodeLine{13432             \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{13433         \}}
\DoxyCodeLine{13434     \} \textcolor{comment}{// anonymous namespace}}
\DoxyCodeLine{13435 }
\DoxyCodeLine{13436     JunitReporter::JunitReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{13437         :   CumulativeReporterBase( \_config ),}
\DoxyCodeLine{13438             xml( \_config.stream() )}
\DoxyCodeLine{13439         \{}
\DoxyCodeLine{13440             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{true};}
\DoxyCodeLine{13441             m\_reporterPrefs.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{13442         \}}
\DoxyCodeLine{13443 }
\DoxyCodeLine{13444     JunitReporter::~JunitReporter() \{\}}
\DoxyCodeLine{13445 }
\DoxyCodeLine{13446     std::string JunitReporter::getDescription() \{}
\DoxyCodeLine{13447         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Reports test results in an XML format that looks like Ant's junitreport target"};}
\DoxyCodeLine{13448     \}}
\DoxyCodeLine{13449 }
\DoxyCodeLine{13450     \textcolor{keywordtype}{void} JunitReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& \textcolor{comment}{/*spec*/} ) \{\}}
\DoxyCodeLine{13451 }
\DoxyCodeLine{13452     \textcolor{keywordtype}{void} JunitReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& runInfo )  \{}
\DoxyCodeLine{13453         CumulativeReporterBase::testRunStarting( runInfo );}
\DoxyCodeLine{13454         xml.startElement( \textcolor{stringliteral}{"testsuites"} );}
\DoxyCodeLine{13455     \}}
\DoxyCodeLine{13456 }
\DoxyCodeLine{13457     \textcolor{keywordtype}{void} JunitReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{13458         suiteTimer.start();}
\DoxyCodeLine{13459         stdOutForSuite.clear();}
\DoxyCodeLine{13460         stdErrForSuite.clear();}
\DoxyCodeLine{13461         unexpectedExceptions = 0;}
\DoxyCodeLine{13462         CumulativeReporterBase::testGroupStarting( groupInfo );}
\DoxyCodeLine{13463     \}}
\DoxyCodeLine{13464 }
\DoxyCodeLine{13465     \textcolor{keywordtype}{void} JunitReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo ) \{}
\DoxyCodeLine{13466         m\_okToFail = testCaseInfo.okToFail();}
\DoxyCodeLine{13467     \}}
\DoxyCodeLine{13468 }
\DoxyCodeLine{13469     \textcolor{keywordtype}{bool} JunitReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{13470         \textcolor{keywordflow}{if}( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException \&\& !m\_okToFail )}
\DoxyCodeLine{13471             unexpectedExceptions++;}
\DoxyCodeLine{13472         \textcolor{keywordflow}{return} CumulativeReporterBase::assertionEnded( assertionStats );}
\DoxyCodeLine{13473     \}}
\DoxyCodeLine{13474 }
\DoxyCodeLine{13475     \textcolor{keywordtype}{void} JunitReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{13476         stdOutForSuite += testCaseStats.stdOut;}
\DoxyCodeLine{13477         stdErrForSuite += testCaseStats.stdErr;}
\DoxyCodeLine{13478         CumulativeReporterBase::testCaseEnded( testCaseStats );}
\DoxyCodeLine{13479     \}}
\DoxyCodeLine{13480 }
\DoxyCodeLine{13481     \textcolor{keywordtype}{void} JunitReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{13482         \textcolor{keywordtype}{double} suiteTime = suiteTimer.getElapsedSeconds();}
\DoxyCodeLine{13483         CumulativeReporterBase::testGroupEnded( testGroupStats );}
\DoxyCodeLine{13484         writeGroup( *m\_testGroups.back(), suiteTime );}
\DoxyCodeLine{13485     \}}
\DoxyCodeLine{13486 }
\DoxyCodeLine{13487     \textcolor{keywordtype}{void} JunitReporter::testRunEndedCumulative() \{}
\DoxyCodeLine{13488         xml.endElement();}
\DoxyCodeLine{13489     \}}
\DoxyCodeLine{13490 }
\DoxyCodeLine{13491     \textcolor{keywordtype}{void} JunitReporter::writeGroup( TestGroupNode \textcolor{keyword}{const}\& groupNode, \textcolor{keywordtype}{double} suiteTime ) \{}
\DoxyCodeLine{13492         XmlWriter::ScopedElement e = xml.scopedElement( \textcolor{stringliteral}{"testsuite"} );}
\DoxyCodeLine{13493         TestGroupStats \textcolor{keyword}{const}\& stats = groupNode.value;}
\DoxyCodeLine{13494         xml.writeAttribute( \textcolor{stringliteral}{"name"}, stats.groupInfo.name );}
\DoxyCodeLine{13495         xml.writeAttribute( \textcolor{stringliteral}{"errors"}, unexpectedExceptions );}
\DoxyCodeLine{13496         xml.writeAttribute( \textcolor{stringliteral}{"failures"}, stats.totals.assertions.failed-unexpectedExceptions );}
\DoxyCodeLine{13497         xml.writeAttribute( \textcolor{stringliteral}{"tests"}, stats.totals.assertions.total() );}
\DoxyCodeLine{13498         xml.writeAttribute( \textcolor{stringliteral}{"hostname"}, \textcolor{stringliteral}{"tbd"} ); \textcolor{comment}{// !TBD}}
\DoxyCodeLine{13499         \textcolor{keywordflow}{if}( m\_config->showDurations() == ShowDurations::Never )}
\DoxyCodeLine{13500             xml.writeAttribute( \textcolor{stringliteral}{"time"}, \textcolor{stringliteral}{""} );}
\DoxyCodeLine{13501         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13502             xml.writeAttribute( \textcolor{stringliteral}{"time"}, suiteTime );}
\DoxyCodeLine{13503         xml.writeAttribute( \textcolor{stringliteral}{"timestamp"}, getCurrentTimestamp() );}
\DoxyCodeLine{13504 }
\DoxyCodeLine{13505         \textcolor{comment}{// Write test cases}}
\DoxyCodeLine{13506         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& child : groupNode.children )}
\DoxyCodeLine{13507             writeTestCase( *child );}
\DoxyCodeLine{13508 }
\DoxyCodeLine{13509         xml.scopedElement( \textcolor{stringliteral}{"system-out"} ).writeText( trim( stdOutForSuite ), \textcolor{keyword}{false} );}
\DoxyCodeLine{13510         xml.scopedElement( \textcolor{stringliteral}{"system-err"} ).writeText( trim( stdErrForSuite ), \textcolor{keyword}{false} );}
\DoxyCodeLine{13511     \}}
\DoxyCodeLine{13512 }
\DoxyCodeLine{13513     \textcolor{keywordtype}{void} JunitReporter::writeTestCase( TestCaseNode \textcolor{keyword}{const}\& testCaseNode ) \{}
\DoxyCodeLine{13514         TestCaseStats \textcolor{keyword}{const}\& stats = testCaseNode.value;}
\DoxyCodeLine{13515 }
\DoxyCodeLine{13516         \textcolor{comment}{// All test cases have exactly one section - which represents the}}
\DoxyCodeLine{13517         \textcolor{comment}{// test case itself. That section may have 0-n nested sections}}
\DoxyCodeLine{13518         assert( testCaseNode.children.size() == 1 );}
\DoxyCodeLine{13519         SectionNode \textcolor{keyword}{const}\& rootSection = *testCaseNode.children.front();}
\DoxyCodeLine{13520 }
\DoxyCodeLine{13521         std::string className = stats.testInfo.className;}
\DoxyCodeLine{13522 }
\DoxyCodeLine{13523         \textcolor{keywordflow}{if}( className.empty() ) \{}
\DoxyCodeLine{13524             className = fileNameTag(stats.testInfo.tags);}
\DoxyCodeLine{13525             \textcolor{keywordflow}{if} ( className.empty() )}
\DoxyCodeLine{13526                 className = \textcolor{stringliteral}{"global"};}
\DoxyCodeLine{13527         \}}
\DoxyCodeLine{13528 }
\DoxyCodeLine{13529         \textcolor{keywordflow}{if} ( !m\_config->name().empty() )}
\DoxyCodeLine{13530             className = m\_config->name() + "." + className;}
\DoxyCodeLine{13531 }
\DoxyCodeLine{13532         writeSection( className, \textcolor{stringliteral}{""}, rootSection );}
\DoxyCodeLine{13533     \}}
\DoxyCodeLine{13534 }
\DoxyCodeLine{13535     \textcolor{keywordtype}{void} JunitReporter::writeSection(  std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{13536                         std::string \textcolor{keyword}{const}\& rootName,}
\DoxyCodeLine{13537                         SectionNode \textcolor{keyword}{const}\& sectionNode ) \{}
\DoxyCodeLine{13538         std::string name = trim( sectionNode.stats.sectionInfo.name );}
\DoxyCodeLine{13539         \textcolor{keywordflow}{if}( !rootName.empty() )}
\DoxyCodeLine{13540             name = rootName + \textcolor{charliteral}{'/'} + name;}
\DoxyCodeLine{13541 }
\DoxyCodeLine{13542         \textcolor{keywordflow}{if}( !sectionNode.assertions.empty() ||}
\DoxyCodeLine{13543             !sectionNode.stdOut.empty() ||}
\DoxyCodeLine{13544             !sectionNode.stdErr.empty() ) \{}
\DoxyCodeLine{13545             XmlWriter::ScopedElement e = xml.scopedElement( \textcolor{stringliteral}{"testcase"} );}
\DoxyCodeLine{13546             \textcolor{keywordflow}{if}( className.empty() ) \{}
\DoxyCodeLine{13547                 xml.writeAttribute( \textcolor{stringliteral}{"classname"}, name );}
\DoxyCodeLine{13548                 xml.writeAttribute( \textcolor{stringliteral}{"name"}, \textcolor{stringliteral}{"root"} );}
\DoxyCodeLine{13549             \}}
\DoxyCodeLine{13550             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13551                 xml.writeAttribute( \textcolor{stringliteral}{"classname"}, className );}
\DoxyCodeLine{13552                 xml.writeAttribute( \textcolor{stringliteral}{"name"}, name );}
\DoxyCodeLine{13553             \}}
\DoxyCodeLine{13554             xml.writeAttribute( \textcolor{stringliteral}{"time"}, ::Catch::Detail::stringify( sectionNode.stats.durationInSeconds ) );}
\DoxyCodeLine{13555 }
\DoxyCodeLine{13556             writeAssertions( sectionNode );}
\DoxyCodeLine{13557 }
\DoxyCodeLine{13558             \textcolor{keywordflow}{if}( !sectionNode.stdOut.empty() )}
\DoxyCodeLine{13559                 xml.scopedElement( \textcolor{stringliteral}{"system-out"} ).writeText( trim( sectionNode.stdOut ), \textcolor{keyword}{false} );}
\DoxyCodeLine{13560             \textcolor{keywordflow}{if}( !sectionNode.stdErr.empty() )}
\DoxyCodeLine{13561                 xml.scopedElement( \textcolor{stringliteral}{"system-err"} ).writeText( trim( sectionNode.stdErr ), \textcolor{keyword}{false} );}
\DoxyCodeLine{13562         \}}
\DoxyCodeLine{13563         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& childNode : sectionNode.childSections )}
\DoxyCodeLine{13564             \textcolor{keywordflow}{if}( className.empty() )}
\DoxyCodeLine{13565                 writeSection( name, \textcolor{stringliteral}{""}, *childNode );}
\DoxyCodeLine{13566             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13567                 writeSection( className, name, *childNode );}
\DoxyCodeLine{13568     \}}
\DoxyCodeLine{13569 }
\DoxyCodeLine{13570     \textcolor{keywordtype}{void} JunitReporter::writeAssertions( SectionNode \textcolor{keyword}{const}\& sectionNode ) \{}
\DoxyCodeLine{13571         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& assertion : sectionNode.assertions )}
\DoxyCodeLine{13572             writeAssertion( assertion );}
\DoxyCodeLine{13573     \}}
\DoxyCodeLine{13574 }
\DoxyCodeLine{13575     \textcolor{keywordtype}{void} JunitReporter::writeAssertion( AssertionStats \textcolor{keyword}{const}\& stats ) \{}
\DoxyCodeLine{13576         AssertionResult \textcolor{keyword}{const}\& result = stats.assertionResult;}
\DoxyCodeLine{13577         \textcolor{keywordflow}{if}( !result.isOk() ) \{}
\DoxyCodeLine{13578             std::string elementName;}
\DoxyCodeLine{13579             \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{13580                 \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{13581                 \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{13582                     elementName = \textcolor{stringliteral}{"error"};}
\DoxyCodeLine{13583                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{13584                 \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{13585                     elementName = \textcolor{stringliteral}{"failure"};}
\DoxyCodeLine{13586                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{13587                 \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{13588                     elementName = \textcolor{stringliteral}{"failure"};}
\DoxyCodeLine{13589                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{13590                 \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{13591                     elementName = \textcolor{stringliteral}{"failure"};}
\DoxyCodeLine{13592                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{13593 }
\DoxyCodeLine{13594                 \textcolor{comment}{// We should never see these here:}}
\DoxyCodeLine{13595                 \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{13596                 \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{13597                 \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{13598                 \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{13599                 \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{13600                 \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{13601                     elementName = \textcolor{stringliteral}{"internalError"};}
\DoxyCodeLine{13602                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{13603             \}}
\DoxyCodeLine{13604 }
\DoxyCodeLine{13605             XmlWriter::ScopedElement e = xml.scopedElement( elementName );}
\DoxyCodeLine{13606 }
\DoxyCodeLine{13607             xml.writeAttribute( \textcolor{stringliteral}{"message"}, result.getExpandedExpression() );}
\DoxyCodeLine{13608             xml.writeAttribute( \textcolor{stringliteral}{"type"}, result.getTestMacroName() );}
\DoxyCodeLine{13609 }
\DoxyCodeLine{13610             ReusableStringStream rss;}
\DoxyCodeLine{13611             \textcolor{keywordflow}{if}( !result.getMessage().empty() )}
\DoxyCodeLine{13612                 rss << result.getMessage() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13613             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : stats.infoMessages )}
\DoxyCodeLine{13614                 \textcolor{keywordflow}{if}( msg.type == ResultWas::Info )}
\DoxyCodeLine{13615                     rss << msg.message << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13616 }
\DoxyCodeLine{13617             rss << \textcolor{stringliteral}{"at "} << result.getSourceInfo();}
\DoxyCodeLine{13618             xml.writeText( rss.str(), false );}
\DoxyCodeLine{13619         \}}
\DoxyCodeLine{13620     \}}
\DoxyCodeLine{13621 }
\DoxyCodeLine{13622     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"junit"}, JunitReporter )}
\DoxyCodeLine{13623 }
\DoxyCodeLine{13624 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13625 \textcolor{comment}{// end catch\_reporter\_junit.cpp}}
\DoxyCodeLine{13626 \textcolor{comment}{// start catch\_reporter\_listening.cpp}}
\DoxyCodeLine{13627 }
\DoxyCodeLine{13628 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{13629 }
\DoxyCodeLine{13630 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13631 }
\DoxyCodeLine{13632     ListeningReporter::ListeningReporter() \{}
\DoxyCodeLine{13633         \textcolor{comment}{// We will assume that listeners will always want all assertions}}
\DoxyCodeLine{13634         m\_preferences.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{13635     \}}
\DoxyCodeLine{13636 }
\DoxyCodeLine{13637     \textcolor{keywordtype}{void} ListeningReporter::addListener( IStreamingReporterPtr\&\& listener ) \{}
\DoxyCodeLine{13638         m\_listeners.push\_back( std::move( listener ) );}
\DoxyCodeLine{13639     \}}
\DoxyCodeLine{13640 }
\DoxyCodeLine{13641     \textcolor{keywordtype}{void} ListeningReporter::addReporter(IStreamingReporterPtr\&\& reporter) \{}
\DoxyCodeLine{13642         assert(!m\_reporter \&\& \textcolor{stringliteral}{"Listening reporter can wrap only 1 real reporter"});}
\DoxyCodeLine{13643         m\_reporter = std::move( reporter );}
\DoxyCodeLine{13644         m\_preferences.shouldRedirectStdOut = m\_reporter->getPreferences().shouldRedirectStdOut;}
\DoxyCodeLine{13645     \}}
\DoxyCodeLine{13646 }
\DoxyCodeLine{13647     ReporterPreferences ListeningReporter::getPreferences()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13648         \textcolor{keywordflow}{return} m\_preferences;}
\DoxyCodeLine{13649     \}}
\DoxyCodeLine{13650 }
\DoxyCodeLine{13651     std::set<Verbosity> ListeningReporter::getSupportedVerbosities() \{}
\DoxyCodeLine{13652         \textcolor{keywordflow}{return} std::set<Verbosity>\{ \};}
\DoxyCodeLine{13653     \}}
\DoxyCodeLine{13654 }
\DoxyCodeLine{13655     \textcolor{keywordtype}{void} ListeningReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) \{}
\DoxyCodeLine{13656         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13657             listener->noMatchingTestCases( spec );}
\DoxyCodeLine{13658         \}}
\DoxyCodeLine{13659         m\_reporter->noMatchingTestCases( spec );}
\DoxyCodeLine{13660     \}}
\DoxyCodeLine{13661 }
\DoxyCodeLine{13662     \textcolor{keywordtype}{void} ListeningReporter::benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& benchmarkInfo ) \{}
\DoxyCodeLine{13663         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13664             listener->benchmarkStarting( benchmarkInfo );}
\DoxyCodeLine{13665         \}}
\DoxyCodeLine{13666         m\_reporter->benchmarkStarting( benchmarkInfo );}
\DoxyCodeLine{13667     \}}
\DoxyCodeLine{13668     \textcolor{keywordtype}{void} ListeningReporter::benchmarkEnded( BenchmarkStats \textcolor{keyword}{const}\& benchmarkStats ) \{}
\DoxyCodeLine{13669         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13670             listener->benchmarkEnded( benchmarkStats );}
\DoxyCodeLine{13671         \}}
\DoxyCodeLine{13672         m\_reporter->benchmarkEnded( benchmarkStats );}
\DoxyCodeLine{13673     \}}
\DoxyCodeLine{13674 }
\DoxyCodeLine{13675     \textcolor{keywordtype}{void} ListeningReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) \{}
\DoxyCodeLine{13676         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13677             listener->testRunStarting( testRunInfo );}
\DoxyCodeLine{13678         \}}
\DoxyCodeLine{13679         m\_reporter->testRunStarting( testRunInfo );}
\DoxyCodeLine{13680     \}}
\DoxyCodeLine{13681 }
\DoxyCodeLine{13682     \textcolor{keywordtype}{void} ListeningReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{13683         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13684             listener->testGroupStarting( groupInfo );}
\DoxyCodeLine{13685         \}}
\DoxyCodeLine{13686         m\_reporter->testGroupStarting( groupInfo );}
\DoxyCodeLine{13687     \}}
\DoxyCodeLine{13688 }
\DoxyCodeLine{13689     \textcolor{keywordtype}{void} ListeningReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{13690         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13691             listener->testCaseStarting( testInfo );}
\DoxyCodeLine{13692         \}}
\DoxyCodeLine{13693         m\_reporter->testCaseStarting( testInfo );}
\DoxyCodeLine{13694     \}}
\DoxyCodeLine{13695 }
\DoxyCodeLine{13696     \textcolor{keywordtype}{void} ListeningReporter::sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \{}
\DoxyCodeLine{13697         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13698             listener->sectionStarting( sectionInfo );}
\DoxyCodeLine{13699         \}}
\DoxyCodeLine{13700         m\_reporter->sectionStarting( sectionInfo );}
\DoxyCodeLine{13701     \}}
\DoxyCodeLine{13702 }
\DoxyCodeLine{13703     \textcolor{keywordtype}{void} ListeningReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) \{}
\DoxyCodeLine{13704         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13705             listener->assertionStarting( assertionInfo );}
\DoxyCodeLine{13706         \}}
\DoxyCodeLine{13707         m\_reporter->assertionStarting( assertionInfo );}
\DoxyCodeLine{13708     \}}
\DoxyCodeLine{13709 }
\DoxyCodeLine{13710     \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{13711     \textcolor{keywordtype}{bool} ListeningReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{13712         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13713             static\_cast<void>( listener->assertionEnded( assertionStats ) );}
\DoxyCodeLine{13714         \}}
\DoxyCodeLine{13715         \textcolor{keywordflow}{return} m\_reporter->assertionEnded( assertionStats );}
\DoxyCodeLine{13716     \}}
\DoxyCodeLine{13717 }
\DoxyCodeLine{13718     \textcolor{keywordtype}{void} ListeningReporter::sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \{}
\DoxyCodeLine{13719         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13720             listener->sectionEnded( sectionStats );}
\DoxyCodeLine{13721         \}}
\DoxyCodeLine{13722         m\_reporter->sectionEnded( sectionStats );}
\DoxyCodeLine{13723     \}}
\DoxyCodeLine{13724 }
\DoxyCodeLine{13725     \textcolor{keywordtype}{void} ListeningReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{13726         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13727             listener->testCaseEnded( testCaseStats );}
\DoxyCodeLine{13728         \}}
\DoxyCodeLine{13729         m\_reporter->testCaseEnded( testCaseStats );}
\DoxyCodeLine{13730     \}}
\DoxyCodeLine{13731 }
\DoxyCodeLine{13732     \textcolor{keywordtype}{void} ListeningReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{13733         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13734             listener->testGroupEnded( testGroupStats );}
\DoxyCodeLine{13735         \}}
\DoxyCodeLine{13736         m\_reporter->testGroupEnded( testGroupStats );}
\DoxyCodeLine{13737     \}}
\DoxyCodeLine{13738 }
\DoxyCodeLine{13739     \textcolor{keywordtype}{void} ListeningReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \{}
\DoxyCodeLine{13740         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13741             listener->testRunEnded( testRunStats );}
\DoxyCodeLine{13742         \}}
\DoxyCodeLine{13743         m\_reporter->testRunEnded( testRunStats );}
\DoxyCodeLine{13744     \}}
\DoxyCodeLine{13745 }
\DoxyCodeLine{13746     \textcolor{keywordtype}{void} ListeningReporter::skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{13747         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{13748             listener->skipTest( testInfo );}
\DoxyCodeLine{13749         \}}
\DoxyCodeLine{13750         m\_reporter->skipTest( testInfo );}
\DoxyCodeLine{13751     \}}
\DoxyCodeLine{13752 }
\DoxyCodeLine{13753     \textcolor{keywordtype}{bool} ListeningReporter::isMulti()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13754         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{13755     \}}
\DoxyCodeLine{13756 }
\DoxyCodeLine{13757 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13758 \textcolor{comment}{// end catch\_reporter\_listening.cpp}}
\DoxyCodeLine{13759 \textcolor{comment}{// start catch\_reporter\_xml.cpp}}
\DoxyCodeLine{13760 }
\DoxyCodeLine{13761 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{13762 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{13763 \textcolor{preprocessor}{\#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{13764                               \textcolor{comment}{// Note that 4062 (not all labels are handled}}
\DoxyCodeLine{13765                               \textcolor{comment}{// and default is missing) is enabled}}
\DoxyCodeLine{13766 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13767 }
\DoxyCodeLine{13768 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13769     XmlReporter::XmlReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{13770     :   StreamingReporterBase( \_config ),}
\DoxyCodeLine{13771         m\_xml(\_config.stream())}
\DoxyCodeLine{13772     \{}
\DoxyCodeLine{13773         m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{true};}
\DoxyCodeLine{13774         m\_reporterPrefs.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{13775     \}}
\DoxyCodeLine{13776 }
\DoxyCodeLine{13777     XmlReporter::~XmlReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13778 }
\DoxyCodeLine{13779     std::string XmlReporter::getDescription() \{}
\DoxyCodeLine{13780         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Reports test results as an XML document"};}
\DoxyCodeLine{13781     \}}
\DoxyCodeLine{13782 }
\DoxyCodeLine{13783     std::string XmlReporter::getStylesheetRef()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13784         \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{13785     \}}
\DoxyCodeLine{13786 }
\DoxyCodeLine{13787     \textcolor{keywordtype}{void} XmlReporter::writeSourceInfo( SourceLineInfo \textcolor{keyword}{const}\& sourceInfo ) \{}
\DoxyCodeLine{13788         m\_xml}
\DoxyCodeLine{13789             .writeAttribute( \textcolor{stringliteral}{"filename"}, sourceInfo.file )}
\DoxyCodeLine{13790             .writeAttribute( \textcolor{stringliteral}{"line"}, sourceInfo.line );}
\DoxyCodeLine{13791     \}}
\DoxyCodeLine{13792 }
\DoxyCodeLine{13793     \textcolor{keywordtype}{void} XmlReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& s ) \{}
\DoxyCodeLine{13794         StreamingReporterBase::noMatchingTestCases( s );}
\DoxyCodeLine{13795     \}}
\DoxyCodeLine{13796 }
\DoxyCodeLine{13797     \textcolor{keywordtype}{void} XmlReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{13798         StreamingReporterBase::testRunStarting( testInfo );}
\DoxyCodeLine{13799         std::string stylesheetRef = getStylesheetRef();}
\DoxyCodeLine{13800         \textcolor{keywordflow}{if}( !stylesheetRef.empty() )}
\DoxyCodeLine{13801             m\_xml.writeStylesheetRef( stylesheetRef );}
\DoxyCodeLine{13802         m\_xml.startElement( \textcolor{stringliteral}{"Catch"} );}
\DoxyCodeLine{13803         \textcolor{keywordflow}{if}( !m\_config->name().empty() )}
\DoxyCodeLine{13804             m\_xml.writeAttribute( \textcolor{stringliteral}{"name"}, m\_config->name() );}
\DoxyCodeLine{13805         \textcolor{keywordflow}{if}( m\_config->rngSeed() != 0 )}
\DoxyCodeLine{13806             m\_xml.scopedElement( \textcolor{stringliteral}{"Randomness"} )}
\DoxyCodeLine{13807                 .writeAttribute( \textcolor{stringliteral}{"seed"}, m\_config->rngSeed() );}
\DoxyCodeLine{13808     \}}
\DoxyCodeLine{13809 }
\DoxyCodeLine{13810     \textcolor{keywordtype}{void} XmlReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{13811         StreamingReporterBase::testGroupStarting( groupInfo );}
\DoxyCodeLine{13812         m\_xml.startElement( \textcolor{stringliteral}{"Group"} )}
\DoxyCodeLine{13813             .writeAttribute( \textcolor{stringliteral}{"name"}, groupInfo.name );}
\DoxyCodeLine{13814     \}}
\DoxyCodeLine{13815 }
\DoxyCodeLine{13816     \textcolor{keywordtype}{void} XmlReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{13817         StreamingReporterBase::testCaseStarting(testInfo);}
\DoxyCodeLine{13818         m\_xml.startElement( \textcolor{stringliteral}{"TestCase"} )}
\DoxyCodeLine{13819             .writeAttribute( \textcolor{stringliteral}{"name"}, trim( testInfo.name ) )}
\DoxyCodeLine{13820             .writeAttribute( \textcolor{stringliteral}{"description"}, testInfo.description )}
\DoxyCodeLine{13821             .writeAttribute( \textcolor{stringliteral}{"tags"}, testInfo.tagsAsString() );}
\DoxyCodeLine{13822 }
\DoxyCodeLine{13823         writeSourceInfo( testInfo.lineInfo );}
\DoxyCodeLine{13824 }
\DoxyCodeLine{13825         \textcolor{keywordflow}{if} ( m\_config->showDurations() == ShowDurations::Always )}
\DoxyCodeLine{13826             m\_testCaseTimer.start();}
\DoxyCodeLine{13827         m\_xml.ensureTagClosed();}
\DoxyCodeLine{13828     \}}
\DoxyCodeLine{13829 }
\DoxyCodeLine{13830     \textcolor{keywordtype}{void} XmlReporter::sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \{}
\DoxyCodeLine{13831         StreamingReporterBase::sectionStarting( sectionInfo );}
\DoxyCodeLine{13832         \textcolor{keywordflow}{if}( m\_sectionDepth++ > 0 ) \{}
\DoxyCodeLine{13833             m\_xml.startElement( \textcolor{stringliteral}{"Section"} )}
\DoxyCodeLine{13834                 .writeAttribute( \textcolor{stringliteral}{"name"}, trim( sectionInfo.name ) );}
\DoxyCodeLine{13835             writeSourceInfo( sectionInfo.lineInfo );}
\DoxyCodeLine{13836             m\_xml.ensureTagClosed();}
\DoxyCodeLine{13837         \}}
\DoxyCodeLine{13838     \}}
\DoxyCodeLine{13839 }
\DoxyCodeLine{13840     \textcolor{keywordtype}{void} XmlReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) \{ \}}
\DoxyCodeLine{13841 }
\DoxyCodeLine{13842     \textcolor{keywordtype}{bool} XmlReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{13843 }
\DoxyCodeLine{13844         AssertionResult \textcolor{keyword}{const}\& result = assertionStats.assertionResult;}
\DoxyCodeLine{13845 }
\DoxyCodeLine{13846         \textcolor{keywordtype}{bool} includeResults = m\_config->includeSuccessfulResults() || !result.isOk();}
\DoxyCodeLine{13847 }
\DoxyCodeLine{13848         \textcolor{keywordflow}{if}( includeResults || result.getResultType() == ResultWas::Warning ) \{}
\DoxyCodeLine{13849             \textcolor{comment}{// Print any info messages in <Info> tags.}}
\DoxyCodeLine{13850             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : assertionStats.infoMessages ) \{}
\DoxyCodeLine{13851                 \textcolor{keywordflow}{if}( msg.type == ResultWas::Info \&\& includeResults ) \{}
\DoxyCodeLine{13852                     m\_xml.scopedElement( \textcolor{stringliteral}{"Info"} )}
\DoxyCodeLine{13853                             .writeText( msg.message );}
\DoxyCodeLine{13854                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( msg.type == ResultWas::Warning ) \{}
\DoxyCodeLine{13855                     m\_xml.scopedElement( \textcolor{stringliteral}{"Warning"} )}
\DoxyCodeLine{13856                             .writeText( msg.message );}
\DoxyCodeLine{13857                 \}}
\DoxyCodeLine{13858             \}}
\DoxyCodeLine{13859         \}}
\DoxyCodeLine{13860 }
\DoxyCodeLine{13861         \textcolor{comment}{// Drop out if result was successful but we're not printing them.}}
\DoxyCodeLine{13862         \textcolor{keywordflow}{if}( !includeResults \&\& result.getResultType() != ResultWas::Warning )}
\DoxyCodeLine{13863             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{13864 }
\DoxyCodeLine{13865         \textcolor{comment}{// Print the expression if there is one.}}
\DoxyCodeLine{13866         \textcolor{keywordflow}{if}( result.hasExpression() ) \{}
\DoxyCodeLine{13867             m\_xml.startElement( \textcolor{stringliteral}{"Expression"} )}
\DoxyCodeLine{13868                 .writeAttribute( \textcolor{stringliteral}{"success"}, result.succeeded() )}
\DoxyCodeLine{13869                 .writeAttribute( \textcolor{stringliteral}{"type"}, result.getTestMacroName() );}
\DoxyCodeLine{13870 }
\DoxyCodeLine{13871             writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{13872 }
\DoxyCodeLine{13873             m\_xml.scopedElement( \textcolor{stringliteral}{"Original"} )}
\DoxyCodeLine{13874                 .writeText( result.getExpression() );}
\DoxyCodeLine{13875             m\_xml.scopedElement( \textcolor{stringliteral}{"Expanded"} )}
\DoxyCodeLine{13876                 .writeText( result.getExpandedExpression() );}
\DoxyCodeLine{13877         \}}
\DoxyCodeLine{13878 }
\DoxyCodeLine{13879         \textcolor{comment}{// And... Print a result applicable to each result type.}}
\DoxyCodeLine{13880         \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{13881             \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{13882                 m\_xml.startElement( \textcolor{stringliteral}{"Exception"} );}
\DoxyCodeLine{13883                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{13884                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{13885                 m\_xml.endElement();}
\DoxyCodeLine{13886                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13887             \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{13888                 m\_xml.startElement( \textcolor{stringliteral}{"FatalErrorCondition"} );}
\DoxyCodeLine{13889                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{13890                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{13891                 m\_xml.endElement();}
\DoxyCodeLine{13892                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13893             \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{13894                 m\_xml.scopedElement( \textcolor{stringliteral}{"Info"} )}
\DoxyCodeLine{13895                     .writeText( result.getMessage() );}
\DoxyCodeLine{13896                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13897             \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{13898                 \textcolor{comment}{// Warning will already have been written}}
\DoxyCodeLine{13899                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13900             \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{13901                 m\_xml.startElement( \textcolor{stringliteral}{"Failure"} );}
\DoxyCodeLine{13902                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{13903                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{13904                 m\_xml.endElement();}
\DoxyCodeLine{13905                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13906             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13907                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13908         \}}
\DoxyCodeLine{13909 }
\DoxyCodeLine{13910         \textcolor{keywordflow}{if}( result.hasExpression() )}
\DoxyCodeLine{13911             m\_xml.endElement();}
\DoxyCodeLine{13912 }
\DoxyCodeLine{13913         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{13914     \}}
\DoxyCodeLine{13915 }
\DoxyCodeLine{13916     \textcolor{keywordtype}{void} XmlReporter::sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \{}
\DoxyCodeLine{13917         StreamingReporterBase::sectionEnded( sectionStats );}
\DoxyCodeLine{13918         \textcolor{keywordflow}{if}( --m\_sectionDepth > 0 ) \{}
\DoxyCodeLine{13919             XmlWriter::ScopedElement e = m\_xml.scopedElement( \textcolor{stringliteral}{"OverallResults"} );}
\DoxyCodeLine{13920             e.writeAttribute( \textcolor{stringliteral}{"successes"}, sectionStats.assertions.passed );}
\DoxyCodeLine{13921             e.writeAttribute( \textcolor{stringliteral}{"failures"}, sectionStats.assertions.failed );}
\DoxyCodeLine{13922             e.writeAttribute( \textcolor{stringliteral}{"expectedFailures"}, sectionStats.assertions.failedButOk );}
\DoxyCodeLine{13923 }
\DoxyCodeLine{13924             \textcolor{keywordflow}{if} ( m\_config->showDurations() == ShowDurations::Always )}
\DoxyCodeLine{13925                 e.writeAttribute( \textcolor{stringliteral}{"durationInSeconds"}, sectionStats.durationInSeconds );}
\DoxyCodeLine{13926 }
\DoxyCodeLine{13927             m\_xml.endElement();}
\DoxyCodeLine{13928         \}}
\DoxyCodeLine{13929     \}}
\DoxyCodeLine{13930 }
\DoxyCodeLine{13931     \textcolor{keywordtype}{void} XmlReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{13932         StreamingReporterBase::testCaseEnded( testCaseStats );}
\DoxyCodeLine{13933         XmlWriter::ScopedElement e = m\_xml.scopedElement( \textcolor{stringliteral}{"OverallResult"} );}
\DoxyCodeLine{13934         e.writeAttribute( \textcolor{stringliteral}{"success"}, testCaseStats.totals.assertions.allOk() );}
\DoxyCodeLine{13935 }
\DoxyCodeLine{13936         \textcolor{keywordflow}{if} ( m\_config->showDurations() == ShowDurations::Always )}
\DoxyCodeLine{13937             e.writeAttribute( \textcolor{stringliteral}{"durationInSeconds"}, m\_testCaseTimer.getElapsedSeconds() );}
\DoxyCodeLine{13938 }
\DoxyCodeLine{13939         \textcolor{keywordflow}{if}( !testCaseStats.stdOut.empty() )}
\DoxyCodeLine{13940             m\_xml.scopedElement( \textcolor{stringliteral}{"StdOut"} ).writeText( trim( testCaseStats.stdOut ), \textcolor{keyword}{false} );}
\DoxyCodeLine{13941         \textcolor{keywordflow}{if}( !testCaseStats.stdErr.empty() )}
\DoxyCodeLine{13942             m\_xml.scopedElement( \textcolor{stringliteral}{"StdErr"} ).writeText( trim( testCaseStats.stdErr ), \textcolor{keyword}{false} );}
\DoxyCodeLine{13943 }
\DoxyCodeLine{13944         m\_xml.endElement();}
\DoxyCodeLine{13945     \}}
\DoxyCodeLine{13946 }
\DoxyCodeLine{13947     \textcolor{keywordtype}{void} XmlReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{13948         StreamingReporterBase::testGroupEnded( testGroupStats );}
\DoxyCodeLine{13949         \textcolor{comment}{// TODO: Check testGroupStats.aborting and act accordingly.}}
\DoxyCodeLine{13950         m\_xml.scopedElement( \textcolor{stringliteral}{"OverallResults"} )}
\DoxyCodeLine{13951             .writeAttribute( \textcolor{stringliteral}{"successes"}, testGroupStats.totals.assertions.passed )}
\DoxyCodeLine{13952             .writeAttribute( \textcolor{stringliteral}{"failures"}, testGroupStats.totals.assertions.failed )}
\DoxyCodeLine{13953             .writeAttribute( \textcolor{stringliteral}{"expectedFailures"}, testGroupStats.totals.assertions.failedButOk );}
\DoxyCodeLine{13954         m\_xml.endElement();}
\DoxyCodeLine{13955     \}}
\DoxyCodeLine{13956 }
\DoxyCodeLine{13957     \textcolor{keywordtype}{void} XmlReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \{}
\DoxyCodeLine{13958         StreamingReporterBase::testRunEnded( testRunStats );}
\DoxyCodeLine{13959         m\_xml.scopedElement( \textcolor{stringliteral}{"OverallResults"} )}
\DoxyCodeLine{13960             .writeAttribute( \textcolor{stringliteral}{"successes"}, testRunStats.totals.assertions.passed )}
\DoxyCodeLine{13961             .writeAttribute( \textcolor{stringliteral}{"failures"}, testRunStats.totals.assertions.failed )}
\DoxyCodeLine{13962             .writeAttribute( \textcolor{stringliteral}{"expectedFailures"}, testRunStats.totals.assertions.failedButOk );}
\DoxyCodeLine{13963         m\_xml.endElement();}
\DoxyCodeLine{13964     \}}
\DoxyCodeLine{13965 }
\DoxyCodeLine{13966     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"xml"}, XmlReporter )}
\DoxyCodeLine{13967 }
\DoxyCodeLine{13968 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13969 }
\DoxyCodeLine{13970 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{13971 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{13972 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13973 \textcolor{comment}{// end catch\_reporter\_xml.cpp}}
\DoxyCodeLine{13974 }
\DoxyCodeLine{13975 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13976     LeakDetector leakDetector;}
\DoxyCodeLine{13977 \}}
\DoxyCodeLine{13978 }
\DoxyCodeLine{13979 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{13980 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{13981 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13982 }
\DoxyCodeLine{13983 \textcolor{comment}{// end catch\_impl.hpp}}
\DoxyCodeLine{13984 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13985 }
\DoxyCodeLine{13986 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_MAIN}}
\DoxyCodeLine{13987 \textcolor{comment}{// start catch\_default\_main.hpp}}
\DoxyCodeLine{13988 }
\DoxyCodeLine{13989 \textcolor{preprocessor}{\#ifndef \_\_OBJC\_\_}}
\DoxyCodeLine{13990 }
\DoxyCodeLine{13991 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(WIN32) \&\& defined(\_UNICODE) \&\& !defined(DO\_NOT\_USE\_WMAIN)}}
\DoxyCodeLine{13992 \textcolor{comment}{// Standard C/C++ Win32 Unicode wmain entry point}}
\DoxyCodeLine{13993 \textcolor{keyword}{extern} \textcolor{stringliteral}{"C"} \textcolor{keywordtype}{int} wmain (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} * argv[], \textcolor{keywordtype}{wchar\_t} * []) \{}
\DoxyCodeLine{13994 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{13995 \textcolor{comment}{// Standard C/C++ main entry point}}
\DoxyCodeLine{13996 \textcolor{keywordtype}{int} main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} * argv[]) \{}
\DoxyCodeLine{13997 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13998 }
\DoxyCodeLine{13999     \textcolor{keywordflow}{return} Catch::Session().run( argc, argv );}
\DoxyCodeLine{14000 \}}
\DoxyCodeLine{14001 }
\DoxyCodeLine{14002 \textcolor{preprocessor}{\#else // \_\_OBJC\_\_}}
\DoxyCodeLine{14003 }
\DoxyCodeLine{14004 \textcolor{comment}{// Objective-C entry point}}
\DoxyCodeLine{14005 \textcolor{keywordtype}{int} main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} * \textcolor{keyword}{const} argv[]) \{}
\DoxyCodeLine{14006 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{14007     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];}
\DoxyCodeLine{14008 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14009 }
\DoxyCodeLine{14010     Catch::registerTestMethods();}
\DoxyCodeLine{14011     \textcolor{keywordtype}{int} result = Catch::Session().run( argc, (\textcolor{keywordtype}{char}**)argv );}
\DoxyCodeLine{14012 }
\DoxyCodeLine{14013 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{14014     [pool drain];}
\DoxyCodeLine{14015 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14016 }
\DoxyCodeLine{14017     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{14018 \}}
\DoxyCodeLine{14019 }
\DoxyCodeLine{14020 \textcolor{preprocessor}{\#endif // \_\_OBJC\_\_}}
\DoxyCodeLine{14021 }
\DoxyCodeLine{14022 \textcolor{comment}{// end catch\_default\_main.hpp}}
\DoxyCodeLine{14023 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14024 }
\DoxyCodeLine{14025 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_IMPL\_ONLY)}}
\DoxyCodeLine{14026 }
\DoxyCodeLine{14027 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_MAIN\_NOT\_DEFINED}}
\DoxyCodeLine{14028 \textcolor{preprocessor}{\#  undef CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{14029 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14030 }
\DoxyCodeLine{14031 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{14032 \textcolor{comment}{// If this config identifier is defined then all CATCH macros are prefixed with CATCH\_}}
\DoxyCodeLine{14034 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_PREFIX\_ALL}}
\DoxyCodeLine{14035 }
\DoxyCodeLine{14036 \textcolor{preprocessor}{\#define CATCH\_REQUIRE( ... ) INTERNAL\_CATCH\_TEST( "CATCH\_REQUIRE", Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14037 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "CATCH\_REQUIRE\_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14038 }
\DoxyCodeLine{14039 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS( ... ) INTERNAL\_CATCH\_THROWS( "CATCH\_REQUIRE\_THROWS", Catch::ResultDisposition::Normal, "", \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14040 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "CATCH\_REQUIRE\_THROWS\_AS", exceptionType, Catch::ResultDisposition::Normal, expr )}}
\DoxyCodeLine{14041 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "CATCH\_REQUIRE\_THROWS\_WITH", Catch::ResultDisposition::Normal, matcher, expr )}}
\DoxyCodeLine{14042 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14043 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "CATCH\_REQUIRE\_THROWS\_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}}
\DoxyCodeLine{14044 \textcolor{preprocessor}{\#endif// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14045 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "CATCH\_REQUIRE\_NOTHROW", Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14046 }
\DoxyCodeLine{14047 \textcolor{preprocessor}{\#define CATCH\_CHECK( ... ) INTERNAL\_CATCH\_TEST( "CATCH\_CHECK", Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14048 \textcolor{preprocessor}{\#define CATCH\_CHECK\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "CATCH\_CHECK\_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14049 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_IF( ... ) INTERNAL\_CATCH\_IF( "CATCH\_CHECKED\_IF", Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14050 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_ELSE( ... ) INTERNAL\_CATCH\_ELSE( "CATCH\_CHECKED\_ELSE", Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14051 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOFAIL( ... ) INTERNAL\_CATCH\_TEST( "CATCH\_CHECK\_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14052 }
\DoxyCodeLine{14053 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS( ... )  INTERNAL\_CATCH\_THROWS( "CATCH\_CHECK\_THROWS", Catch::ResultDisposition::ContinueOnFailure, "", \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14054 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "CATCH\_CHECK\_THROWS\_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}}
\DoxyCodeLine{14055 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "CATCH\_CHECK\_THROWS\_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}}
\DoxyCodeLine{14056 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14057 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "CATCH\_CHECK\_THROWS\_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}}
\DoxyCodeLine{14058 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14059 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "CATCH\_CHECK\_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14060 }
\DoxyCodeLine{14061 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14062 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "CATCH\_CHECK\_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}}
\DoxyCodeLine{14063 }
\DoxyCodeLine{14064 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "CATCH\_REQUIRE\_THAT", matcher, Catch::ResultDisposition::Normal, arg )}}
\DoxyCodeLine{14065 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14066 }
\DoxyCodeLine{14067 \textcolor{preprocessor}{\#define CATCH\_INFO( msg ) INTERNAL\_CATCH\_INFO( "CATCH\_INFO", msg )}}
\DoxyCodeLine{14068 \textcolor{preprocessor}{\#define CATCH\_WARN( msg ) INTERNAL\_CATCH\_MSG( "CATCH\_WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}}
\DoxyCodeLine{14069 \textcolor{preprocessor}{\#define CATCH\_CAPTURE( ... ) INTERNAL\_CATCH\_CAPTURE( INTERNAL\_CATCH\_UNIQUE\_NAME(capturer), "CATCH\_CAPTURE",\_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14070 }
\DoxyCodeLine{14071 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14072 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14073 \textcolor{preprocessor}{\#define CATCH\_METHOD\_AS\_TEST\_CASE( method, ... ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14074 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TEST\_CASE( Function, ... ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14075 \textcolor{preprocessor}{\#define CATCH\_SECTION( ... ) INTERNAL\_CATCH\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14076 \textcolor{preprocessor}{\#define CATCH\_DYNAMIC\_SECTION( ... ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14077 \textcolor{preprocessor}{\#define CATCH\_FAIL( ... ) INTERNAL\_CATCH\_MSG( "CATCH\_FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14078 \textcolor{preprocessor}{\#define CATCH\_FAIL\_CHECK( ... ) INTERNAL\_CATCH\_MSG( "CATCH\_FAIL\_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14079 \textcolor{preprocessor}{\#define CATCH\_SUCCEED( ... ) INTERNAL\_CATCH\_MSG( "CATCH\_SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14080 }
\DoxyCodeLine{14081 \textcolor{preprocessor}{\#define CATCH\_ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE()}}
\DoxyCodeLine{14082 }
\DoxyCodeLine{14083 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{14084 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14085 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14086 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{14087 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{14088 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{14089 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14090 }
\DoxyCodeLine{14091 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_RUNTIME\_STATIC\_REQUIRE)}}
\DoxyCodeLine{14092 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       static\_assert(   \_\_VA\_ARGS\_\_ ,      \#\_\_VA\_ARGS\_\_ );     CATCH\_SUCCEED( \#\_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14093 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) static\_assert( !(\_\_VA\_ARGS\_\_), "!(" \#\_\_VA\_ARGS\_\_ ")" ); CATCH\_SUCCEED( \#\_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14094 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{14095 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       CATCH\_REQUIRE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14096 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) CATCH\_REQUIRE\_FALSE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14097 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14098 }
\DoxyCodeLine{14099 \textcolor{comment}{// "BDD-style" convenience wrappers}}
\DoxyCodeLine{14100 \textcolor{preprocessor}{\#define CATCH\_SCENARIO( ... ) CATCH\_TEST\_CASE( "Scenario: " \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14101 \textcolor{preprocessor}{\#define CATCH\_SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "Scenario: " \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14102 \textcolor{preprocessor}{\#define CATCH\_GIVEN( desc )     INTERNAL\_CATCH\_DYNAMIC\_SECTION( "    Given: " << desc )}}
\DoxyCodeLine{14103 \textcolor{preprocessor}{\#define CATCH\_AND\_GIVEN( desc ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( "And given: " << desc )}}
\DoxyCodeLine{14104 \textcolor{preprocessor}{\#define CATCH\_WHEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "     When: " << desc )}}
\DoxyCodeLine{14105 \textcolor{preprocessor}{\#define CATCH\_AND\_WHEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( " And when: " << desc )}}
\DoxyCodeLine{14106 \textcolor{preprocessor}{\#define CATCH\_THEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "     Then: " << desc )}}
\DoxyCodeLine{14107 \textcolor{preprocessor}{\#define CATCH\_AND\_THEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "      And: " << desc )}}
\DoxyCodeLine{14108 }
\DoxyCodeLine{14109 \textcolor{comment}{// If CATCH\_CONFIG\_PREFIX\_ALL is not defined then the CATCH\_ prefix is not required}}
\DoxyCodeLine{14110 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{14111 }
\DoxyCodeLine{14112 \textcolor{preprocessor}{\#define REQUIRE( ... ) INTERNAL\_CATCH\_TEST( "REQUIRE", Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_  )}}
\DoxyCodeLine{14113 \textcolor{preprocessor}{\#define REQUIRE\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "REQUIRE\_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14114 }
\DoxyCodeLine{14115 \textcolor{preprocessor}{\#define REQUIRE\_THROWS( ... ) INTERNAL\_CATCH\_THROWS( "REQUIRE\_THROWS", Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14116 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "REQUIRE\_THROWS\_AS", exceptionType, Catch::ResultDisposition::Normal, expr )}}
\DoxyCodeLine{14117 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "REQUIRE\_THROWS\_WITH", Catch::ResultDisposition::Normal, matcher, expr )}}
\DoxyCodeLine{14118 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14119 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "REQUIRE\_THROWS\_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}}
\DoxyCodeLine{14120 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14121 \textcolor{preprocessor}{\#define REQUIRE\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "REQUIRE\_NOTHROW", Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14122 }
\DoxyCodeLine{14123 \textcolor{preprocessor}{\#define CHECK( ... ) INTERNAL\_CATCH\_TEST( "CHECK", Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14124 \textcolor{preprocessor}{\#define CHECK\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "CHECK\_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14125 \textcolor{preprocessor}{\#define CHECKED\_IF( ... ) INTERNAL\_CATCH\_IF( "CHECKED\_IF", Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14126 \textcolor{preprocessor}{\#define CHECKED\_ELSE( ... ) INTERNAL\_CATCH\_ELSE( "CHECKED\_ELSE", Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14127 \textcolor{preprocessor}{\#define CHECK\_NOFAIL( ... ) INTERNAL\_CATCH\_TEST( "CHECK\_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14128 }
\DoxyCodeLine{14129 \textcolor{preprocessor}{\#define CHECK\_THROWS( ... )  INTERNAL\_CATCH\_THROWS( "CHECK\_THROWS", Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14130 \textcolor{preprocessor}{\#define CHECK\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "CHECK\_THROWS\_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}}
\DoxyCodeLine{14131 \textcolor{preprocessor}{\#define CHECK\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "CHECK\_THROWS\_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}}
\DoxyCodeLine{14132 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14133 \textcolor{preprocessor}{\#define CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "CHECK\_THROWS\_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}}
\DoxyCodeLine{14134 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14135 \textcolor{preprocessor}{\#define CHECK\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "CHECK\_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14136 }
\DoxyCodeLine{14137 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14138 \textcolor{preprocessor}{\#define CHECK\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "CHECK\_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}}
\DoxyCodeLine{14139 }
\DoxyCodeLine{14140 \textcolor{preprocessor}{\#define REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "REQUIRE\_THAT", matcher, Catch::ResultDisposition::Normal, arg )}}
\DoxyCodeLine{14141 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14142 }
\DoxyCodeLine{14143 \textcolor{preprocessor}{\#define INFO( msg ) INTERNAL\_CATCH\_INFO( "INFO", msg )}}
\DoxyCodeLine{14144 \textcolor{preprocessor}{\#define WARN( msg ) INTERNAL\_CATCH\_MSG( "WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}}
\DoxyCodeLine{14145 \textcolor{preprocessor}{\#define CAPTURE( ... ) INTERNAL\_CATCH\_CAPTURE( INTERNAL\_CATCH\_UNIQUE\_NAME(capturer), "CAPTURE",\_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14146 }
\DoxyCodeLine{14147 \textcolor{preprocessor}{\#define TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14148 \textcolor{preprocessor}{\#define TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14149 \textcolor{preprocessor}{\#define METHOD\_AS\_TEST\_CASE( method, ... ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14150 \textcolor{preprocessor}{\#define REGISTER\_TEST\_CASE( Function, ... ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14151 \textcolor{preprocessor}{\#define SECTION( ... ) INTERNAL\_CATCH\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14152 \textcolor{preprocessor}{\#define DYNAMIC\_SECTION( ... ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14153 \textcolor{preprocessor}{\#define FAIL( ... ) INTERNAL\_CATCH\_MSG( "FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14154 \textcolor{preprocessor}{\#define FAIL\_CHECK( ... ) INTERNAL\_CATCH\_MSG( "FAIL\_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14155 \textcolor{preprocessor}{\#define SUCCEED( ... ) INTERNAL\_CATCH\_MSG( "SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14156 \textcolor{preprocessor}{\#define ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE()}}
\DoxyCodeLine{14157 }
\DoxyCodeLine{14158 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{14159 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14160 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14161 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{14162 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{14163 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{14164 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14165 }
\DoxyCodeLine{14166 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_RUNTIME\_STATIC\_REQUIRE)}}
\DoxyCodeLine{14167 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       static\_assert(   \_\_VA\_ARGS\_\_,  \#\_\_VA\_ARGS\_\_ ); SUCCEED( \#\_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14168 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) static\_assert( !(\_\_VA\_ARGS\_\_), "!(" \#\_\_VA\_ARGS\_\_ ")" ); SUCCEED( "!(" \#\_\_VA\_ARGS\_\_ ")" )}}
\DoxyCodeLine{14169 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{14170 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       REQUIRE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14171 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) REQUIRE\_FALSE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14172 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14173 }
\DoxyCodeLine{14174 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14175 }
\DoxyCodeLine{14176 \textcolor{preprocessor}{\#define CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION( signature )}}
\DoxyCodeLine{14177 }
\DoxyCodeLine{14178 \textcolor{comment}{// "BDD-style" convenience wrappers}}
\DoxyCodeLine{14179 \textcolor{preprocessor}{\#define SCENARIO( ... ) TEST\_CASE( "Scenario: " \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14180 \textcolor{preprocessor}{\#define SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "Scenario: " \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{14181 }
\DoxyCodeLine{14182 \textcolor{preprocessor}{\#define GIVEN( desc )     INTERNAL\_CATCH\_DYNAMIC\_SECTION( "    Given: " << desc )}}
\DoxyCodeLine{14183 \textcolor{preprocessor}{\#define AND\_GIVEN( desc ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( "And given: " << desc )}}
\DoxyCodeLine{14184 \textcolor{preprocessor}{\#define WHEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "     When: " << desc )}}
\DoxyCodeLine{14185 \textcolor{preprocessor}{\#define AND\_WHEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( " And when: " << desc )}}
\DoxyCodeLine{14186 \textcolor{preprocessor}{\#define THEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "     Then: " << desc )}}
\DoxyCodeLine{14187 \textcolor{preprocessor}{\#define AND\_THEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "      And: " << desc )}}
\DoxyCodeLine{14188 }
\DoxyCodeLine{14189 \textcolor{keyword}{using} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Catch::Detail::Approx}};}
\DoxyCodeLine{14190 }
\DoxyCodeLine{14191 \textcolor{preprocessor}{\#else // CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{14192 }
\DoxyCodeLine{14194 \textcolor{comment}{// If this config identifier is defined then all CATCH macros are prefixed with CATCH\_}}
\DoxyCodeLine{14195 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_PREFIX\_ALL}}
\DoxyCodeLine{14196 }
\DoxyCodeLine{14197 \textcolor{preprocessor}{\#define CATCH\_REQUIRE( ... )        (void)(0)}}
\DoxyCodeLine{14198 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_FALSE( ... )  (void)(0)}}
\DoxyCodeLine{14199 }
\DoxyCodeLine{14200 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS( ... ) (void)(0)}}
\DoxyCodeLine{14201 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{14202 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_WITH( expr, matcher )     (void)(0)}}
\DoxyCodeLine{14203 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14204 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{14205 \textcolor{preprocessor}{\#endif// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14206 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{14207 }
\DoxyCodeLine{14208 \textcolor{preprocessor}{\#define CATCH\_CHECK( ... )         (void)(0)}}
\DoxyCodeLine{14209 \textcolor{preprocessor}{\#define CATCH\_CHECK\_FALSE( ... )   (void)(0)}}
\DoxyCodeLine{14210 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_IF( ... )    if (\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{14211 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_ELSE( ... )  if (!(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{14212 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOFAIL( ... )  (void)(0)}}
\DoxyCodeLine{14213 }
\DoxyCodeLine{14214 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS( ... )  (void)(0)}}
\DoxyCodeLine{14215 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{14216 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_WITH( expr, matcher )     (void)(0)}}
\DoxyCodeLine{14217 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14218 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{14219 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14220 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{14221 }
\DoxyCodeLine{14222 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14223 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THAT( arg, matcher )   (void)(0)}}
\DoxyCodeLine{14224 }
\DoxyCodeLine{14225 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{14226 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14227 }
\DoxyCodeLine{14228 \textcolor{preprocessor}{\#define CATCH\_INFO( msg )    (void)(0)}}
\DoxyCodeLine{14229 \textcolor{preprocessor}{\#define CATCH\_WARN( msg )    (void)(0)}}
\DoxyCodeLine{14230 \textcolor{preprocessor}{\#define CATCH\_CAPTURE( msg ) (void)(0)}}
\DoxyCodeLine{14231 }
\DoxyCodeLine{14232 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{14233 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{14234 \textcolor{preprocessor}{\#define CATCH\_METHOD\_AS\_TEST\_CASE( method, ... )}}
\DoxyCodeLine{14235 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TEST\_CASE( Function, ... ) (void)(0)}}
\DoxyCodeLine{14236 \textcolor{preprocessor}{\#define CATCH\_SECTION( ... )}}
\DoxyCodeLine{14237 \textcolor{preprocessor}{\#define CATCH\_DYNAMIC\_SECTION( ... )}}
\DoxyCodeLine{14238 \textcolor{preprocessor}{\#define CATCH\_FAIL( ... ) (void)(0)}}
\DoxyCodeLine{14239 \textcolor{preprocessor}{\#define CATCH\_FAIL\_CHECK( ... ) (void)(0)}}
\DoxyCodeLine{14240 \textcolor{preprocessor}{\#define CATCH\_SUCCEED( ... ) (void)(0)}}
\DoxyCodeLine{14241 }
\DoxyCodeLine{14242 \textcolor{preprocessor}{\#define CATCH\_ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{14243 }
\DoxyCodeLine{14244 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{14245 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) )}}
\DoxyCodeLine{14246 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), className )}}
\DoxyCodeLine{14247 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{14248 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) ) )}}
\DoxyCodeLine{14249 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), className ) )}}
\DoxyCodeLine{14250 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14251 }
\DoxyCodeLine{14252 \textcolor{comment}{// "BDD-style" convenience wrappers}}
\DoxyCodeLine{14253 \textcolor{preprocessor}{\#define CATCH\_SCENARIO( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{14254 \textcolor{preprocessor}{\#define CATCH\_SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), className )}}
\DoxyCodeLine{14255 \textcolor{preprocessor}{\#define CATCH\_GIVEN( desc )}}
\DoxyCodeLine{14256 \textcolor{preprocessor}{\#define CATCH\_AND\_GIVEN( desc )}}
\DoxyCodeLine{14257 \textcolor{preprocessor}{\#define CATCH\_WHEN( desc )}}
\DoxyCodeLine{14258 \textcolor{preprocessor}{\#define CATCH\_AND\_WHEN( desc )}}
\DoxyCodeLine{14259 \textcolor{preprocessor}{\#define CATCH\_THEN( desc )}}
\DoxyCodeLine{14260 \textcolor{preprocessor}{\#define CATCH\_AND\_THEN( desc )}}
\DoxyCodeLine{14261 }
\DoxyCodeLine{14262 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{14263 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{14264 }
\DoxyCodeLine{14265 \textcolor{comment}{// If CATCH\_CONFIG\_PREFIX\_ALL is not defined then the CATCH\_ prefix is not required}}
\DoxyCodeLine{14266 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{14267 }
\DoxyCodeLine{14268 \textcolor{preprocessor}{\#define REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{14269 \textcolor{preprocessor}{\#define REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{14270 }
\DoxyCodeLine{14271 \textcolor{preprocessor}{\#define REQUIRE\_THROWS( ... ) (void)(0)}}
\DoxyCodeLine{14272 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{14273 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_WITH( expr, matcher ) (void)(0)}}
\DoxyCodeLine{14274 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14275 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{14276 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14277 \textcolor{preprocessor}{\#define REQUIRE\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{14278 }
\DoxyCodeLine{14279 \textcolor{preprocessor}{\#define CHECK( ... ) (void)(0)}}
\DoxyCodeLine{14280 \textcolor{preprocessor}{\#define CHECK\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{14281 \textcolor{preprocessor}{\#define CHECKED\_IF( ... ) if (\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{14282 \textcolor{preprocessor}{\#define CHECKED\_ELSE( ... ) if (!(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{14283 \textcolor{preprocessor}{\#define CHECK\_NOFAIL( ... ) (void)(0)}}
\DoxyCodeLine{14284 }
\DoxyCodeLine{14285 \textcolor{preprocessor}{\#define CHECK\_THROWS( ... )  (void)(0)}}
\DoxyCodeLine{14286 \textcolor{preprocessor}{\#define CHECK\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{14287 \textcolor{preprocessor}{\#define CHECK\_THROWS\_WITH( expr, matcher ) (void)(0)}}
\DoxyCodeLine{14288 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14289 \textcolor{preprocessor}{\#define CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{14290 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14291 \textcolor{preprocessor}{\#define CHECK\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{14292 }
\DoxyCodeLine{14293 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{14294 \textcolor{preprocessor}{\#define CHECK\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{14295 }
\DoxyCodeLine{14296 \textcolor{preprocessor}{\#define REQUIRE\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{14297 \textcolor{preprocessor}{\#endif // CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{14298 }
\DoxyCodeLine{14299 \textcolor{preprocessor}{\#define INFO( msg ) (void)(0)}}
\DoxyCodeLine{14300 \textcolor{preprocessor}{\#define WARN( msg ) (void)(0)}}
\DoxyCodeLine{14301 \textcolor{preprocessor}{\#define CAPTURE( msg ) (void)(0)}}
\DoxyCodeLine{14302 }
\DoxyCodeLine{14303 \textcolor{preprocessor}{\#define TEST\_CASE( ... )  INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{14304 \textcolor{preprocessor}{\#define TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{14305 \textcolor{preprocessor}{\#define METHOD\_AS\_TEST\_CASE( method, ... )}}
\DoxyCodeLine{14306 \textcolor{preprocessor}{\#define REGISTER\_TEST\_CASE( Function, ... ) (void)(0)}}
\DoxyCodeLine{14307 \textcolor{preprocessor}{\#define SECTION( ... )}}
\DoxyCodeLine{14308 \textcolor{preprocessor}{\#define DYNAMIC\_SECTION( ... )}}
\DoxyCodeLine{14309 \textcolor{preprocessor}{\#define FAIL( ... ) (void)(0)}}
\DoxyCodeLine{14310 \textcolor{preprocessor}{\#define FAIL\_CHECK( ... ) (void)(0)}}
\DoxyCodeLine{14311 \textcolor{preprocessor}{\#define SUCCEED( ... ) (void)(0)}}
\DoxyCodeLine{14312 \textcolor{preprocessor}{\#define ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{14313 }
\DoxyCodeLine{14314 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{14315 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) )}}
\DoxyCodeLine{14316 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), className )}}
\DoxyCodeLine{14317 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{14318 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) ) )}}
\DoxyCodeLine{14319 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), className ) )}}
\DoxyCodeLine{14320 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14321 }
\DoxyCodeLine{14322 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{14323 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{14324 }
\DoxyCodeLine{14325 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14326 }
\DoxyCodeLine{14327 \textcolor{preprocessor}{\#define CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION\_NO\_REG( INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionTranslator ), signature )}}
\DoxyCodeLine{14328 }
\DoxyCodeLine{14329 \textcolor{comment}{// "BDD-style" convenience wrappers}}
\DoxyCodeLine{14330 \textcolor{preprocessor}{\#define SCENARIO( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ) )}}
\DoxyCodeLine{14331 \textcolor{preprocessor}{\#define SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), className )}}
\DoxyCodeLine{14332 }
\DoxyCodeLine{14333 \textcolor{preprocessor}{\#define GIVEN( desc )}}
\DoxyCodeLine{14334 \textcolor{preprocessor}{\#define AND\_GIVEN( desc )}}
\DoxyCodeLine{14335 \textcolor{preprocessor}{\#define WHEN( desc )}}
\DoxyCodeLine{14336 \textcolor{preprocessor}{\#define AND\_WHEN( desc )}}
\DoxyCodeLine{14337 \textcolor{preprocessor}{\#define THEN( desc )}}
\DoxyCodeLine{14338 \textcolor{preprocessor}{\#define AND\_THEN( desc )}}
\DoxyCodeLine{14339 }
\DoxyCodeLine{14340 \textcolor{keyword}{using} \mbox{\hyperlink{classCatch_1_1Detail_1_1Approx}{Catch::Detail::Approx}};}
\DoxyCodeLine{14341 }
\DoxyCodeLine{14342 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14343 }
\DoxyCodeLine{14344 \textcolor{preprocessor}{\#endif // ! CATCH\_CONFIG\_IMPL\_ONLY}}
\DoxyCodeLine{14345 }
\DoxyCodeLine{14346 \textcolor{comment}{// start catch\_reenable\_warnings.h}}
\DoxyCodeLine{14347 }
\DoxyCodeLine{14348 }
\DoxyCodeLine{14349 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{14350 \textcolor{preprocessor}{\#    ifdef \_\_ICC // icpc defines the \_\_clang\_\_ macro}}
\DoxyCodeLine{14351 \textcolor{preprocessor}{\#        pragma warning(pop)}}
\DoxyCodeLine{14352 \textcolor{preprocessor}{\#    else}}
\DoxyCodeLine{14353 \textcolor{preprocessor}{\#        pragma clang diagnostic pop}}
\DoxyCodeLine{14354 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{14355 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{14356 \textcolor{preprocessor}{\#    pragma GCC diagnostic pop}}
\DoxyCodeLine{14357 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14358 }
\DoxyCodeLine{14359 \textcolor{comment}{// end catch\_reenable\_warnings.h}}
\DoxyCodeLine{14360 \textcolor{comment}{// end catch.hpp}}
\DoxyCodeLine{14361 \textcolor{preprocessor}{\#endif // TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{14362 }

\end{DoxyCode}
